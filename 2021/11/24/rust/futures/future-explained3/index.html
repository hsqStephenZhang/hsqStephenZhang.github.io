

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="mem::swap(Rust, 🦀 )">
  <meta name="keywords" content="">
  
    <meta name="description" content="withoutboats 是 Rust 异步的主要负责人，他在一次分享中详细描述了 Pin 的演变过程和背后的心路历程 1. Future 模式引入在 Rust 之前的很多语言，绝大多数选择了回调机制实现的异步逻辑，比如C语言中的 libevent，再还有 nodejs 中的 callback。首先在 Rust 中，你很难写出 nodejs 那种回调模式的异步代码，下面是一小段典型的 nodejs">
<meta property="og:type" content="article">
<meta property="og:title" content="future explained(3)">
<meta property="og:url" content="https://hsqstephenzhang.github.io/2021/11/24/rust/futures/future-explained3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="withoutboats 是 Rust 异步的主要负责人，他在一次分享中详细描述了 Pin 的演变过程和背后的心路历程 1. Future 模式引入在 Rust 之前的很多语言，绝大多数选择了回调机制实现的异步逻辑，比如C语言中的 libevent，再还有 nodejs 中的 callback。首先在 Rust 中，你很难写出 nodejs 那种回调模式的异步代码，下面是一小段典型的 nodejs">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://hsqstephenzhang.github.io/images/pin1.png">
<meta property="og:image" content="https://hsqstephenzhang.github.io/images/pin1.png">
<meta property="article:published_time" content="2021-11-24T06:04:29.000Z">
<meta property="article:modified_time" content="2022-01-22T14:36:58.858Z">
<meta property="article:author" content="mem::swap(Rust, 🦀 )">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://hsqstephenzhang.github.io/images/pin1.png">
  
  
  <title>future explained(3) - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"hsqstephenzhang.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>mem::swap</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-user-fill"></i>
                Links
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="future explained(3)">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-24 14:04" pubdate>
        November 24, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      96 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">future explained(3)</h1>
            
            <div class="markdown-body">
              <p>withoutboats 是 Rust 异步的主要负责人，他在一次分享中详细描述了 Pin 的演变过程和背后的心路历程</p>
<h2 id="1-Future-模式引入"><a href="#1-Future-模式引入" class="headerlink" title="1. Future 模式引入"></a>1. Future 模式引入</h2><p>在 Rust 之前的很多语言，绝大多数选择了回调机制实现的异步逻辑，比如C语言中的 libevent，再还有 nodejs 中的 callback。<br>首先在 Rust 中，你很难写出 <code>nodejs</code> 那种回调模式的异步代码，下面是一小段典型的 <code>nodejs</code> 回调模型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_foos</span></span>(client: Client) -&gt; <span class="hljs-keyword">impl</span> Future&lt;Output = <span class="hljs-built_in">Vec</span>&lt;Response&gt;&gt;&#123;<br>    client.get_index(<span class="hljs-string">&quot;/foos&quot;</span>).and_then(|index|&#123;<br>        client.get_responses(&amp;index).collect()<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 Rust 中，且不说回调地狱问题，关键是这种写法 <strong>根 本 编 译 不 过!</strong></p>
<p>这段代码，在 Rust 中存在很严重的所有权和生命周期问题，你会得到各种各样的编译错误。根据 rustc 的提示，缝缝补补，你或许会用下面这种方式去处理，也确实可以编译，但也仅此而已。且不说为了编译通过而付出的努力，单单是 Arc 和 Mutex 带来的额外开销，也是无法接受的。当创建大型程序时，简直无法想象。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_foos</span></span>(client: Client) -&gt; <span class="hljs-keyword">impl</span> Future&lt;Output = <span class="hljs-built_in">Vec</span>&lt;Response&gt;&gt;&#123;<br>    <span class="hljs-keyword">let</span> client: Arc&lt;Mutex&lt;Client&gt;&gt; = Arc::new(Mutex::new(Client));<br>    <span class="hljs-keyword">let</span> client2 = client.clone();<br><br>    client.lock().unwrap().get_index(<span class="hljs-string">&quot;/foos&quot;</span>).and_then(<span class="hljs-keyword">move</span> |index|&#123;<br>        client2.lock().unwrap().get_responses(&amp;index).collect()<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此，Rust 团队进行设计了一套基于 Future 的 API，提出了 async/await 这组关键字，将异步代码转换成同步模型，这不仅回避了上面的所有权问题，还更加符合人体工程学。</p>
<p>这种写法非常接近 <code>blocking io</code>，程序员能轻易看出执行的逻辑，却能够以异步的方式运行，这主要归功于 Rust 编译器对于 async 代码块的高级抽象，async block 会被翻译成一个<strong>状态机 GenFuture</strong>（匿名结构体），并且其中任何跨越 await 代码块的引用，都会将被引用的变量和引用保存到当前为 async 代码块生成的状态机中，每一个 await 点都是状态的转变时机。  </p>
<p>这样的设计是十分优雅的，也非常有效，但是却带来了一个问题：<strong>自引用</strong> 。来看下面这个例子：  </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_foos</span></span>(client: Client) -&gt; <span class="hljs-built_in">Vec</span>&lt;Response&gt;&#123;<br>    <span class="hljs-keyword">let</span> index = client.get_index(<span class="hljs-string">&quot;/foos&quot;</span>).<span class="hljs-keyword">await</span>; <span class="hljs-comment">// State &#123; Client, &amp;mut Client&#125;</span><br>    client.get_responses(&amp;index).collect().<span class="hljs-keyword">await</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码中，<code>let index = client.get_index(&quot;/foos&quot;).await;</code> 存在一个跨越 await 关键字的对于 client 的引用，因此，必须要将 client 和 &amp;mut client 都保存在状态机中。（这里不去考虑手动构造的问题，需要 unsafe 代码操作裸指针才可以，编译器实现起来会轻松很多）</p>
<p>如果按照最原始的 Future 接口( <code>fn poll(&amp;mut self, ctx: &amp;mut Context&lt;&#39;_&gt;)</code>)，我们很轻易就能在安全代码中让 Rust 程序崩溃：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> future = get_foos(...);<br>    future.poll(...);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> future2 = get_foos(...); <span class="hljs-comment">// 为了防止 let mut future2 = future 只是一个别名，强制初始化 future2，从而下面的 future2 = future 成为一个 memcpy 操作</span><br>    future2 = future;       <span class="hljs-comment">// 自引用结构已经失效，因为 future 和 future2 都是栈上的结构</span><br>    future2.poll(...); <span class="hljs-comment">// 此时完全无法控制 poll 中是否会使用该失效的自引用 ，</span><br>                       <span class="hljs-comment">// 产生了 undefined behavior</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码存在的问题是：当 poll 一个 Future 之后，我们移动了它原本的位置，导致 Future 中的<strong>自引用结构失效</strong>。</p>
<p>这似乎有一点莫名其妙，深究一下根源，你会发现，这和堆、栈的特性有关。</p>
<p>在栈上分配的变量，如果移动了所有权，其大概率（如果不是通过别名复用这块内存的话）也会重新分配一块内存，并且原先的内存会失效。参照下图，在 <code>state2 = state1;</code> 之后，会将 state1 中的内容完完整整拷贝到 state2 中，但是 State 中的 <code>&amp;mut client</code>，还指向 state1 那块已经失效的内存，这才产生的 UB 行为</p>
<p><img src="/images/pin1.png" srcset="/img/loading.gif" lazyload alt="pin on stack"></p>
<p>解决的办法很简单：堆内存分配！</p>
<p>如果我们在栈上只保留一个指针，指向堆上分配的 State，那么，当所有权发生转移的时候，仅仅是之前这个指针失效了，堆上的<strong>值引用结构</strong>并没有移动，也没有被释放，仍然是有效的。</p>
<p><img src="/images/pin1.png" srcset="/img/loading.gif" lazyload alt="pin on heap"></p>
<p>这种模式，就好像将 State 钉(Pin)在了堆空间中，无论栈上的指针怎么移动，堆上的内存都不会受到半点影响。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> state3 = state2;<br><span class="hljs-keyword">let</span> state4 = state3; <span class="hljs-comment">// totally fine</span><br>...<br><br></code></pre></td></tr></table></figure>

<h2 id="2-Future-改进，Pin-引入"><a href="#2-Future-改进，Pin-引入" class="headerlink" title="2. Future 改进，Pin 引入"></a>2. Future 改进，Pin 引入</h2><p>withoutboats 作为 Rust 异步机制的主要设计者，针对原始的 Future trait 提出了几个方案：</p>
<h3 id="2-1-unsafe-标记"><a href="#2-1-unsafe-标记" class="headerlink" title="2.1 unsafe 标记"></a>2.1 unsafe 标记</h3><p>这个方案解决的思路是：为了使用 Future，你必须要确保 SAFETY：该 Future 一旦被 poll 之后，直到其被 Drop 都不会被移动。<br>对于分配在堆上的 future 天生就满足这一点要求，所以这主要是针对在栈上的内存而言的约束。</p>
<p>虽然这确实可以解决现阶段 Future 移动导致的问题，但这会带来一个不得不考虑的问题：本就不受大家欢迎的 unsafe 可能会遍布代码库！而且相当于把锅都甩给了用户，大大加重了开发人员心智负担，该方案作为针对 Future 接口的第一次改进，也就到此为止。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Future</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span>;<br><br>    <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, ctx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-2-Pin-的原始版本"><a href="#2-2-Pin-的原始版本" class="headerlink" title="2.2 Pin 的原始版本"></a>2.2 Pin 的原始版本</h3><p>unsafe Future Trait 的方案被 pass 之后，Rust 团队开始寻求别的解决方式，并提出了 Pin 的概念。</p>
<p>但 Pin 最一开始并不像现在这样简洁，其也是经历了很多设计上的改进。最一开始的设计其实长下面这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PinMut</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T);<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; PinMut&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_mut_unchecked</span></span>(<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T&#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PinBox</span></span>&lt;T&gt;(<span class="hljs-built_in">Box</span>&lt;T&gt;);<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">From</span>&lt;<span class="hljs-built_in">Box</span>&lt;T&gt;&gt; <span class="hljs-keyword">for</span> PinBox&lt;T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(b: <span class="hljs-built_in">Box</span>&lt;T&gt;) -&gt; PinBox&lt;T&gt; &#123;<br>        PinBox(b)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; PinBox&lt;T&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_mut</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T&#123;<br>        PinMut(&amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Future</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll</span></span>(<span class="hljs-keyword">self</span>: PinMut&lt;<span class="hljs-symbol">&#x27;_</span>, <span class="hljs-keyword">Self</span>&gt;, ctx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里引入了 <code>PinBox</code> 和 <code>PinMut</code> 两个概念，都是对于指针的封装，最大的不同是，如果想要通过 <code>PinMut</code> 获取到背后的指针，必须要通过非安全方法完成，而对于 <code>PinBox</code> 而言，则是可以直接在安全代码中获取 Box 背后的对象指针。  </p>
<p>这种封装，带来了一个很大的好处：如果想要通过 PinMut 获取背后的引用，只能通过 get_mut_unchecked 这种 unsafe 的方式，那么，当我们将 Future 的 self 类型限定为 <code>PinMut&lt;&#39;_, Self&gt;</code> 的时候，就会发现，并不是那么轻易就能获取到 <code>&amp;mut self</code> 的哦，必须要确保这个操作的 <strong>SAFETY</strong>，也就不可能在安全代码中，直接获取到 &amp;mut self，继而导致 future 中内容被轻易移动。并且，基于这两个抽象，正确性证明起来是比较容易的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> a = PinMut(&amp;<span class="hljs-keyword">mut</span> p);<br><span class="hljs-comment">// error to compile</span><br>mem::swap(a.get_mut_unchecked(),&amp;<span class="hljs-keyword">mut</span> something_else);<br><span class="hljs-comment">// ok to compile, but usage of unsafe is wrong</span><br>mem::swap(<span class="hljs-keyword">unsafe</span> &#123; a.get_mut_unchecked() &#125;,&amp;<span class="hljs-keyword">mut</span> something_else);<br><br></code></pre></td></tr></table></figure>

<p>这段话中还引入了一点，如果能够在安全代码中，获取到自引用结构的可变引用，也会导致 Rust 给我们做出的安全规范轰然倒塌<br>结合之前的堆、栈分配的特点，实际使用中，会先将其分配在堆上，保证不会因为 <code>let mut future2 = future1;</code> 这种语义将其移动，其次，就是遵守 PinMut 给我们的约束，保证不会获取到可变引用而移动。</p>
<p>相比如第一个 unsafe 提案，我们虽然免不了和 unsafe 打交道，但是已经可以得到一个非常干净的 Future 接口，调用 poll 也不需要再用 unsafe 来方式误用了，相当于是将 unsafe 逻辑转移到了内层实现中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">spawn</span></span>&lt;F: Future&gt;(f: F)&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> fut = PinBox::from(<span class="hljs-built_in">Box</span>::new(f));<br>    <br>    <span class="hljs-comment">// safe the fut to somewhere</span><br><br>    <span class="hljs-comment">// handin to the executor</span><br><br>    <span class="hljs-comment">// construct PinMut, then poll</span><br>    fut.as_mut().poll(...);<br>&#125; <br></code></pre></td></tr></table></figure>

<p>但即使是内层的 unsafe 逻辑，也会给开发人员带来很大的心智负担！</p>
<p>在上面的约束下，我们如果想要在 poll 方法中更新 self 的状态，或者调用 self 某一些 field 的方法，都要首先通过非安全代码，获取 &amp;mut Self，相当于声明：我遵守 unsafe 赋予我的一切权力，我保证不会移动 self。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AsyncIoHandle</span></span>&#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll_read</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>,buf: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-built_in">u8</span>]) -&gt;Poll&lt;<span class="hljs-built_in">usize</span>&gt;&#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IoFuture</span></span> &#123;<br>    buf: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;,<br>    file: AsyncFileHandle<br>&#125;<br><br><span class="hljs-keyword">impl</span> Future <span class="hljs-keyword">for</span> IoFuture &#123;<br>    tyep Output = <span class="hljs-built_in">usize</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll</span></span>(<span class="hljs-keyword">self</span>: PinMut&lt;<span class="hljs-symbol">&#x27;_</span>, <span class="hljs-keyword">Self</span>&gt;, x: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;&#123;<br>        <span class="hljs-comment">// wont&#x27;t compile </span><br>        <span class="hljs-comment">// self.file.poll_read(&amp;mut self.buf[..]) </span><br><br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">let</span> this: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span> = <span class="hljs-keyword">self</span>.get_mut_unchecked();<br>            this.file.poll(&amp;<span class="hljs-keyword">mut</span> this.buf[..]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种恼人的问题对于 <strong>Leaf Future</strong> 尤为严重。所谓的 <strong>Leaf Future</strong>，其实是面向底层 Io(reactor)、需要手动实现的 Future，<strong>Non-Leaf Future</strong> 就是通过 async await 自动生成的 Future，包含了下面的所有结点，non-leaf or leaf。更令人无奈的一点是，对于 99% 手动实现的 <code>Leaf Future</code>，并没有 <code>self referential</code> 的问题，仍需要使用 unsafe。  async/await 中的 <code>self referential</code> 算是解决，但又发力过猛，一棒子打死了更多的 <strong>good future</strong>。</p>
<p>总结一点：<strong>目前为止，通过 PinMut 和 PinBox 的抽象，已经解决了 executor 中的问题(比如需要使用 unsafe)，提供了易用的 Future::poll 接口，但是对于 reactor 仍无太好的办法。PinMut 和 PinBox 的正确性是毋庸置疑的</strong>  </p>
<h3 id="2-3-Unpin-的引入"><a href="#2-3-Unpin-的引入" class="headerlink" title="2.3 Unpin 的引入"></a>2.3 Unpin 的引入</h3><p>为了解决上面的问题，withoutboats 引入了 Unpin 的概念。  </p>
<p>Unpin 是一个 auto trait，Rust 默认为所有结构都添加了这个标记 Trait（像 Send 和 Sync），但是，如果一个结构包含了 !Unpin 的字段，那么其自身也是 !Unpin（ !Unpin 属性会传播），几乎唯一的 !Unpin 结构就是编译器为 async 代码块生成的 GenFuture。其余所有的基础结构，包括 i32, usize 都是 Unpin 的结构，比较特殊的是对于复杂的自引用结构的指针。  </p>
<p>对于内部包含了 Unpin 结构的 PinMut，只需要为其实现 DerefMut 方法，就可以直接获取到 &amp;mut T，PinMut&lt;’a,T&gt; 和 &amp;mut T，也就不需要烦人的 unsafe 了! 乌拉！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> auto <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Unpin</span></span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: Unpin + ?<span class="hljs-built_in">Sized</span>&gt; DerefMut <span class="hljs-keyword">for</span> PinMut&lt;<span class="hljs-symbol">&#x27;a</span>,T&gt;&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Target</span></span> = T;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>) -&gt; &amp;<span class="hljs-keyword">mut</span> Self::Target&#123;<br>        ...<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="2-4-最终方案-Pin"><a href="#2-4-最终方案-Pin" class="headerlink" title="2.4 最终方案 Pin"></a>2.4 最终方案 Pin</h3><p>最终引入标准库的方案并不是上面的 PinMut + PinBox，而是更加简洁的一个统一接口： <strong>Pin</strong>  </p>
<p>Pin 也是一个智能指针，内层包装了一个指针，针对内部不同的指针类型，实现了不同的 trait。</p>
<p>标准库中有下面几个关键的函数，都对它们做了注解：  </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pin</span></span>&lt;P&gt;&#123;<br>    pointer: P<br>&#125;<br><br><span class="hljs-comment">// 直接通过裸指针创建 Pin 是不安全的，使用者必须要确保，这个指针是有效的!</span><br><span class="hljs-keyword">impl</span> Deref&lt;P: Deref&gt; Pin&lt;P&gt;&#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new_unchecked</span></span>(pointer: P) -&gt; Pin&lt;P&gt; &#123;<br>        Pin &#123; pointer &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 同理，将 Pin 转换成内部的裸指针，也是不安全的!</span><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, P&gt; Pin&lt;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> P&gt;&#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_unchecked_mut</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> P &#123;<br>        <span class="hljs-keyword">self</span>.pointer<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Target::Unpin 的指针 P，可以安全获取 &amp;mut P::Target</span><br><span class="hljs-keyword">impl</span>&lt;P: DerefMut&lt;Target: Unpin&gt;&gt; <span class="hljs-keyword">for</span> Pin&lt;P&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-keyword">mut</span> P::Target &#123;<br>        Pin::get_mut(Pin::as_mut(<span class="hljs-keyword">self</span>))<br>    &#125; <br>&#125;<br><br><span class="hljs-comment">// 如果要从 Pin&lt;P&gt; 创建出 Pin&lt;&amp;&#x27;a mut P::Target&gt;，还是可以办到的</span><br><span class="hljs-comment">// 因为 Pin 始终有这个指针的所有权，所以不需要担心会出现 UB 行为</span><br><span class="hljs-keyword">impl</span>&lt;P: DereMut&gt; Pin&lt;P&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_mut</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; Pin&lt;&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> P::Target&gt; &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123; Pin::new_unchecked(&amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span>.pointer) &#125;<br>    &#125;<br>&#125; <br><br><span class="hljs-comment">// 从 Box 创建 Pin 本身就是安全的，因为 Box 实现了 Unpin</span><br><span class="hljs-keyword">impl</span>&lt;P&gt; <span class="hljs-built_in">From</span>&lt;<span class="hljs-built_in">Box</span>&lt;P&gt;&gt; <span class="hljs-keyword">for</span> Pin&lt;<span class="hljs-built_in">Box</span>&lt;P&gt;&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(b: <span class="hljs-built_in">Box</span>&lt;P&gt;) -&gt; Pin&lt;<span class="hljs-built_in">Box</span>&lt;P&gt;&gt;&#123;<br>         <span class="hljs-keyword">unsafe</span> &#123; Pin::new_unchecked(b) &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码可能有一点绕，但是核心关注点就两个</p>
<ol>
<li>对于实现了 Deref 类型的 P，是否可以安全地获取到内层的这个 pointer</li>
<li>对于实现了 Deref 类型的 P，是否可以安全地获取内层 pointer 指针指向的对象</li>
</ol>
<p>始终要牢记 Pin 的使命：需要确保 Rust 中 async/await 代码中的自引用结构有效，不能在 safe code 中 crash Rust 的强安全保证。<strong>这段代码其实是有问题的，后面会提到</strong>。</p>
<p>目前的 Pin 的设计，最核心的 API 是 get_unchecked_mut，这里的 <strong>SAFETY</strong> 保障是：如果 <code>&lt;P as DerefMut&gt;::Target</code> 是 Unpin，那么无法通过安全手段得到其可变引用，否则就可能移动其内容，导致自引用失效（99%的Unpin都发生在自引用结构上）</p>
<p>结合上面的 Unpin 概念，我们可以针对基本类型和自引用结构分别探讨一下合理性。</p>
<p>基本类型是 Unpin 的，因此可以通过 <code>Pin::new</code> 创建，也可以通过 <code>b.get_mut()</code> 获取可变引用，跟普通使用指针没有任何区别</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> b = Pin::new(&amp;<span class="hljs-keyword">mut</span> a);<br><span class="hljs-keyword">let</span> c = b.get_mut();<br></code></pre></td></tr></table></figure>

<p>接来下考虑 Pin 在 async/await 这种自引用结构上的运用（前提是已经分配在堆上了）。为什么对于一个 <code>Box&lt;impl Future&lt;...&gt;&gt;</code>，我们不应该安全的获取代码块的可变引用？</p>
<p>换句话说，如果我们可以安全地获取，可能会怎样违背 Rust 的安全准则？  </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> a = <span class="hljs-built_in">Box</span>::new(<span class="hljs-keyword">async</span> &#123;&#125;); <span class="hljs-comment">// a is pined on the heap, but &lt;A as DerefMut&gt;::Target is still Unpin</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> b = <span class="hljs-keyword">unsafe</span> &#123; Pin::new_unchecked(a) &#125;;<br><span class="hljs-keyword">let</span> c = b.as_mut();<br><span class="hljs-comment">// let d = c.get_unchecked_mut();</span><br><span class="hljs-keyword">let</span> d = <span class="hljs-keyword">unsafe</span> &#123; c.get_unchecked_mut() &#125;;<br><br></code></pre></td></tr></table></figure>

<p>如果可以安全获取到 &amp;mut GenFuture，一旦在两次 poll 之间，被不知情的用户通过 <code>mem::swap()</code> 等手段将其移动出去，就会导致自引用结构失效 💥 。因此，<code>Pin::get_mut_unchecked()</code> 需要通过 unsafe 来让用户自己做出保证。</p>
<p>前面我们也提到，如果想要通过 <code>Pin::new()</code> 这种方式安全地构造 Pin，需要保障 <code>&lt;P as DerefMut&gt;::Target: Unpin</code>，对于 Future 来说，也就只能用 Box 包装两层，第一次是对内部 Future 的 Box，第二次是对指向 <code>async &#123;&#125;</code> 的指针的 Box，然后我们也可以通过 <code>b.as_mut().get_mut()</code> 的方式安全地获取到 <code>&amp;mut Box&lt;...&gt;</code>，WOW！我们可以移动里面的结构了耶！那么 Rust 崩了吗？就这？</p>
<p>等等，别高兴太早，注意到 Future::poll 的方法签名，要求被 poll 的 future 必须要被 Pin 保护起来，我们这里再怎么移动 Box 里面的 Future，都不可能影响 Future::poll。一个 Box 压根就无法被 poll</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> a = <span class="hljs-built_in">Box</span>::new(<span class="hljs-built_in">Box</span>::new(<span class="hljs-keyword">async</span> &#123;&#125;));<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> b = Pin::new(a);<br><span class="hljs-keyword">let</span> c = b.as_mut().get_mut();<br></code></pre></td></tr></table></figure>

<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>使用 Pin 主要是为了避免自引用 Future 的移动问题，核心会关注两点：</p>
<ol>
<li>是否分配在堆上</li>
<li>在给出了 Pin&lt;&amp;mut Self&gt; 之后，是否能安全地获取到 &amp;mut Self</li>
</ol>
<p>前者面向 executor，后者面向 reactor  </p>
<h3 id="3-1-第一个问题，Heap-or-Stack"><a href="#3-1-第一个问题，Heap-or-Stack" class="headerlink" title="3.1 第一个问题，Heap or Stack?"></a>3.1 第一个问题，Heap or Stack?</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 1. Pin to the heap </span><br><br><span class="hljs-comment">// Box::pin(future) : Pin&lt;Box&lt;T&gt;&gt;</span><br><span class="hljs-comment">// for example</span><br><span class="hljs-keyword">let</span> a: Pin&lt;<span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Future&gt;&gt; = <span class="hljs-built_in">Box</span>::pin(future);<br><br><span class="hljs-comment">// 2. Pin to the stack</span><br><br><span class="hljs-keyword">let</span> f: <span class="hljs-keyword">impl</span> Future = <span class="hljs-keyword">async</span> &#123;&#125;;<br><span class="hljs-comment">// pin-utils crate</span><br>pin_utils:pin_mut!(f);<br>f: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">impl</span> Future&lt;..&gt;&gt;;<br></code></pre></td></tr></table></figure>

<p>对于一个分配在堆上的 Future 来说，当然可以随意”移动”，这里的移动指的是，<code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code> 这个结构的所有权不管如何转移，该 Future 的内存一直(Pin)在堆上，直到 Box 被 Drop 才会被释放，比如下面的例子中，a 首先被 poll，不管之后所有权如何转移，改变的也只是栈上的指针位置，该 <code>Box&lt;dyn Future&gt;</code> 的内容仍然在堆上，因而自引用也是有效的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>()&#123;&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-built_in">Box</span>::pin(aysnc&#123; bar().<span class="hljs-keyword">await</span>; <span class="hljs-number">1</span>&#125;);<br>a.poll(...);<br><span class="hljs-keyword">let</span> b = a;<br><span class="hljs-keyword">let</span> c = b;<br><span class="hljs-comment">// 仍然是有效的</span><br>c.poll(...);<br></code></pre></td></tr></table></figure>

<p>对于一个分配在栈上的 Future 来说，如果我们想要手动 Poll 这个 Future，也需要将其 Pin 住，才能满足 <code>poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#39;_&gt;)</code> 的方法签名，有两种方式可以实现：</p>
<ol>
<li>通过 unsafe 代码，<code>Pin::new_unchecked(&amp;mut a)</code></li>
<li>通过 pin-utils 这个 crate 提供的 pin_mut! 宏来解决  </li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>()&#123;&#125;<br><br><span class="hljs-comment">// 1. unsafe 实现，需要手动保证 a 不被 move</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> a = bar();<br><span class="hljs-keyword">let</span> f = <span class="hljs-keyword">unsafe</span> &#123; Pin::new_unchecked(&amp;<span class="hljs-keyword">mut</span> a) &#125;;<br>f.poll(...);<br><span class="hljs-keyword">let</span> c = a;<br>f.poll(..); <span class="hljs-comment">// BOM!</span><br><br><span class="hljs-comment">// 2. pin_mut 宏实现，更加 clever 的方式，回避了 a 被 move 的可能</span><br><span class="hljs-keyword">let</span> a = bar(); <span class="hljs-comment">// a 是分配在栈上的</span><br>pin_mut!(a);  <span class="hljs-comment">// a now is Pin&lt;&amp;mut impl Future&lt;Output=()&gt;&gt;</span><br>a.poll(...)<br><br></code></pre></td></tr></table></figure>

<p>显然，对于栈上的 GenFuture 来说，仅仅是 <code>let c = a</code> 这种转移所有权的方式，也会让 Pin&lt;&amp;mut …&gt; 失效，栈上的 Future 一旦已经 poll，根本无法在线程间转移，更别提调度了，只有在没有堆内存分配的嵌入式系统中，才会实现特殊的 runtime，保证一定在特定的 Stack 上去 poll 这个已经 Pin 住的 Future。因为一旦离开了这个执行栈，这个 Future 也就失效了。而第二种方式中的 pin_mut!，由于 Rust 卫生宏的特性，将变量 a 覆盖了，就无法通过除非安全代码之外的方式获取到 <code>&amp;mut a</code>，从而保证安全性。</p>
<p>对比了 <code>Box::pin 和 pin_mut!</code>，我们可以得出下面的结论：</p>
<ul>
<li>当需要返回一个 Box，或者要将一个 Future 保存在结构体中，需要用 <code>Box::pin</code></li>
<li>当目的是在某个函数中使用 Future，更应该用上 pin_mut!，可以节省 heap allocation 的开销</li>
</ul>
<p>这里必须要补充一个知识点，也就是 Future 的两种执行方式:</p>
<ol>
<li>runtime::spawn(future)   – 顶层 Future</li>
<li>future.await                       – 交给 parent Future 执行</li>
</ol>
<p>第一种方式中，runtime 会首先对顶层的 Future 做一次堆分配，我们就叫它 root Future，无论 root Future 是否是 Unpin 的，<code>Box&lt;dyn Future&gt;</code> 一定实现了 Unpin，就可以交给 executor 安全地执行 poll 了</p>
<p>第二种方式中，该 Future 会被 parent Future(async) <strong>感知</strong>，在被 grand parent 感知…，到最后也一定是通过runtime::spawn 来执行的。如果将其视为一颗 Future 树，内部所有的子孙 Future 都会复用 root Future 分配的空间，也就是 spawn 中一次性分配在堆上的空间。</p>
<h3 id="3-2-第二个问题，获取-amp-mut-Self"><a href="#3-2-第二个问题，获取-amp-mut-Self" class="headerlink" title="3.2 第二个问题，获取 &amp;mut Self"></a>3.2 第二个问题，获取 &amp;mut Self</h3><p>针对 async/await 得到的 <code>Pin&lt;&amp;mut Future&gt;</code>，Pin 可以确保不会在安全代码中得到 <code>&amp;mut Future</code>，从而被滥用；针对手动实现、没有自引用结构的、面向底层 reactor 的 Future，则可以没有任何代价地获取到 <code>&amp;mut Future</code>。</p>
<p>针对 executor 和 reactor，有两种不同的 Future，async/await 是 high-level，面向 executor 的 Future，手动实现的是 low-level，面向系统的 Future。只有前者会导致自引用问题，但是 Rust 团队花了这么多精力去修补完善，这才拿出了这个比较好用的 API，如果不了解这些，完全没有办法想象，居然有这么多考量的因素。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/rust/">rust</a>
                    
                      <a class="hover-with-bg" href="/categories/rust/async/">async</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/24/linux/network/zero%20copy/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">zero copy</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/24/rust/futures/future-explained2/">
                        <span class="hidden-mobile">future explained(2)</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" lazyload class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
