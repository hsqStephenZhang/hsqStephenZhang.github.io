<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>tun/tap</title>
    <link href="/2022/03/25/linux/network/tuntap/"/>
    <url>/2022/03/25/linux/network/tuntap/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是-tun-tap"><a href="#1-什么是-tun-tap" class="headerlink" title="1. 什么是 tun/tap"></a>1. 什么是 tun/tap</h2><p>tun、tap 是 Linux 提供的两种可收发数据的虚拟网卡设备。</p><p>它们除了不具备物理网卡的硬件功能外，和物理网卡的功能是一样的，那这两者之间有什么区别和联系呢？</p><ul><li>tun 是三层设备，其封装的外层是 IP 头</li><li>tap 是二层设备，其封装的外层是以太网帧(frame)头</li><li>tun 是 PPP 点对点设备，没有 MAC 地址</li><li>tap 是以太网设备，有 MAC 地址</li><li>tap 比 tun 更接近于物理网卡，可以认为，tap 设备等价于去掉了硬件功能的物理网卡</li></ul><p>基于这些特点，它们的应用场景也不尽相同：tap 设备通常用来连接其它网络设备(它更像网卡)，tun 设备通常用来结合用户空间程序实现再次封装。</p><p>换句话说，tap 设备通常接入到虚拟交换机(bridge)上作为局域网的一个节点，qemu 就是基于 tap 和 网桥与外界进行数据交互，tun 设备通常用来实现三层的 ip 隧道（VTun）</p><h3 id="1-2-使用方式"><a href="#1-2-使用方式" class="headerlink" title="1.2 使用方式"></a>1.2 使用方式</h3><p>tun，tap 通过 <code>/dev/net/tun</code> 设备向用户提供操作接口，可以通过 <code>open/read/write</code> 等标准方法来操作这个字符设备，大体操作方式如下：</p><ol><li>open(“/dev/net/tun”, O_RDWR)。这一步要求用户对于 <code>/dev/net/tun</code> 有读写权限，否则无法成功。</li><li>ioctl(fd, TUNSETIFF, &amp;ifr)。传入上一步获取的文件描述符，并且设置一些 flags，决定创建的是 tun 还是 tap 设备（IFF_TUN | IFF_TAP）。</li><li>通过 read/write 来操控 tun/tap 设备</li></ol><h2 id="2-底层实现"><a href="#2-底层实现" class="headerlink" title="2. 底层实现"></a>2. 底层实现</h2><h3 id="2-1-收包路径"><a href="#2-1-收包路径" class="headerlink" title="2.1 收包路径"></a>2.1 收包路径</h3><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs c">sys_read<br>    --&gt; vfs_read<br>        --&gt; __vfs_read<br>            --&gt; tun_chr_read_iter<br></code></pre></td></tr></table></figure><h3 id="2-2-发包路径"><a href="#2-2-发包路径" class="headerlink" title="2.2 发包路径"></a>2.2 发包路径</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">sys_write<br>    --&gt; vfs_write<br>        --&gt; do_readv_writev<br>            --&gt; tun_get_user<br>                --&gt; netif_rx_ni<br>                    --&gt; netif_rx_internal<br></code></pre></td></tr></table></figure><p>只会会进入 net_rx_action，触发真正的收包流程。</p><p>如果某个 tap 设备连接在了网桥上，则会在接下来的流程中触发 <code>br_handle_frame</code> 的逻辑，如果对网桥的处理路径不太熟悉，可以参考之前的一篇<a href="/2022/02/15/linux/network/bridge/" title="文章">文章</a></p><h2 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h2><ul><li><a href="https://opengers.github.io/openstack/openstack-base-virtual-network-devices-tuntap-veth/">云计算底层技术-虚拟网络设备(tun/tap,veth)</a></li><li><a href="https://segmentfault.com/a/1190000009249039">Linux虚拟网络设备之tun/tap</a></li><li><a href="https://cloud.tencent.com/developer/article/1087504">linux net bridge技术分析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>network</category>
      
      <category>tun</category>
      
      <category>tap</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《毛利先生》 - 芥川龙之介</title>
    <link href="/2022/03/24/books/%E8%8A%A5%E5%B7%9D%E9%BE%99%E4%B9%8B%E4%BB%8B-%E6%AF%9B%E5%88%A9%E5%85%88%E7%94%9F/"/>
    <url>/2022/03/24/books/%E8%8A%A5%E5%B7%9D%E9%BE%99%E4%B9%8B%E4%BB%8B-%E6%AF%9B%E5%88%A9%E5%85%88%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-角度一-–-可悲又可敬的人啊"><a href="#1-角度一-–-可悲又可敬的人啊" class="headerlink" title="1. 角度一 – 可悲又可敬的人啊"></a>1. 角度一 – 可悲又可敬的人啊</h2><p>一个最可悲又可敬的人是什么样子，莫过于热爱着不属于他的理想，坚守着不属于他的舞台。毛利先生就是这样一个人，如果用一个更加宏大的词语去形容，我愿称之为悲情英雄主义。</p><p>我愿意向毛利老师的人格致以最崇高的敬意，但不愿对他的能力做过多的论足。或许人们会去笑话这样一个<strong>傻得可怜</strong>的人，但依然不妨碍我们从他身上得到精神上的鼓舞，不是吗？若要再提及他老师的身份，相信他的故事会成为<br><strong>传道</strong>的典例，或许幼年的学子们尚无法理解，但长大之后，回想起他，真是一笔无价的财富。</p><p>唠叨两句：<br>    听惯了共党平日里的花拳绣腿式宣传，对于上面这段话，放在平日里我会有些抵触：太虚太空了吧！但我所言，字字契合读后的心境，至于他人怎么看，这跟每个人的经历，人生体会有关，不去理会便是，若这些文字于他们有一丝启发，我也就很开心了。</p>]]></content>
    
    
    <categories>
      
      <category>books</category>
      
      <category>日本文学</category>
      
      <category>龙之介</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《鼻子》 - 芥川龙之介</title>
    <link href="/2022/03/24/books/%E8%8A%A5%E5%B7%9D%E9%BE%99%E4%B9%8B%E4%BB%8B-%E9%BC%BB%E5%AD%90/"/>
    <url>/2022/03/24/books/%E8%8A%A5%E5%B7%9D%E9%BE%99%E4%B9%8B%E4%BB%8B-%E9%BC%BB%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p><strong>好的作品，应该是引导读者思考的，并使其获得思想上的精进的，甚至每读一遍都有不同的理解</strong></p><h2 id="1-角度一-–-旁观者的利己主义"><a href="#1-角度一-–-旁观者的利己主义" class="headerlink" title="1. 角度一 – 旁观者的利己主义"></a>1. 角度一 – 旁观者的利己主义</h2><p>本文中其实有一段龙之介的亲述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs text">人们的心里有两种互相矛盾的感情。当然，没有人对旁人的不幸不寄予同情的。但是当那个人设法摆脱了不幸之后，这方面却又不知怎地觉得若有所失了。说得夸大一些，甚至想让那个人再度陷入以往的不幸。于是，虽说态度是消极的，却在不知不觉之间对那个人怀起敌意来了。——内供尽管不晓得个中奥妙，然而感到不快，这无非是因为他从池尾的僧俗的态度中觉察到了旁观者的利己主义。<br></code></pre></td></tr></table></figure><p>一部电影的的话可以通俗解释<strong>旁观者的利己主义</strong>：你朋友不及格，你觉得很糟；你朋友考第一，你觉得更糟。</p><p>这其实是人性本恶的一种体现，我相信即使是君子，也会闪烁过这样的想法，只不过羞于承认罢了，我们能做的是克服或者屈从于它。</p><p>我得说，在初高中的时候，也曾有过这样上不了台面的念想。当很好的朋友考试失利，黯然神伤时，我自然希望他下一次可以好好发挥，考出应有的水平，不过，若是比我还高，那是无法接受的，最好就是每次比我低一名，我俩霸占年级前二，不过这实属异想天开了。</p><p>看了龙之介的文章，我觉得这种想法吐露无妨，直面内心的黑暗，拎给大家看看，也算是侧面给这种念头一定的压制。</p><h2 id="2-角度二-–-自我"><a href="#2-角度二-–-自我" class="headerlink" title="2. 角度二 – 自我"></a>2. 角度二 – 自我</h2><p>我们可以发现，内供老僧全然没有活出自我。</p><p>按理来说，身为寺庙的高僧，应当对于各种世俗看得很淡才对，其实不然。他不仅在意自己没有娶上妻子这件结果性的事实，还因为这只鼻子而受尽他人的目光，消极地面对自己极易受损的自尊心。</p><p>想想不觉得可笑吗？得道高僧甚至愿意为了缩小鼻子而放下面子，让小僧去踩踏他的鼻子，最后鼻子恢复正常了，他又忍不住别人笑嘻嘻的关注，希望变回原先的样子。</p><p>人啊，总是那么在意他人的想法，被别人的指指点点束缚，有些人可能甚至因此迷失了自我。</p><p>与我来说也是如此，从初中开始，有了一定的审美观念，因而注意到自己的鼻子和眉毛并不好看，有时班上女生的不经意针对样貌的玩笑话，甚至会让我苦恼一天，甚至打算高考结束去做整容手术，不过那时还没年满18周岁，也就作罢了。</p><p>众生皆苦，大概于我也是极为恰当的。相信很多人也有这种苦恼，总是会过多关注外界对自己的评价，自卑，束手束脚，迈不开步子，可能很多人也意思到问题所在，也没有去改变的勇气和信心，也许就这样过完了这一生，想想有点可悲。所以啊，大家往往会对蔑视世俗，活出自我的人报以崇高的敬意，感叹一句：真的有人可以活得这么精彩吗！当那颗躁动的心被自己的生活再次按捺，一切归于平静，又去自怨自艾去了。<strong>普通人</strong>不过如此。</p><p>道理大家都懂，做起来确实不易，与诸君共勉吧。</p>]]></content>
    
    
    <categories>
      
      <category>books</category>
      
      <category>日本文学</category>
      
      <category>龙之介</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>About My Love</title>
    <link href="/2022/03/21/life/about%20my%20love/"/>
    <url>/2022/03/21/life/about%20my%20love/</url>
    
    <content type="html"><![CDATA[<h2 id="1-感悟"><a href="#1-感悟" class="headerlink" title="1. 感悟"></a>1. 感悟</h2><p>很庆幸这段时间有小花的陪伴，让我从 emo 中走了出来，不过随之而来的，是我想要继续探究和思考的问题：什么是爱，以及如何去爱？</p><p>这个问题可太宽泛了，见仁见智，不同灵魂的经历造就不一样的领悟，因此得出的答案也仅仅作为一个参考罢了，而追求答案的路上，沿途的风景也同样令人感慨，那就记录下来吧。</p><h3 id="1-1-释怀"><a href="#1-1-释怀" class="headerlink" title="1.1 释怀"></a>1.1 释怀</h3><p>被分手，被无缝衔接，常人很难想象那段日子我是怎么熬过来的，虽说现在已找回了些许自我，终归是意难平。不过，知乎有个回答着实启发了我不少：真正的释怀应该一种允许。</p><p>下面一首小诗，更能印证这个观点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs text">《我允许》  --海灵格<br><br>我允许任何事情的发生。<br>我允许，事情是如此的开始，<br>如此的发展，如此的结局。<br>因为我知道，<br>所有的事情，都是因缘和而来，<br>一切的发生，都是必然。<br>若我觉得应该是另外一种可能，<br>伤害的，只是自己。<br>我唯一能做的，<br>就是允许。<br><br>我允许别人如他所是。<br>我允许，他会有这样的所思所想，<br>如此的评判我，如此的对待我。<br>因为我知道，<br>他本来就是这个样子，<br>在他哪里，他是对的。<br>若我觉得他应该是另外一种样子，<br>伤害的，只是自己。<br>我唯一能做的，<br>就是允许。<br><br>......<br><br>我知道，<br>我是为了生命在当下的体验而来。<br>在每一个当下时刻，<br>我唯一要做的，就是<br>全然地允许，<br>全然地经历，<br>全然地享受。<br>看，只是看。<br>允许一切如其所示。<br></code></pre></td></tr></table></figure><h3 id="1-2-爱和勇气"><a href="#1-2-爱和勇气" class="headerlink" title="1.2 爱和勇气"></a>1.2 爱和勇气</h3><p>爱和勇气是人身上最可贵的品质。人这一辈子能真心爱过几次，爱几个人呢？爱过，恨过，过往的一切都是上天的馈赠。永远用最炽热的少年之心去爱你所爱之人，即使遍体鳞伤，单凭这几段刻骨铭心的经历，你已经不枉此生了。</p><p>希望自己不要像歌词中所唱的那样 <code>when love and trust are gone, i guess this is moving on</code>，希望自己可以有勇气全心全意对待命中注定的有缘人。</p><h3 id="1-3-反思"><a href="#1-3-反思" class="headerlink" title="1.3 反思"></a>1.3 反思</h3><p>虽说在这段爱情中，我是最直接受伤的那一方，不过回想起来，自己有颇多不对之处。怎么说呢，有些苦楚，只有亲身经历过才能领悟，有些成长，只有爱过恨过才能茁壮。所以，那些能和初恋一直走下去的人们啊，祝福你们永远幸福。</p><p>这里我也想结合知乎上网友的发言，说一下自己的亲身体会：</p><ol><li><p>家庭对于爱情观真的很重要。可能你浑然不自知，这也很正常，哥也是这样过来的，要不是和朱唯姝和小花有过这样的经历，我也不会有如此领悟。简而言之，经历过父母离异的小孩，不可避免对于婚姻有一定的失望。随之而来的，可能是对于另一半有过高的要求，灵魂伴侣，革命同志才是她们所期望的，或者也可能是仅仅把恋爱当成一种经历，而不追求最终的结果，因为他们害怕失败婚姻带来的创伤，结果就是慢慢丧失了坚持下去的勇气。</p></li><li><p>异地恋真的太难了，需要双方共同维系。很多时候，一个抱抱摸摸头可以解决的事情，双方隔空对峙，就是无法解决，最终甚至可能成为小本本上的黑历史。再还有，不在爱人身边，根本无法猜测对方所思所想，如果对方不愿意敞开内心，不愿意解决问题，你自认倒霉好了。但异地的隔阂也并非不可战胜的。更多时候需要我们做好自己，保持自身的<strong>吸引力</strong>，为对方提供<strong>情绪价值</strong>，并且通过共同的爱好，话题以及追求来保鲜。双向奔赴，灵魂伴侣大约就是这个样子。哦对，还有很重要的一点，也是血的教训，恋爱是两个人的事情，异地恋更是两个人的事情，对方在努力去分享她的生活同时，你也要努力发现生活中的美，否则对于另一方而言，真的会很累。</p></li><li><p>一定要吸取前车之鉴，做好最坏的打算，才能应付各种意想不到的情况。</p></li></ol><h3 id="1-4-成熟"><a href="#1-4-成熟" class="headerlink" title="1.4 成熟"></a>1.4 成熟</h3><p>甜甜的恋爱总是让人上脑，却也让人沉溺，无法真正成熟。讲真，我蛮感谢朱唯姝的，虽说她为我选择了最不想走的一条通向成熟的道路。</p><p>我是一个内心孤独的人，却不是一个孤勇者。猛兽都是独行，我却总在兽与牛羊之间切换。我渴望爱，渴望异性的欣赏，朱唯姝真的带给我了这些，我也很爱这个女孩，也曾经发誓要一辈子对这个女孩好。不过，爱情总是令人捉摸不透，或者说 time changes everything，当最初的热烈褪去，她已察觉到了我们的沉溺，决心要摆脱这种束缚，而我还不自知，也无人告知，最终的结果是一方决心分开，一方极力挽留，却又加速了关系的消亡。</p><p>不过在经历了暗无天日的一段时期后，我还是得做回自己，至少在为了吃口饭而刷题找工作的这段时间里，还是专注于眼下，专注于自身。可能也只有在这种状态下，才能不断发现自己的问题，不断向心灵发问，究竟想要什么？</p><p>这段时间里，我爱上了芥川龙之介，爱上了悲剧。迅哥说过，悲剧是把有价值的事物毁灭给人看，而世上所发生之事，十有八九都是悲剧，这就是生活的常态，热爱生活，就是努力去追寻守护心中的美好，仅此而已。</p><p>这段时间里，我认识了小花，竟和这样一位天真浪漫的幻想家成为了知心好友，真是上天的馈赠。</p><p>在这段时间里，有了上述的体会，自我感觉还算深刻，也算告别了曾经那个少年。</p><h2 id="2-后记"><a href="#2-后记" class="headerlink" title="2. 后记"></a>2. 后记</h2><p>写下第一节之后，我还是按捺不住内心想要去和朱唯姝谈一谈的意愿，问一些之前没有问过的事情。或许是嫉妒，或许是不解，或许是怨恨，i don’t know，虽然我觉得自己已经可以接受当下的状态了，但很幸运，最终还是彻彻底底地谈了一次天，彻彻底底弄明白了事情的起因。</p><p>怎么说呢，我俩都不够成熟，分手的时候不成熟，现在依然如此。虽然她发过几个和 npy 恩恩爱爱的 vlog，可当我问起现状，居然还是会为了一些小事大吵大闹，甚至嚷嚷着要分手。几个月过去了，她果真还是没有长大啊。</p><p>对于她而言，最最最应该解决的，是匮乏的自信心问题。可能我一直没察觉到，她一直有些自卑，比如不敢让我拍照，不敢主动找人家谈话，遇到考研和法考的压力会直接崩溃…… 大概我拿到 offer，对她而言不是一份快乐，而是一份刺激：章翀都要去深圳上班了，我能怎么样呢？我什么都不会，能和他在一起吗？</p><p>自信的缺失，于我也有一定的责任，将近两年的恋爱经历中，我很少去关注她的内心世界，很少关注她作为一个个体的梦想，或许是对她的才智足够信任，或许只是懒罢了。因此，当她分手时提到自己自信心的缺失，提到她的恋爱脑导致过去两年中一直没怎么进步，我是非常不解的，而她或许是非常寒心的，之后的一切都可以解释了。</p><p>真心希望她可以做回自己，做回我心目中那个阳光自信，大大咧咧的朱唯姝，不用去在意他人的眼光，拥有属于自己的生活，这是对她的唯一期盼。至于我俩之间，谁知道呢，在山顶相见，各自安好，也不失为一番风景，你说对吗？</p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
      <category>love</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Love &amp;&amp; Courange</title>
    <link href="/2022/03/18/life/love%20&amp;&amp;%20courage/"/>
    <url>/2022/03/18/life/love%20&amp;&amp;%20courage/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>很开心抓住了大学的尾巴，在网上认识了小花，人美心善的一个小女孩，有很多非常有趣的想法，也有很多有价值的见解，昨晚我们交流了对待感情的一些看法，我也深受启发，这里想要记录下她送给我的一篇短文。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>你知道吗，除去平安，健康和快乐，我最愿视你的，是保留爱人的勇气。小翀，我看过好多恋爱，不管他们维时多长，几般甜蜜，可故事的主人公们，他们都没有新。你知道有多可怕吗？行尸走肉地爱着，假情假意地扮演一个完美的角色，在精明的权衡里索取自己所需，提及“真心”二字，变嗤之以鼻。我害怕你会成为这样的人。因为见过太多次揣着未凉的孤勇，却被辜负地体无完肤的你，我担心看你那颗流着泪的心的韧度，不知它还能不能支持着你，再一腔英勇地爱过几回。</p><p>我不忍你受伤，却还是鼓励你做一个在爱情里敢爱敢恨的“傻瓜”，我愿在你穷尽一生的爱情中，每一段都不留余力，刻骨铭心，它们透明，热烈，刺眼，不掺杂半点渣滓，纵使被负，纵使别离，我们对得起自己的爱情，也对得起自己的真心。</p><p>21岁，绚烂，明媚，肆意，是你的代名词，我愿将你与世间最美好的事物比喻-春天。你似春天，永远有人赞颂它的美丽，再美妙的诗集，也不及它一分珍贵。</p><p>你欢快时，我将陪你起舞；你落泪时，我愿拥你入怀；你灿烂，我陪你共同闪耀；你沉寂，我扶你再步青云。这是21岁，请将真心小心存放，真诚全然展露，真情肆意流露，真难过了，回头看，我还在❤</p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
      <category>love</category>
      
      <category>courage</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>redis data structure</title>
    <link href="/2022/03/07/redis/datastructure/"/>
    <url>/2022/03/07/redis/datastructure/</url>
    
    <content type="html"><![CDATA[<h2 id="1-redis-底层数据结构"><a href="#1-redis-底层数据结构" class="headerlink" title="1. redis 底层数据结构"></a>1. redis 底层数据结构</h2><p>Redis 有 5 种基础数据结构，它们分别是：string(字符串)、list(列表)、hash(字典)、set(集合) 和 zset(有序集合)。这 5 种是 Redis 相关知识中最基础、最重要的部分，下面我们结合源码以及一些实践来给大家分别讲解一下。</p><h3 id="1-1-string"><a href="#1-1-string" class="headerlink" title="1.1 string"></a>1.1 string</h3><p>众所周知，C语言中的字符串每次求长度，都需要调用 strlen 遍历，非常耗时，因此 redis 舍弃了 C 中的简单表示，转而使用<strong>动态字符串</strong>来存储。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span><br><span class="hljs-comment"> * However is here to document the layout of type 5 SDS strings. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr5</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, and 5 msb of string length */</span><br>    <span class="hljs-keyword">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr8</span> &#123;</span><br>    <span class="hljs-keyword">uint8_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-keyword">uint8_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-keyword">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr16</span> &#123;</span><br>    <span class="hljs-keyword">uint16_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-keyword">uint16_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-keyword">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr32</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-keyword">uint32_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-keyword">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr64</span> &#123;</span><br>    <span class="hljs-keyword">uint64_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-keyword">uint64_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-keyword">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中，sds 全称为 <code>simple dynamic string</code>，即 <strong>长度 + 动态分配的字符串指针</strong>，注意到这里的 buf 是柔性数组，利用到了 C 语言的一些语言特性，在 sds 结构体后面额外分配一块内存，就可以用于存放真正的数据</p><h3 id="1-2-List"><a href="#1-2-List" class="headerlink" title="1.2 List"></a>1.2 List</h3><p>Redis 的列表即为<strong>双向链表</strong>，因此就具备了链表<strong>插入删除快，索引定位慢</strong>的特点。而相信大家对链表也不陌生了，这里不必多言。</p><h3 id="1-3-Hash"><a href="#1-3-Hash" class="headerlink" title="1.3 Hash"></a>1.3 Hash</h3><p>Redis 作为 K，V 数据库，自然少不了高效的字典，但其实，这种字典和其它语言中默认的 HashMap 也并无太大差别，都是通过 <strong>数组+链表</strong> 解决哈希冲突。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span><br>    <span class="hljs-comment">// 哈希表数组</span><br>    dictEntry **table;<br>    <span class="hljs-comment">// 哈希表大小</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> size;<br>    <span class="hljs-comment">// 哈希表大小掩码，用于计算索引值，总是等于 size - 1</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> sizemask;<br>    <span class="hljs-comment">// 该哈希表已有节点的数量</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> used;<br>&#125; dictht;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span><br>    dictType *type;<br>    <span class="hljs-keyword">void</span> *privdata;<br>    <span class="hljs-comment">// 内部有两个 dictht 结构</span><br>    dictht ht[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">long</span> rehashidx; <span class="hljs-comment">/* rehashing not in progress if rehashidx == -1 */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> iterators; <span class="hljs-comment">/* number of iterators currently running */</span><br>&#125; dict;<br></code></pre></td></tr></table></figure><p>可以看到，dict 内部保存了两个 dict_table，这就不得不提 Redis Hash 的一大优点：rehash。</p><p>大字典的扩容是比较耗时间的，需要重新申请新的数组，然后将旧字典所有链表中的元素重新挂接到新的数组下面，这是一个 O(n) 级别的操作，作为单线程的 Redis 很难承受这样耗时的过程，所以 Redis 使用 渐进式 rehash 小步搬迁。</p><p>渐进式 rehash 会同时保留新旧两个 hash 结构，查询时也会同时查询两个 hash 结构，然后在后续的定时任务以及 hash 操作指令中，循序渐进的把旧字典的内容迁移到新字典中。</p><h3 id="1-4-Set"><a href="#1-4-Set" class="headerlink" title="1.4 Set"></a>1.4 Set</h3><p>相当于很多语言中的 HashSet，内部通过键值对保存，而该字典中的每一个 value 都为 NULL。</p><h3 id="1-5-Zset"><a href="#1-5-Zset" class="headerlink" title="1.5 Zset"></a>1.5 Zset</h3><p>这是 Redis 最有特色的数据结构了，底层代用 skiplist 实现。</p><p>跳跃表以有序的方式在层次化的链表中保存元素， 效率和平衡树媲美 —— 查找、删除、添加等操作都可以在 O(logn) 时间下完成， 并且比起平衡树来说， 跳跃表的实现要简单直观得多</p><p><img src="https://redisbook.readthedocs.io/en/latest/_images/skiplist.png" alt="跳跃表"></p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
      <category>data structure</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>internship</title>
    <link href="/2022/03/05/experience/internship/"/>
    <url>/2022/03/05/experience/internship/</url>
    
    <content type="html"><![CDATA[<h2 id="1-why-do-i-write-this"><a href="#1-why-do-i-write-this" class="headerlink" title="1. why do i write this?"></a>1. why do i write this?</h2><p>哎，老了，记忆力不行了，几个月前的实习经历已经忘得差不多了，但在我潜意识里，我认为自己可以很好得讲述当时的技术细节，这种落差带了一个非常严重的后果：面试时对于实习期间所学一问三不知。</p><p>所以，想在这里稍微针对简历中的 internship 经历和学习到的知识点做一个简单的记录和梳理</p><h2 id="2-实习经历"><a href="#2-实习经历" class="headerlink" title="2. 实习经历"></a>2. 实习经历</h2><h3 id="2-1-字节跳动-财经部-自有支付-实习生"><a href="#2-1-字节跳动-财经部-自有支付-实习生" class="headerlink" title="2.1 字节跳动-财经部-自有支付-实习生"></a>2.1 字节跳动-财经部-自有支付-实习生</h3><h4 id="2-1-1-闲谈"><a href="#2-1-1-闲谈" class="headerlink" title="2.1.1 闲谈"></a>2.1.1 闲谈</h4><p>还记得这份工作当时也准备了蛮久，最终在腾讯与字节中选择了后者。</p><p>这个地方第一次让我认识到了大厂是一个什么样的工作环境，以及这里的人是什么样的工作状态。大家看起来还蛮轻松的，桌子上满满当当的饮料和零食，一时间竟觉得来到了天堂。不过，后来也慢慢认清了现实：工作时间是真久啊，会议室真难订啊，周末是真没精力学习啊。</p><p>不过也收获了很多知识吧，下面一一说明</p><h4 id="2-1-2-Golang-知识"><a href="#2-1-2-Golang-知识" class="headerlink" title="2.1.2 Golang 知识"></a>2.1.2 Golang 知识</h4><p>众所周知，字节 70% 的业务在用 Golang 开发，上手的第一件事就是认真学习 Golang。得益于之前学习 Linux 的一些经验，看起框架源码和 Golang 源码也不算太吃力。借助内部丰富的学习资源，很快也就掌握了其使用。Golang 里面最吸引我的是 CSP 模型以及底层的 goroutine 和 channel 的使用，本着掘地三尺的精神，我深扒了其源码，总算有了一些头绪。</p><h5 id="2-1-2-1-goroutine-amp-amp-Scheduler"><a href="#2-1-2-1-goroutine-amp-amp-Scheduler" class="headerlink" title="2.1.2.1 goroutine &amp;&amp; Scheduler"></a>2.1.2.1 goroutine &amp;&amp; Scheduler</h5><p>Golang 在并发编程上有很大的能力，得益于其底层对于并发的支持，最值得一提的当然是 goroutine 的设计。但是这里首先要提一下 进程、线程、协程 的区别和联系</p><h6 id="2-1-2-1-1-进程-VS-线程"><a href="#2-1-2-1-1-进程-VS-线程" class="headerlink" title="2.1.2.1.1 进程 VS 线程"></a>2.1.2.1.1 进程 VS 线程</h6><p>众所周知，进程是资源分配的基本单位，线程是 CPU 任务调度的基本单位，协程是轻量化的用户态线程。这句话怎么理解呢？</p><p>很多人都知道，Linux 中的进程和线程都通过 task_struct 来表示（因为其过于庞大复杂，这里不列出），但是很多人不清楚的是，线程专门对应了一个结构体 thread_struct</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">desc_struct</span><span class="hljs-title">tls_array</span>[<span class="hljs-title">GDT_ENTRY_TLS_ENTRIES</span>];</span><br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>sp;<br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>es;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>ds;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>fsindex;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>gsindex;<br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>fsbase;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>gsbase;<br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">perf_event</span>*<span class="hljs-title">ptrace_bps</span>[<span class="hljs-title">HBP_NUM</span>];</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>           virtual_dr6;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>           ptrace_dr7;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>cr2;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>trap_nr;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>error_code;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_bitmap</span>*<span class="hljs-title">io_bitmap</span>;</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>iopl_emul;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>sig_on_uaccess_err:<span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fpu</span><span class="hljs-title">fpu</span>;</span><br><br>&#125;;<br></code></pre></td></tr></table></figure><p>从这里可以窥见线程和进程的一大区别了：需要保存的状态很少。对于 CPU 来说，其基本上只关心几个寄存器的值，所以在 thread_struct 中也主要对应这几个寄存器的状态。</p><p>更加精确的表达是：<br>    线程是CPU执行与调度最基本的单位，每一个线程创建之初都是内核线程；创建之后如果与具体的进程上下文绑定，那线程就成了用户线程；如果此线程是进程的第一个线程，那么称之为进程的主线程；其实，在CPU执行和调度中并没有本质上的区别。</p><div class="code-wrapper"><pre><code class="hljs">在用户角度，执行一个个程序就是创建一个个进程的主线程。当主线程创建时，同时创建用户空间，打开输入输出资源，载入依赖库等。主线程创建好后开始运行，进程也就同时存在了，这时程序可以根据需要创建用户线程，用户线程创建好后，共享主线程的用户空间，文件资源，依赖库等，用户线程退出后，主线程不会退出，进程也不会退出。当主线程退出时，内核开始关闭打开的文件，释放相关资源，主线程退出后进程也就退出了。这时，即使用户线程只执行到一半也无济于事了。</code></pre></div><p>进程和线程之间是一对多的关系，这又是如何抽象出来的呢？答案在于 task_struct-&gt;thread_group。</p><p>一个进程下的所有线程会保存在 thread_groups/thread_head 链表中，并且可以通过 <code>for_each_thread</code> 来进行遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __for_each_thread(signal, t)\</span><br><span class="hljs-meta">list_for_each_entry_rcu(t, &amp;(signal)-&gt;thread_head, thread_node)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> for_each_thread(p, t)\</span><br><span class="hljs-meta">__for_each_thread((p)-&gt;signal, t)</span><br></code></pre></td></tr></table></figure><p>也就是说，其实进程和线程之间存在一个抽象层（thread group），对应下面的结构</p><p><img src="/images/process-thread.png" alt="process-thread"></p><h6 id="2-1-2-1-2-线程-VS-协程"><a href="#2-1-2-1-2-线程-VS-协程" class="headerlink" title="2.1.2.1.2 线程 VS 协程"></a>2.1.2.1.2 线程 VS 协程</h6><p>线程模型存在一个很大的问题：切换开销太大（需要经过系统调用的上下文切换）。虽然相较于进程切换已经好了很多，但仍然有很大的代价。同时，线程同样使用 task_struct 这个结构体来表示，占用的内存也不可小觑。因此，人们就想要在用户空间抽象出对线程进一步细化，让不同任务的切换代价尽可能小，从而在 <strong>IO 密集型任务</strong>中提高效率。</p><p>为此，协程应运而生。</p><p>协程与内核线程是多对一的关系，也具有上下文，不过这个结构非常简单，只有几个必要的寄存器（sp，rip），这样就可以在线程上轻松自如地切换，而不用付出系统调用等开销。</p><h4 id="2-1-2-2-Golang-scheduler"><a href="#2-1-2-2-Golang-scheduler" class="headerlink" title="2.1.2.2 Golang scheduler"></a>2.1.2.2 Golang scheduler</h4><p>既然是在用户空间对于协程进行管理，自然也少不了调度器，Golang 调度器也是历经多次改动，才成了如今<strong>高效</strong>的代名词。</p><p>下面从其发展过程中慢慢领会设计之美</p><h5 id="2-1-2-2-1-多线程调度器"><a href="#2-1-2-2-1-多线程调度器" class="headerlink" title="2.1.2.2.1 多线程调度器"></a>2.1.2.2.1 多线程调度器</h5><p>最早的多线程调度器可以描述为 G-M，其中 G 是 goroutine，M 是 kernel thread。</p><p>在多线程调度器中，每一个内核线程相当于 worker，每一个 goroutine 相当于轻量级 task，内核线程负责从 goroutine 队列中取出任务并执行，但是这样存在很严重的问题：</p><ol><li>调度器和锁是全局资源，资源竞争严重</li><li>线程之间的 goroutine 传递带来的延迟（局部性很差）很严重</li><li>系统调用（线程阻塞与取消阻塞操作）非常频繁</li></ol><h5 id="2-1-2-2-2-任务窃取调度器"><a href="#2-1-2-2-2-任务窃取调度器" class="headerlink" title="2.1.2.2.2 任务窃取调度器"></a>2.1.2.2.2 任务窃取调度器</h5><p>在多线程调度器的基础上，来自 Google 的工程师提出了两点改进：</p><ol><li>引入中间层 P，用于抽象和管理资源</li><li>引入多级队列，在 P 的基础上实现任务窃取</li></ol><p>这就是沿用至今的 G-M-P 模型。</p><p>P 它包含了运行 goroutine 的资源，如果线程想运行 goroutine，必须先获取 P，P 中还包含了可运行的 G 队列。</p><p>第二个改进点的思想主要是减少 goroutine 这个关键资源的抢占：每一个 P 管理着局部 goroutine 队列，同时还存在着全局队列，属于 P 自己的 goroutine 先用着，出队入队都不需要加锁，效率最高，再不行就去全局队列取 gorutine，效率稍低，再不行就去别的 P 任务队列中<strong>窃取</strong>，分摊压力。</p><h5 id="2-1-2-2-3-GMP-模型"><a href="#2-1-2-2-3-GMP-模型" class="headerlink" title="2.1.2.2.3 GMP 模型"></a>2.1.2.2.3 GMP 模型</h5><p>G</p><p>Goroutine 是 Go 语言调度器中待执行的任务，是一种更加细粒度的带哦度单位，使用 runtime.g 来表示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;<br><br>    <span class="hljs-comment">// Goroutine 的栈结构，stackguard 用于抢占式调度</span><br>    stack       stack   <span class="hljs-comment">// offset known to runtime/cgo</span><br>stackguard0 <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// offset known to liblink</span><br>stackguard1 <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// offset known to liblink</span><br><br>    <span class="hljs-comment">// _panic _defer 分别用于存放 panic 和 defer 链表</span><br>_panic    *_panic <span class="hljs-comment">// innermost panic - offset known to liblink</span><br>_defer    *_defer <span class="hljs-comment">// innermost defer</span><br><br>    <span class="hljs-comment">// m: 当前 goroutine 占用的线程，可能为 nil</span><br>m         *m      <span class="hljs-comment">// current m; offset known to arm liblink</span><br>    <span class="hljs-comment">// shed：和调度相关的数据</span><br>sched     gobuf<br>    <span class="hljs-comment">// goid：goroutine id，唯一标识</span><br>    goid         <span class="hljs-keyword">int64</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述字段中，需要展开的是 gobuf 结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> gobuf <span class="hljs-keyword">struct</span> &#123;<br>sp   <span class="hljs-keyword">uintptr</span><br>pc   <span class="hljs-keyword">uintptr</span><br>g    guintptr<br>ret  sys.Uintreg<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关键字段的含义：</p><ul><li>sp：栈指针</li><li>pc：程序计数器</li><li>g：持有 runtime.gobuf 的 Goroutine</li><li>ret：系统调用的返回值</li></ul><p>这些字段是用于保存 goroutine 的执行状态，也就是 goroutine 的<strong>上下文</strong>，可以看出，确实非常<strong>轻量</strong>。</p><p>M</p><p>Go 语言并发模型中的 M 是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 GOMAXPROCS 个活跃线程能够正常运行。</p><p>在默认情况下，运行时会将 GOMAXPROCS 设置成当前机器的核数，我们也可以在程序中使用 runtime.GOMAXPROCS 来改变最大的活跃线程数</p><p>M 对应的结构体如下所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> m <span class="hljs-keyword">struct</span> &#123;<br>g0      *g     <span class="hljs-comment">// goroutine with scheduling stack</span><br>    curg          *g       <span class="hljs-comment">// current running goroutine</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中 g0 是持有调度栈的 goroutine，curg 是在当前线程上运行的用户 goroutine，这两者是线程运行唯一需要关心的。</p><p>P</p><p>调度器中的 processor P 是线程和 goroutine 的中间层，它能提供线程需要的上下文环境，也会负责调度线程上的等待队列，通过 P 的调度，每一个内核线程都能够执行多个 goroutine，它能在 goroutine 进行一些 I/O 操作时及时让出计算资源，提高线程的利用率</p><p>runtime.p 是处理器的运行时表示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> p <span class="hljs-keyword">struct</span> &#123;<br>id          <span class="hljs-keyword">int32</span><br>status      <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// one of pidle/prunning/...</span><br>m           muintptr   <span class="hljs-comment">// back-link to associated m (nil if idle)</span><br>    <span class="hljs-comment">// ...</span><br><span class="hljs-comment">// Queue of runnable goroutines. Accessed without lock.</span><br>runqhead <span class="hljs-keyword">uint32</span><br>runqtail <span class="hljs-keyword">uint32</span><br>runq     [<span class="hljs-number">256</span>]guintptr<br><br>runnext guintptr<br><br><span class="hljs-comment">// Per-P GC state</span><br><span class="hljs-comment">// gcXXX   xxx</span><br><br>    <span class="hljs-comment">// Per-P timer</span><br><span class="hljs-comment">// xxTimer xxx</span><br>&#125;<br></code></pre></td></tr></table></figure><p>m 维护着线程与处理器之间的关系，而 runqhead、runqtail 和 runq 三个字段表示处理器持有的运行队列，status 字段会是以下五种中的一种：</p><ul><li>_Pidle    ：处理器没有运行用户代码或者调度器，被空闲队列或者改变其状态的结构持有，运行队列为空</li><li>_Prunning    ：被线程 M 持有，并且正在执行用户代码或者调度器</li><li>_Psyscall    ：没有执行用户代码，当前线程陷入系统调用</li><li>_Pgcstop    ：被线程 M 持有，当前处理器由于垃圾回收被停止</li><li>_Pdead    ：当前处理器已经不被使用</li></ul><h5 id="2-1-2-2-4-GMP-细节"><a href="#2-1-2-2-4-GMP-细节" class="headerlink" title="2.1.2.2.4 GMP 细节"></a>2.1.2.2.4 GMP 细节</h5><ol><li>P 和 M 的创建时机？</li></ol><p>P 创建的时机：确定了 P 的最大数量之后，Golang 运行时初始化时会创建相应数量的 P<br>M 创建的时机：当没有足够的 M 去和 P 关联</p><ol start="2"><li>GMP 执行流</li></ol><p><img src="https://cdn.learnku.com/uploads/images/202003/11/58489/a4vWtvRWGQ.jpeg!large" alt="调度流程"></p><ol><li><p>调用 go func () 创建一个 goroutine；</p></li><li><p>新创建的 G 优先保存在 P 的<strong>本地队列</strong>中，如果 P 的本地队列已经满了就会保存在全局的队列中；</p></li><li><p>M 需要在 P 的本地队列弹出一个可执行的 G，如果 P 的本地队列为空，则先会去<strong>全局队列</strong>中获取 G，如果全局队列也为空则去其他 P 中<strong>偷取</strong> G 放到自己的 P 中</p></li><li><p>G 将相关参数传输给 M，为 M 执行 G 做准备</p></li><li><p>当 M 执行某一个 G 时候如果发生了<strong>系统调用</strong>并且导致 M 阻塞，如果当前 P 队列中有一些 G，runtime 会将线程 M 和 P 分离，然后再获取空闲的线程或创建一个新的内核级的线程来服务于这个 P，阻塞调用完成后 G 被销毁将值返回；</p></li><li><p>销毁 G，将执行结果返回</p></li><li><p>当 M 系统调用结束时候，这个 M 会尝试获取一个空闲的 P 执行，如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中。</p></li><li><p>GMP 相较于 GM 的优化点</p><ol><li>本地队列带来锁竞争的减少</li><li>Work Stealing 算法</li><li>调用阻塞的系统调用时，会 detach M（ M 释放绑定的 P），提高了资源利用率</li></ol></li></ol><h3 id="2-2-字节跳动-基础架构-Rust-框架组"><a href="#2-2-字节跳动-基础架构-Rust-框架组" class="headerlink" title="2.2 字节跳动-基础架构-Rust 框架组"></a>2.2 字节跳动-基础架构-Rust 框架组</h3><h4 id="2-2-1-tower-中间件模型"><a href="#2-2-1-tower-中间件模型" class="headerlink" title="2.2.1 tower 中间件模型"></a>2.2.1 tower 中间件模型</h4><p>最主要的一点是，采用了洋葱圈模型，之前的系列博客中已经详细说明其实现原理以及设计思路。</p><h4 id="2-2-2-rpc-框架的序列化和反序列化"><a href="#2-2-2-rpc-框架的序列化和反序列化" class="headerlink" title="2.2.2 rpc 框架的序列化和反序列化"></a>2.2.2 rpc 框架的序列化和反序列化</h4><h5 id="2-2-2-1-protobuf-编解码"><a href="#2-2-2-1-protobuf-编解码" class="headerlink" title="2.2.2.1 protobuf 编解码"></a>2.2.2.1 protobuf 编解码</h5><p>带着 protobuf <strong>体积小，编解码快</strong>的优点，来探究一下其深层的原理</p><ol><li>varint 和 zigzag 的编码方式：varint 是一种变长编码方式，对于小整数，可以节约相当多的空间，而 zigzag 编码则是通过将有符号整数映射为无符号整数，解决 varint 对于负数编码效率低的问题。</li><li>隔断冗余信息的剔除：protobuf <strong>首先将消息里每一个字段编码之后</strong>，再通过 key + length + data (TLV) 的方式存储数据（length 可选），减少了分隔符的使用，存储非常紧凑，空间利用率高</li></ol><p><img src="/images/protobuf2.png" alt="protobuf"></p><p>Xml 这种需要文档结构解析的传输方式，效率低下自不必多言，Json 虽然简单直观，但是不论是编解码还是压缩，和 protobuf 相比都不尽如人意。</p>]]></content>
    
    
    <categories>
      
      <category>experience</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>why we sleep</title>
    <link href="/2022/03/03/life/why%20we%20sleep/"/>
    <url>/2022/03/03/life/why%20we%20sleep/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>睡眠占据了人一生中三分之一的时间，没有一分钟的睡眠是在浪费时间</p><h2 id="2-博主观点"><a href="#2-博主观点" class="headerlink" title="2. 博主观点"></a>2. 博主观点</h2><h3 id="2-1-睡眠的危害可能要超出你的想象：不要再熬夜刷手机看电视啦！"><a href="#2-1-睡眠的危害可能要超出你的想象：不要再熬夜刷手机看电视啦！" class="headerlink" title="2.1 睡眠的危害可能要超出你的想象：不要再熬夜刷手机看电视啦！"></a>2.1 睡眠的危害可能要超出你的想象：不要再熬夜刷手机看电视啦！</h3><p><a href="https://www.bilibili.com/video/BV1wf4y1777a">视频链接</a></p><h4 id="2-1-1-人为什么到点要睡觉"><a href="#2-1-1-人为什么到点要睡觉" class="headerlink" title="2.1.1 人为什么到点要睡觉"></a>2.1.1 人为什么到点要睡觉</h4><p>两个因素在主导我们的睡眠，调节我们的习惯：生物钟 + 腺苷（化学物质）</p><p>所谓生物钟，其实真的对应人脑中的一个结构：视交叉上核（视觉神经会先形成一个交叉，再与视觉皮层相连，而上核值的就是在这个交叉的上方的一个脑组织）。生物钟对光信号进行抽象分析，通过控制松果体的褪黑激素含量，从而间接调节<strong>昼夜规律</strong>。</p><p>另一个因素腺苷，则是直接调节睡眠。腺苷浓度越高，就越容易犯困。腺苷作用于细胞上的受体，因而，通过某些手段阻止腺苷与受体结合，就可以<strong>暂时性缓解困意</strong>，咖啡因就是很好的阻断剂。但是，咖啡因一旦被分解，就不再生效，腺苷就会重新掌握主导权，因此可以将这种情况称为<strong>睡眠负债</strong>。清楚腺苷的唯一手段就是睡眠。也就是说，出来混总是要还的，咖啡因不是长久之计。</p><h4 id="2-1-2-睡眠阶段"><a href="#2-1-2-睡眠阶段" class="headerlink" title="2.1.2 睡眠阶段"></a>2.1.2 睡眠阶段</h4><p>以 90 分钟为一个周期，分为下面五个阶段：</p><ol><li>阶段一/二：浅度非快速眼动睡眠</li><li>阶段三/四：深度非快速眼动睡眠</li><li>阶段五：快速眼动睡眠</li></ol><p>每一个周期占据主导的阶段不一样，作用也不同，所以必须要 5-6 个周期一起完成，达芬奇睡眠法 <strong>is totally unaccepatable</strong>.</p><p>对我们最关键的其实是<strong>深度睡眠</strong>，因为在这个阶段，大脑会执行一个重要的工作：记忆力固化。此时大脑会将在海马体中的<strong>事实记忆</strong>转移到大脑皮层中，从而形成更加深刻的<strong>技能记忆</strong>，逐渐形成本能。</p><p>同时，关于老年痴呆症的病因，有研究表明其就和深度睡眠有关，如果深度睡眠不足，大脑中的一些毒性蛋白无法清理，积累过多之后，就会损害大脑深度睡眠的能力，形成恶性循环（细思极恐啊）。</p><p>快速眼动睡眠也非常有意思，此时大脑的活跃度比平时高出了 30%，说不定就能灵光乍现，发现个了不起的定律，得个诺贝尔奖啥的。有研究表明，快速眼动睡眠和人白天的情绪强相关，大脑会在这个阶段尝试去重现白天的负面情绪，试着将这个情绪从记忆中剥离（sleep heals everything）。然而这种消除负面情绪的功能还会受到一个很重要的激素影响：<strong>去甲肾上腺素</strong>。这个激素会给人带来负面情绪（参见 PTSD 患者），导致大脑在这个阶段不断尝试复现负面情绪，噩梦连续剧就降临了。</p><h4 id="2-1-3-参考资料"><a href="#2-1-3-参考资料" class="headerlink" title="2.1.3 参考资料"></a>2.1.3 参考资料</h4><p>[1] <a href="https://64sr5eu63h.pdcdn.xyz/dl2.php?id=199776564&h=ba9f8b92297637f0f6df5cdc8d6109ff&u=cache&ext=pdf&n=Why%20we%20sleep%20unlocking%20the%20power%20of%20sleep%20and%20dreams">why we sleep.pdf</a></p><h3 id="2-2-如何用5小时睡出10小时的效果？"><a href="#2-2-如何用5小时睡出10小时的效果？" class="headerlink" title="2.2 如何用5小时睡出10小时的效果？"></a>2.2 如何用5小时睡出10小时的效果？</h3><p><a href="https://www.bilibili.com/video/BV1jh411a7Jm">视频链接</a></p><h4 id="2-2-1-睡眠负债"><a href="#2-2-1-睡眠负债" class="headerlink" title="2.2.1 睡眠负债"></a>2.2.1 睡眠负债</h4><p>科学家进行了很多的实验，发现睡眠时间一旦不足，将很难恢复（需要连续多天长时间睡眠，对于现代人来说基本做不到）。也就是说，<strong>睡眠负债不可偿还</strong>，背后正是<strong>腺苷</strong>在作祟。</p><h4 id="2-2-2-不要忽视最初的困意"><a href="#2-2-2-不要忽视最初的困意" class="headerlink" title="2.2.2 不要忽视最初的困意"></a>2.2.2 不要忽视最初的困意</h4><p>生长激素在第一个周期的非 REM（rapid eye movement） 睡眠阶段分泌尤其显著，如果在平时已经入睡的阶段坚持不睡，那么就会缺乏促使你入睡的激素，甚至是失眠</p><p><img src="/images/%E6%B7%B1%E5%BA%A6%E7%9D%A1%E7%9C%A0.png" alt="深度睡眠"></p><h4 id="2-2-3-如何快速入睡"><a href="#2-2-3-如何快速入睡" class="headerlink" title="2.2.3 如何快速入睡"></a>2.2.3 如何快速入睡</h4><p>人体有两个开关，可以调节清醒状态。一个是体温，另一个是大脑。</p><p>对于体温来说，有研究表明，体内温度与体表温度差越大，越有利于清醒，反之有利于睡眠。因此睡前90分钟左右洗澡，之后让体内温度慢慢下降，这样就可以达到一个有利于睡眠的温度差；或者可以睡前洗脚，通过手脚部位发达的毛细血管来来散发体内热量，也能达到类似的效果。</p><p>对于大脑而言，睡前减少光的刺激也有助于生长激素分泌，如果实在需要电子设备办公，建议将其调节为<strong>夜晚/护眼模式</strong>，这样光线才不会过于刺激。同时，睡前尽量不要让大脑过于兴奋，做一些可以放松的事情，听听歌，看看书都是不错的活动。</p><h4 id="2-2-4-睡眠作息修改"><a href="#2-2-4-睡眠作息修改" class="headerlink" title="2.2.4 睡眠作息修改"></a>2.2.4 睡眠作息修改</h4><p>不推荐一次性将睡觉时间往前或往后挪动太多，如果定下了入睡时间的目标，建议少量多次，让身体逐渐适应这个过程，同时可以运用到体温调节这个方式，调整自己的洗浴时间。</p><p>要养成科学的作息习惯，首先要从固定起床时间做起，逐步调节入睡时间，这才是最有效的方法。</p><h4 id="2-2-5-午觉"><a href="#2-2-5-午觉" class="headerlink" title="2.2.5 午觉"></a>2.2.5 午觉</h4><p>先来看一组研究数据</p><ul><li>每天午休时间不超过 30 分钟的人，得老年痴呆的概率是不午休人的 1/7</li><li>每天午休 30-60 分钟的人，得老年痴呆的概率是不午休人的 1/2</li><li>每天午休时间超过 60 分钟的人，得老年痴呆的概率比不午休人高出 2 倍</li></ul><p>如果不想午睡，建议午饭少吃一些淀粉类食物，降低血糖浓度，减少困意。</p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
      <category>sleep</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>char device driver</title>
    <link href="/2022/02/25/linux/device/char%20device/"/>
    <url>/2022/02/25/linux/device/char%20device/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是字符设备驱动"><a href="#1-什么是字符设备驱动" class="headerlink" title="1. 什么是字符设备驱动"></a>1. 什么是字符设备驱动</h2><p>Linux将设备分为三大类：字符设备、块设备和网络设备。字符设备是其中较为基础的一类，它的读写操作需要一个字节一个字节地进行，无法随机读取设备中的某一字节的数据。比较常见的字符设备有鼠标、键盘、串口等。</p><h2 id="2-char-device-driver-internal"><a href="#2-char-device-driver-internal" class="headerlink" title="2. char device driver internal"></a>2. char device driver internal</h2><h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><p>Linux 使用 cdev 结构体来表示一个字符设备</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br><span class="hljs-keyword">dev_t</span> dev;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> count;<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p>kojb 不必多说，嵌入在 cdev 中，从而构成设备间的层次关系。</p><p>其中，dev_t 表示设备号，一共有 32 bit，其中 24 bit 为主设备号，8 bit 为次设备号，可以通过下面的宏快速操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAJOR(dev)((dev)&gt;&gt;8)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MINOR(dev)((dev) &amp; 0xff)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MKDEV(ma,mi)((ma)&lt;&lt;8 | (mi))</span><br></code></pre></td></tr></table></figure><p>另一个关键成员 ops 则定义了字符设备驱动提供给虚拟文件系统的接口函数。</p><h3 id="2-2-设备初始化"><a href="#2-2-设备初始化" class="headerlink" title="2.2 设备初始化"></a>2.2 设备初始化</h3><p>每种设备都需要分配空间+初始化之后才能使用，字符设备也不例外，分别对应 cdev_alloc 和cdev_device_add。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">struct cdev *<span class="hljs-title">cdev_alloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> *<span class="hljs-title">p</span> =</span> kzalloc(<span class="hljs-keyword">sizeof</span>(struct cdev), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (p) &#123;<br>INIT_LIST_HEAD(&amp;p-&gt;<span class="hljs-built_in">list</span>);<br>kobject_init(&amp;p-&gt;kobj, &amp;ktype_cdev_dynamic);<br>&#125;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cdev_device_add</span><span class="hljs-params">(struct cdev *cdev, struct device *dev)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> rc = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (dev-&gt;devt) &#123;<br>cdev_set_parent(cdev, &amp;dev-&gt;kobj);<br><br>rc = cdev_add(cdev, dev-&gt;devt, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (rc)<br><span class="hljs-keyword">return</span> rc;<br>&#125;<br><br>rc = device_add(dev);<br><span class="hljs-keyword">if</span> (rc)<br>cdev_del(cdev);<br><br><span class="hljs-keyword">return</span> rc;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时需要注意，调用 <code>cdev_device_add</code> 添加设备之前，还需要通过 <code>register_chrdev_region</code> 申请设备号，从而赋予该设备唯一的标识</p><h3 id="2-3-文件系统-API"><a href="#2-3-文件系统-API" class="headerlink" title="2.3 文件系统 API"></a>2.3 文件系统 API</h3><p>file_operations 中的回调函数是字符设备驱动的关键，这些函数会在虚拟文件系统的 open，read，write，close 等操作时被内核回调。</p><p>下面通过一些具体的例子来说明字符设备驱动应该如何设置 file_operations</p><h4 id="2-3-1-tty"><a href="#2-3-1-tty" class="headerlink" title="2.3.1 tty"></a>2.3.1 tty</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">tty_fops</span> =</span> &#123;<br>.llseek= no_llseek,<br>.read= tty_read,<br>.write= tty_write,<br>.poll= tty_poll,<br>.unlocked_ioctl= tty_ioctl,<br>.compat_ioctl= tty_compat_ioctl,<br>.open= tty_open,<br>.release= tty_release,<br>.fasync= tty_fasync,<br>.show_fdinfo= tty_show_fdinfo,<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>device</category>
      
      <category>driver</category>
      
      <category>char</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/02/25/linux/network/unix%20socket/"/>
    <url>/2022/02/25/linux/network/unix%20socket/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>tcpdump 原理</title>
    <link href="/2022/02/25/linux/network/tcpdump/"/>
    <url>/2022/02/25/linux/network/tcpdump/</url>
    
    <content type="html"><![CDATA[<h2 id="1-tcpdump-简介"><a href="#1-tcpdump-简介" class="headerlink" title="1. tcpdump 简介"></a>1. tcpdump 简介</h2><p>tcpdump 类似于 wireshark，是常用的一款抓包工具，其是如何抓到内核态的网络包的呢？如果让你写一个抓包程序，你能完成吗？</p><h2 id="2-tcpdump-internal"><a href="#2-tcpdump-internal" class="headerlink" title="2. tcpdump internal"></a>2. tcpdump internal</h2><h3 id="2-1-tcpdump-抓包点"><a href="#2-1-tcpdump-抓包点" class="headerlink" title="2.1 tcpdump 抓包点"></a>2.1 tcpdump 抓包点</h3><p>首先要明确，tcpdump 抓包的入口在何处，这里先讨论收包这种情况：</p><p>从软中断到tcp/ip协议栈的收包路径为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs text">net_rx_action<br>    --&gt; napi_poll<br>        --&gt; napi_struct-&gt;poll<br>        --&gt; napi_complete_done<br>            --&gt; netif_receive_skb_list_internal<br>                --&gt; __netif_receive_skb_list_core<br>                    --&gt; __netif_receive_skb_core<br>                    --&gt; ip_list_rcv<br></code></pre></td></tr></table></figure><p>其中，napi_xxx 是 napi 驱动相关的操作，netif 是设备层面的操作，到了 ip_list_rcv，就要逐步交给上层协议栈去处理了。</p><p>tcpdump 的作用位置正是位于 <code>__netif_receive_skb_core</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __netif_receive_skb_core(struct sk_buff **pskb, <span class="hljs-keyword">bool</span> pfmemalloc,<br>    struct packet_type **ppt_prev)<br>&#123;<br>list_for_each_entry_rcu(ptype, &amp;ptype_all, <span class="hljs-built_in">list</span>) &#123;<br><span class="hljs-keyword">if</span> (pt_prev)<br>ret = deliver_skb(skb, pt_prev, orig_dev);<br>pt_prev = ptype;<br>&#125;<br><br>list_for_each_entry_rcu(ptype, &amp;skb-&gt;dev-&gt;ptype_all, <span class="hljs-built_in">list</span>) &#123;<br><span class="hljs-keyword">if</span> (pt_prev)<br>ret = deliver_skb(skb, pt_prev, orig_dev);<br>pt_prev = ptype;<br>&#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该函数中，遍历了 ptype_all/dev-&gt;ptype_all，并且针对其中的每一个 ptype，都会调用 <code>deliver_skb</code> 处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/netdevice.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packet_type</span> &#123;</span><br>__be16type;<span class="hljs-comment">/* This is really htons(ether_type). */</span><br><span class="hljs-keyword">bool</span>ignore_outgoing;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span>*<span class="hljs-title">dev</span>;</span><span class="hljs-comment">/* NULL is wildcarded here     */</span><br><span class="hljs-keyword">int</span>(*func) (struct sk_buff *,<br> struct net_device *,<br> struct packet_type *,<br> struct net_device *);<br><span class="hljs-keyword">void</span>(*list_func) (struct list_head *,<br>      struct packet_type *,<br>      struct net_device *);<br><span class="hljs-keyword">bool</span>(*id_match)(struct packet_type *ptype,<br>    struct sock *sk);<br><span class="hljs-keyword">void</span>*af_packet_priv;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">list</span>;</span><br>&#125;;<br><br><span class="hljs-comment">//net/core/dev.c</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">deliver_skb</span><span class="hljs-params">(struct sk_buff *skb,</span></span><br><span class="hljs-params"><span class="hljs-function">      struct packet_type *pt_prev,</span></span><br><span class="hljs-params"><span class="hljs-function">      struct net_device *orig_dev)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">return</span> pt_prev-&gt;func(skb, skb-&gt;dev, pt_prev, orig_dev);<br>&#125;<br></code></pre></td></tr></table></figure><p>而在 <code>deliver_skb</code> 中，直接调用了 <code>packet_type-&gt;func</code> 进行回调，从而触发 tcpdump 事先设置好的回调函数。</p><h3 id="2-2-tcpdump-与-ptype-all"><a href="#2-2-tcpdump-与-ptype-all" class="headerlink" title="2.2 tcpdump 与 ptype_all"></a>2.2 tcpdump 与 ptype_all</h3><p>上面提到，Linux 在网络收包路径中，已经为我们提供了 hook 点：<code>ptype_all</code>，只需要提前注册抓包相关的处理函数，就可以通过回调完成 tcpdump 的基本功能了。那么，就下来就来研究一下 tcpdump 是如何和 ptype_all 关联的。</p><p>通过 <code>trace tcpdump -i eth0</code> 来查看 tcpdump 的内核函数调用链，发现其源头在于 <code>socket(AF_PACKET, SOCK_RAW, xxx)</code></p><p>对于 socket api 有过了解的同学可能知道，socket 相当于一个多路复用器，该函数中的第一个参数 AF_PACKET 表示 packet 类型的协议族，对应注册到系统中的 <code>packet_family_ops</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_proto_family</span> <span class="hljs-title">packet_family_ops</span> =</span> &#123;<br>.family =PF_PACKET,<br>.create =packet_create,<br>.owner=THIS_MODULE,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 socket 对应的系统调用中，会取出该 net_proto_family，并调用 <code>pf-&gt;create()</code> 来完成 socket 的创建，从而完成该特定类型 sock 的初始化工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> __sock_create(struct net *net, <span class="hljs-keyword">int</span> family, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> protocol,<br> struct socket **res, <span class="hljs-keyword">int</span> kern)<br>&#123;<br><span class="hljs-keyword">if</span> (family &lt; <span class="hljs-number">0</span> || family &gt;= NPROTO)<br><span class="hljs-keyword">return</span> -EAFNOSUPPORT;<br><span class="hljs-keyword">if</span> (type &lt; <span class="hljs-number">0</span> || type &gt;= SOCK_MAX)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br>sock = sock_alloc();<br>    <br>    <span class="hljs-comment">// ...</span><br>pf = rcu_dereference(net_families[family]);<br>err = pf-&gt;create(net, sock, protocol, kern);<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由上可知，AF_PACKET 的关键在于 <code>packet_create</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_create</span><span class="hljs-params">(struct net *net, struct socket *sock, <span class="hljs-keyword">int</span> protocol,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">int</span> kern)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ...</span><br>po-&gt;prot_hook.func = packet_rcv;<br><br><span class="hljs-keyword">if</span> (sock-&gt;type == SOCK_PACKET)<br>po-&gt;prot_hook.func = packet_rcv_spkt;<br><br>po-&gt;prot_hook.af_packet_priv = sk;<br><br><span class="hljs-keyword">if</span> (proto) &#123;<br>po-&gt;prot_hook.type = proto;<br>__register_prot_hook(sk);<br>&#125;<br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __register_prot_hook(struct sock *sk)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packet_sock</span> *<span class="hljs-title">po</span> =</span> pkt_sk(sk);<br><br><span class="hljs-keyword">if</span> (!po-&gt;running) &#123;<br><span class="hljs-keyword">if</span> (po-&gt;fanout)<br>__fanout_link(sk, po);<br><span class="hljs-keyword">else</span><br>dev_add_pack(&amp;po-&gt;prot_hook);<br><br>sock_hold(sk);<br>po-&gt;running = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数中将 <code>prot_hook.func</code> 设置为 <code>packet_rcv</code>，并且通过 <code>__register_prot_hook</code>，将 prot_hook 注册到了 dev 的 ptype_all 链表中。这样，在遍历 dev-&gt;ptype_all 链表时，就可以找到 <code>packet_rcv</code> 并执行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> struct list_head *<span class="hljs-title">ptype_head</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct packet_type *pt)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (pt-&gt;type == htons(ETH_P_ALL))<br><span class="hljs-keyword">return</span> pt-&gt;dev ? &amp;pt-&gt;dev-&gt;ptype_all : &amp;ptype_all;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> pt-&gt;dev ? &amp;pt-&gt;dev-&gt;ptype_specific :<br> &amp;ptype_base[ntohs(pt-&gt;type) &amp; PTYPE_HASH_MASK];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dev_add_pack</span><span class="hljs-params">(struct packet_type *pt)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">head</span> =</span> ptype_head(pt);<br><br>spin_lock(&amp;ptype_lock);<br>list_add_rcu(&amp;pt-&gt;<span class="hljs-built_in">list</span>, head);<br>spin_unlock(&amp;ptype_lock);<br>&#125;<br>EXPORT_SYMBOL(dev_add_pack);<br></code></pre></td></tr></table></figure><p>之前的解释其实并不太严谨，因为在 <code>ptype_head</code> 中，会根据 packet_type 是否设置了 dev 字段，进而判断将 packet_type 挂载到 dev-&gt;ptype_all 还是全局的 ptype_all 上。但无论是哪种情况，在 <code>__netif_receive_skb_core</code> 都会进行处理</p><h3 id="2-3-发送数据包"><a href="#2-3-发送数据包" class="headerlink" title="2.3 发送数据包"></a>2.3 发送数据包</h3><p>发送数据包的情况有所不同，因为 Linux 中还存在 netfilter 用来过滤数据包，如果数据包在到达 AF_PACKET 发包抓包点之前就已经被丢弃，无论如何也采集不到该数据包的内容。</p><p>进入到设备层之后，发包的函数调用链为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">dev_hard_start_xmit<br>--&gt; xmit_one<br>--&gt; dev_queue_xmit_nit<br>--&gt; deliver_skb // 遍历 ptype_all 链表，处理 AF_PACKET 回调 <br>--&gt; netdev_start_xmit<br>--&gt; __netdev_start_xmit<br>--&gt; ops-&gt;ndo_start_xmit // 网卡驱动发送数据包<br></code></pre></td></tr></table></figure><p>在发送数据包之前，会在 <code>dev_queue_xmit_nit</code> 中处理 ptype_all 链表上注册的回调函数，之后的处理相信大家都已经了然于胸了。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>network</category>
      
      <category>tcpdump</category>
      
      <category>af_packet</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>platform device driver</title>
    <link href="/2022/02/24/linux/device/platform_driver/"/>
    <url>/2022/02/24/linux/device/platform_driver/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是平台设备驱动"><a href="#1-什么是平台设备驱动" class="headerlink" title="1. 什么是平台设备驱动"></a>1. 什么是平台设备驱动</h2><p>首先需要区分物理总线和驱动总线。</p><ul><li>物理总线：芯片和功能外设之间传送信息的公共（专用）通信线路，包括了地址总线，数据总线，控制总线，传递的是电信号。</li><li>驱动总线：Linux 为设备驱动模型虚拟出来的总线，指定，执行设备与驱动的匹配规则，自动完成设备与驱动之间的匹配，执行驱动的初始化函数。</li></ul><p>对于常见的 I2C，USB，PCI 等物理总线，Linux 都会为其自动创建驱动总线，该设备就连接到对应的总线上。但其实，实际中很多设备并不需要物理总线，比如时钟，按键等等，为了这些简单的设备也能遵循设备驱动模型，Linux 引入了一种虚拟总线：平台总线。相应也就有了平台设备（platform_device）以及平台驱动（platform_driver），分别继承（嵌入）了 device 和 driver，可以看做是特殊的子类型。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>device</category>
      
      <category>driver</category>
      
      <category>platform</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kobject</title>
    <link href="/2022/02/24/linux/device/kobject/"/>
    <url>/2022/02/24/linux/device/kobject/</url>
    
    <content type="html"><![CDATA[<h2 id="1-kobject-是什么"><a href="#1-kobject-是什么" class="headerlink" title="1. kobject 是什么"></a>1. kobject 是什么</h2><p>在 <a href="/2022/02/24/linux/device/index/" title="Linux 设备驱动框架">Linux 设备驱动框架</a> 一文中，我们提到了 Linux 设备驱动是以 Device，Bus，Driver，Class 这几种结构为核心，从而方便管理。</p><p>由于设备与设备，设备与总线之间有非常明显的拓扑关系（设备接在总线上，设备也会有依赖关系），因此，可以通过树状结构进行管理，而 kobject 就是这种管理方式的核心，同时辅助以 kset/ktype，构成了设备框架的基石。</p><h2 id="2-kobject-internal"><a href="#2-kobject-internal" class="headerlink" title="2. kobject internal"></a>2. kobject internal</h2><h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> &#123;</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*name;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">entry</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span>*<span class="hljs-title">parent</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset</span>*<span class="hljs-title">kset</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_type</span>*<span class="hljs-title">ktype</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kernfs_node</span>*<span class="hljs-title">sd</span>;</span> <span class="hljs-comment">/* sysfs directory entry */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kref</span><span class="hljs-title">kref</span>;</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> state_initialized:<span class="hljs-number">1</span>;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> state_in_sysfs:<span class="hljs-number">1</span>;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> state_add_uevent_sent:<span class="hljs-number">1</span>;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> state_remove_uevent_sent:<span class="hljs-number">1</span>;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uevent_suppress:<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>关键字段的含义：</p><ul><li>name：设备名</li><li>parent：指向父对象的指针，</li><li>kset：该 kobject 所属的集合</li><li>ktype：kobject 的类型</li><li>sd：文件系统的目录项</li><li>kref：引用计数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br><span class="hljs-keyword">spinlock_t</span> list_lock;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset_uevent_ops</span> *<span class="hljs-title">uevent_ops</span>;</span><br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p>关键字段含义：</p><ul><li>list：所包含的 kobject 链表</li><li>kobj：该 kset 也是一个特殊的 kobject</li><li>uevent_ops：用于处理 uevent 的操作</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_type</span> &#123;</span><br><span class="hljs-keyword">void</span> (*release)(struct kobject *kobj);<br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysfs_ops</span> *<span class="hljs-title">sysfs_ops</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute</span> **<span class="hljs-title">default_attrs</span>;</span><span class="hljs-comment">/* use default_groups instead */</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">default_groups</span>;</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_ns_type_operations</span> *(*<span class="hljs-title">child_ns_type</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> *<span class="hljs-title">kobj</span>);</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *(*<span class="hljs-keyword">namespace</span>)(struct kobject *kobj);<br><span class="hljs-keyword">void</span> (*get_ownership)(struct kobject *kobj, <span class="hljs-keyword">kuid_t</span> *uid, <span class="hljs-keyword">kgid_t</span> *gid);<br>&#125;;<br></code></pre></td></tr></table></figure><p>关键字段含义：</p><ul><li>release：释放 kobject 时，调用该函数，相当于析构函数</li><li>sysfs_ops：处理 sysfs 的 show/store 操作，对应文件系统的 read/write</li><li>attribute：在 sysfs 中暴露给用户的 driver 属性，可以对 driver 进行控制</li></ul><h3 id="2-2-kobject-amp-amp-kset"><a href="#2-2-kobject-amp-amp-kset" class="headerlink" title="2.2 kobject &amp;&amp; kset"></a>2.2 kobject &amp;&amp; kset</h3><h4 id="2-2-1-kobject-和-kset-关联与区别"><a href="#2-2-1-kobject-和-kset-关联与区别" class="headerlink" title="2.2.1 kobject 和 kset 关联与区别"></a>2.2.1 kobject 和 kset 关联与区别</h4><p>kobject 本身并不单独使用，而是内嵌在别的结构体中。如果用面向对象的思想来理解，那么 kobject 相当于<strong>基类</strong>，包含了 kobject 的结构体则是<strong>子类</strong>。kset 就是一个典型的子类型。</p><p>正因为 kobject 这种<strong>可嵌入</strong>的特点，可以很容易将各种数据结构按照树状结构组织起来，通过 <code>contrainer_of</code> 可以快速获取到包含 kobject 特定结构，因此，包含了 kobject 的 high-level 数据结构也有着和 kobject 类似的功能（子类继承了父类）。</p><p>前面说到，kobject 对应 sysfs 中的一个文件/目录，而 kset 作用与此类似，只不过有一个限定条件：如果需要在sysfs的目录中包含多个子目录，那需要将它定义成一个 kset，其余情况均使用 kobject 表示。</p><h4 id="2-2-2-kobject-和-kset-的使用"><a href="#2-2-2-kobject-和-kset-的使用" class="headerlink" title="2.2.2 kobject 和 kset 的使用"></a>2.2.2 kobject 和 kset 的使用</h4><p>因为 kobject 和 kset 仅仅作为一个结构体嵌入到别的复杂结构中，充当树状结构的骨架，所以其操作也比较简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text"><br>kobject_init_and_add --------<br>                            |<br>                        kobject_add ---- kobject_add_varg ---- kobject_add_internal<br>                            |                                           |<br>kobject_create_and_add ------                                           |<br>                                                                        |<br>                                                                        |<br>kset_create_and_add ------ kset_create                                  |<br>                      ---- kset_register --------------------------------<br></code></pre></td></tr></table></figure><p>主要代码都是分配结构体，初始化各个字段，构建拓扑关系（设置 kset-&gt;list 和 kobject-&gt;parent）</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>driver</category>
      
      <category>kobject</category>
      
      <category>kset</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>linux driver framework</title>
    <link href="/2022/02/24/linux/device/index/"/>
    <url>/2022/02/24/linux/device/index/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Linux-设备框架"><a href="#1-Linux-设备框架" class="headerlink" title="1. Linux 设备框架"></a>1. Linux 设备框架</h2><h3 id="1-1-软件架构"><a href="#1-1-软件架构" class="headerlink" title="1.1 软件架构"></a>1.1 软件架构</h3><p>首先必须明确一点，驱动是 Linux 中最为复杂，也是代码量最为庞大的部分。并不是因为其架构多么匪夷所思，而是作为一个通用操作系统，Linux 必须要支持 30 多种体系下面的无数硬件设备，这种复杂度已经达到了 O(n*m) 的级别。</p><p>设想一下，如果由你为一个设备编写跨平台驱动，肯定想通过尽可能少的代码改动，完成各个平台的适配，这绝非易事。如果使用普通的 <code>#ifdef</code> <code>menuconfig</code> 等方式来完成配置，也存在很多 boilerplate，因此，一个良好的框架就显得非常关键了。</p><p>下面来简化一下我们遇到的问题：让 N 个不同的设备在 M 中不同的 CPU 架构上运行起来。</p><p>这个问题咋一看复杂度高得吓人，<code>O(N*M)</code>，是一种典型的强耦合，不符合软件工程 <strong>高内聚，低耦合</strong> 的基本原则。为了改进这种<strong>网状架构</strong>，可以引入一个<strong>中间层</strong>（计算机世界所有问题都可以通过引入一个间接的中间层解决），让 N 个设备与中间层耦合，中间层与 M 种 CPU 架构耦合，这样就将复杂度降低了一个数量级。</p><h2 id="2-设备驱动模型"><a href="#2-设备驱动模型" class="headerlink" title="2. 设备驱动模型"></a>2. 设备驱动模型</h2><p>上面提到，可以通过分层的思想，降低设备框架的复杂度，具体是如何操作的呢？首先来看几个关键的概念</p><h2 id="2-1-设备，总线，驱动"><a href="#2-1-设备，总线，驱动" class="headerlink" title="2.1 设备，总线，驱动"></a>2.1 设备，总线，驱动</h2><ul><li>设备：某种物理设备，比如网卡，硬盘，USB设备等各式各样的外设。</li><li>总线：设备之间传递数据的通道，可以多个设备共用一条总线，也可以单个设备独享总线，一般总线的一端总是 CPU。</li><li>驱动：与特定设备相关的程序，用来告诉 CPU 如何控制设备工作。</li></ul><p>其中，设备和驱动是紧密相连的，设备依赖驱动来发挥功能，但是，正如上面对软件架构所分析的那样，如果设备和驱动之间直接进行匹配，后果就是强耦合，高复杂度。庆幸的一点是，还有总线！</p><p>总线充当了设备与驱动之间的中间层，分别集中对设备，驱动进行管理，就完成了解耦。</p><h3 id="2-2-总线"><a href="#2-2-总线" class="headerlink" title="2.2 总线"></a>2.2 总线</h3><h4 id="2-2-1-数据结构"><a href="#2-2-1-数据结构" class="headerlink" title="2.2.1 数据结构"></a>2.2.1 数据结构</h4><p>总线对应下面的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> &#123;</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*name;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*dev_name;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span>*<span class="hljs-title">dev_root</span>;</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">bus_groups</span>;</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">dev_groups</span>;</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">drv_groups</span>;</span><br><br><span class="hljs-keyword">int</span> (*match)(struct device *dev, struct device_driver *drv);<br><span class="hljs-keyword">int</span> (*uevent)(struct device *dev, struct kobj_uevent_env *env);<br><span class="hljs-keyword">int</span> (*probe)(struct device *dev);<br><span class="hljs-keyword">void</span> (*sync_state)(struct device *dev);<br><span class="hljs-keyword">int</span> (*remove)(struct device *dev);<br><span class="hljs-keyword">void</span> (*shutdown)(struct device *dev);<br><br><span class="hljs-keyword">int</span> (*online)(struct device *dev);<br><span class="hljs-keyword">int</span> (*offline)(struct device *dev);<br><br><span class="hljs-keyword">int</span> (*suspend)(struct device *dev, <span class="hljs-keyword">pm_message_t</span> state);<br><span class="hljs-keyword">int</span> (*resume)(struct device *dev);<br><br><span class="hljs-keyword">int</span> (*num_vf)(struct device *dev);<br><br><span class="hljs-keyword">int</span> (*dma_configure)(struct device *dev);<br><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pm_ops</span> *<span class="hljs-title">pm</span>;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iommu_ops</span> *<span class="hljs-title">iommu_ops</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subsys_private</span> *<span class="hljs-title">p</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_class_key</span> <span class="hljs-title">lock_key</span>;</span><br><br><span class="hljs-keyword">bool</span> need_parent_lock;<br>&#125;;<br></code></pre></td></tr></table></figure><p>各个字段的含义：</p><ul><li>name：总线的名称，每注册一种新的总线，就会在 <code>/sys/bus</code> 下面创建一个名为 name 的新目录</li><li>bus_groups、dev_groups、drv_groups：分别表示 总线、设备、驱动的属性</li><li>match：向总线注册一个新的设备或新的驱动，调用该函数进行匹配，</li><li>probe：总线完成设备与驱动的匹配之后，调用该函数，最终调用驱动提供的 probe 函数</li><li>remote：删除总线时，调用该函数</li><li>p：私有结构，其中的 klist_devices 和 klist_drivers 分别保存了该总线上所有的设备和驱动</li></ul><p>实际上，可以将总线也看成一个设备，不过这种设备比较特殊，它存在的目的是为了管理别的普通设备</p><h4 id="2-2-2-总线注册-注销"><a href="#2-2-2-总线注册-注销" class="headerlink" title="2.2.2 总线注册/注销"></a>2.2.2 总线注册/注销</h4><p>既然是设备，也就对应 register/unregister 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bus_register</span><span class="hljs-params">(struct bus_type *bus)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> retval;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subsys_private</span> *<span class="hljs-title">priv</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_class_key</span> *<span class="hljs-title">key</span> =</span> &amp;bus-&gt;lock_key;<br><br>    <span class="hljs-comment">// 1. 分配空间</span><br>priv = kzalloc(<span class="hljs-keyword">sizeof</span>(struct subsys_private), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!priv)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br>priv-&gt;bus = bus;<br>bus-&gt;p = priv;<br><br>    <span class="hljs-comment">// 2. 初始化 notifier</span><br>BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);<br><br>    <span class="hljs-comment">// 3. 设置 bus 名称</span><br>retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, <span class="hljs-string">&quot;%s&quot;</span>, bus-&gt;name);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> out;<br><br>priv-&gt;subsys.kobj.kset = bus_kset;<br>priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;<br>priv-&gt;drivers_autoprobe = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 4. 注册 kset</span><br>retval = kset_register(&amp;priv-&gt;subsys);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> out;<br><br>    <span class="hljs-comment">// 5. 在 /sys/bus/xxx_name 下创建 uevent 文件</span><br>retval = bus_create_file(bus, &amp;bus_attr_uevent);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bus_uevent_fail;<br><br>    <span class="hljs-comment">// 6. 创建 bus 目录下的 devices 目录</span><br>priv-&gt;devices_kset = kset_create_and_add(<span class="hljs-string">&quot;devices&quot;</span>, <span class="hljs-literal">NULL</span>,<br> &amp;priv-&gt;subsys.kobj);<br><span class="hljs-keyword">if</span> (!priv-&gt;devices_kset) &#123;<br>retval = -ENOMEM;<br><span class="hljs-keyword">goto</span> bus_devices_fail;<br>&#125;<br><br>    <span class="hljs-comment">// 7. 创建 bus 目录下的 drivers 目录</span><br>priv-&gt;drivers_kset = kset_create_and_add(<span class="hljs-string">&quot;drivers&quot;</span>, <span class="hljs-literal">NULL</span>,<br> &amp;priv-&gt;subsys.kobj);<br><span class="hljs-keyword">if</span> (!priv-&gt;drivers_kset) &#123;<br>retval = -ENOMEM;<br><span class="hljs-keyword">goto</span> bus_drivers_fail;<br>&#125;<br><br>    <span class="hljs-comment">// 8. 初始化 klist_devices 和 klist_drivers</span><br>INIT_LIST_HEAD(&amp;priv-&gt;interfaces);<br>__mutex_init(&amp;priv-&gt;mutex, <span class="hljs-string">&quot;subsys mutex&quot;</span>, key);<br>klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);<br>klist_init(&amp;priv-&gt;klist_drivers, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 9. 创建 bus 目录下的 drivers_autoprobe 和 drivers_probe 文件</span><br>retval = add_probe_files(bus);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bus_probe_files_fail;<br><br>retval = bus_add_groups(bus, bus-&gt;bus_groups);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bus_groups_fail;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 失败处理</span><br><span class="hljs-keyword">return</span> retval;<br>&#125;<br>EXPORT_SYMBOL_GPL(bus_register);<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bus_unregister</span><span class="hljs-params">(struct bus_type *bus)</span></span><br><span class="hljs-function"></span>&#123;<br>pr_debug(<span class="hljs-string">&quot;bus: &#x27;%s&#x27;: unregistering\n&quot;</span>, bus-&gt;name);<br><span class="hljs-keyword">if</span> (bus-&gt;dev_root)<br>device_unregister(bus-&gt;dev_root);<br>bus_remove_groups(bus, bus-&gt;bus_groups);<br>remove_probe_files(bus);<br>kset_unregister(bus-&gt;p-&gt;drivers_kset);<br>kset_unregister(bus-&gt;p-&gt;devices_kset);<br>bus_remove_file(bus, &amp;bus_attr_uevent);<br>kset_unregister(&amp;bus-&gt;p-&gt;subsys);<br>&#125;<br>EXPORT_SYMBOL_GPL(bus_unregister);<br></code></pre></td></tr></table></figure><p>如果对于 kobject/kset 感到疑惑，可以详细阅读另一篇 <a href="/2022/02/24/linux/device/kobject/" title="文章">文章</a>，这里只需要认识到，kobject/kset 是一种设备树状管理的方式，对应 sysfs 中的目录和文件，可以将其类比为<strong>多叉树的结点</strong></p><p>可以看到，register 操作大部分都是在 创建 sysfs 下所需的文件（夹），通过 <code>/sys/bus/BUS_NAME/devices</code> 和 <code>/sys/bus/BUS_NAME/drivers</code> 两个目录向用户暴露设备以及驱动列表，通过其余的一些文件暴露 bus 本身的一些属性。</p><p>unregister 操作这里不再赘述</p><h3 id="2-3-设备"><a href="#2-3-设备" class="headerlink" title="2.3 设备"></a>2.3 设备</h3><h4 id="2-3-1-数据结构"><a href="#2-3-1-数据结构" class="headerlink" title="2.3.1 数据结构"></a>2.3.1 数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span>*<span class="hljs-title">parent</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_private</span>*<span class="hljs-title">p</span>;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*init_name; <span class="hljs-comment">/* initial name of the device */</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_type</span> *<span class="hljs-title">type</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span>*<span class="hljs-title">bus</span>;</span><span class="hljs-comment">/* type of bus device is on */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> *<span class="hljs-title">driver</span>;</span><span class="hljs-comment">/* which driver has allocated this</span><br><span class="hljs-comment">   device */</span><br><span class="hljs-keyword">void</span>*platform_data;<span class="hljs-comment">/* Platform specific data, device</span><br><span class="hljs-comment">   core doesn&#x27;t touch it */</span><br><span class="hljs-keyword">void</span>*driver_data;<span class="hljs-comment">/* Driver data, set and get with</span><br><span class="hljs-comment">   dev_set_drvdata/dev_get_drvdata */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span><span class="hljs-title">mutex</span>;</span><span class="hljs-comment">/* mutex to synchronize calls to</span><br><span class="hljs-comment"> * its driver.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_links_info</span><span class="hljs-title">links</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pm_info</span><span class="hljs-title">power</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pm_domain</span>*<span class="hljs-title">pm_domain</span>;</span><br><br>u64*dma_mask;<span class="hljs-comment">/* dma mask (if dma&#x27;able device) */</span><br>u64coherent_dma_mask;<span class="hljs-comment">/* Like dma_mask, but for</span><br><span class="hljs-comment">     alloc_coherent mappings as</span><br><span class="hljs-comment">     not all hardware supports</span><br><span class="hljs-comment">     64 bit addresses for consistent</span><br><span class="hljs-comment">     allocations such descriptors. */</span><br>u64bus_dma_limit;<span class="hljs-comment">/* upstream dma constraint */</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_dma_region</span> *<span class="hljs-title">dma_range_map</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_dma_parameters</span> *<span class="hljs-title">dma_parms</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">dma_pools</span>;</span><span class="hljs-comment">/* dma pools (if dma&#x27;ble) */</span><br><br><span class="hljs-comment">/* arch specific additions */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_archdata</span><span class="hljs-title">archdata</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span>*<span class="hljs-title">of_node</span>;</span> <span class="hljs-comment">/* associated device tree node */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fwnode_handle</span>*<span class="hljs-title">fwnode</span>;</span> <span class="hljs-comment">/* firmware device node */</span><br><br><span class="hljs-keyword">dev_t</span>devt;<span class="hljs-comment">/* dev_t, creates the sysfs &quot;dev&quot; */</span><br>u32id;<span class="hljs-comment">/* device instance */</span><br><br><span class="hljs-keyword">spinlock_t</span>devres_lock;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">devres_head</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span>*<span class="hljs-keyword">class</span>;</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">groups</span>;</span><span class="hljs-comment">/* optional groups */</span><br><br><span class="hljs-keyword">void</span>(*release)(struct device *dev);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iommu_group</span>*<span class="hljs-title">iommu_group</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_iommu</span>*<span class="hljs-title">iommu</span>;</span><br><br><span class="hljs-keyword">bool</span>offline_disabled:<span class="hljs-number">1</span>;<br><span class="hljs-keyword">bool</span>offline:<span class="hljs-number">1</span>;<br><span class="hljs-keyword">bool</span>of_node_reused:<span class="hljs-number">1</span>;<br><span class="hljs-keyword">bool</span>state_synced:<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>关键字段的含义：</p><ul><li>kobj：内嵌的 kobject，用于设备树状结构管理</li><li>parent：该设备的父对象</li><li>init_name：设备名称</li><li>bus：归属于哪一个总线</li><li>release：设备注销时，执行该回调函数</li></ul><h4 id="2-3-2-设备注册-注销"><a href="#2-3-2-设备注册-注销" class="headerlink" title="2.3.2 设备注册/注销"></a>2.3.2 设备注册/注销</h4><p>设备需要注册之后才能使用，对应  <code>device_register</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">device_register</span><span class="hljs-params">(struct device *dev)</span></span><br><span class="hljs-function"></span>&#123;<br>device_initialize(dev);<br><span class="hljs-keyword">return</span> device_add(dev);<br>&#125;<br>EXPORT_SYMBOL_GPL(device_register);<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">device_add</span><span class="hljs-params">(struct device *dev)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">parent</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> *<span class="hljs-title">kobj</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">class_interface</span> *<span class="hljs-title">class_intf</span>;</span><br><span class="hljs-keyword">int</span> error = -EINVAL;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> *<span class="hljs-title">glue_dir</span> =</span> <span class="hljs-literal">NULL</span>;<br><br>dev = get_device(dev);<br><span class="hljs-keyword">if</span> (!dev)<br><span class="hljs-keyword">goto</span> done;<br><br><span class="hljs-keyword">if</span> (!dev-&gt;p) &#123;<br>error = device_private_init(dev);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> done;<br>&#125;<br><br>    <span class="hljs-comment">// 1. 设置 device 对应 kobject name</span><br><span class="hljs-keyword">if</span> (dev-&gt;init_name) &#123;<br>dev_set_name(dev, <span class="hljs-string">&quot;%s&quot;</span>, dev-&gt;init_name);<br>dev-&gt;init_name = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">/* subsystems can specify simple device enumeration */</span><br><span class="hljs-keyword">if</span> (!dev_name(dev) &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;dev_name)<br>dev_set_name(dev, <span class="hljs-string">&quot;%s%u&quot;</span>, dev-&gt;bus-&gt;dev_name, dev-&gt;id);<br><br><span class="hljs-keyword">if</span> (!dev_name(dev)) &#123;<br>error = -EINVAL;<br><span class="hljs-keyword">goto</span> name_error;<br>&#125;<br><br>pr_debug(<span class="hljs-string">&quot;device: &#x27;%s&#x27;: %s\n&quot;</span>, dev_name(dev), __func__);<br><br>    <span class="hljs-comment">// 设置 device parent</span><br>parent = get_device(dev-&gt;parent);<br>kobj = get_device_parent(dev, parent);<br><span class="hljs-keyword">if</span> (IS_ERR(kobj)) &#123;<br>error = PTR_ERR(kobj);<br><span class="hljs-keyword">goto</span> parent_error;<br>&#125;<br><span class="hljs-keyword">if</span> (kobj)<br>dev-&gt;kobj.parent = kobj;<br><br><span class="hljs-comment">/* use parent numa_node */</span><br><span class="hljs-keyword">if</span> (parent &amp;&amp; (dev_to_node(dev) == NUMA_NO_NODE))<br>set_dev_node(dev, dev_to_node(parent));<br><br><span class="hljs-comment">// 将 dev 注册到 sysfs 中（需要指定父结点）</span><br>error = kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (error) &#123;<br>glue_dir = get_glue_dir(dev);<br><span class="hljs-keyword">goto</span> Error;<br>&#125;<br><br><span class="hljs-comment">// 事件通知</span><br>error = device_platform_notify(dev, KOBJ_ADD);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> platform_error;<br><br>    <span class="hljs-comment">// 创建 device 的 sysfs 属性文件</span><br>error = device_create_file(dev, &amp;dev_attr_uevent);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> attrError;<br><br>error = device_add_class_symlinks(dev);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> SymlinkError;<br>error = device_add_attrs(dev);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> AttrsError;<br><br>    <span class="hljs-comment">// 将 device 添加到 bus 的 klist_devices 中，并且在 sysfs 中创建一些 link 文件</span><br>error = bus_add_device(dev);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> BusError;<br>error = dpm_sysfs_add(dev);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> DPMError;<br>device_pm_add(dev);<br><br><span class="hljs-keyword">if</span> (MAJOR(dev-&gt;devt)) &#123;<br>error = device_create_file(dev, &amp;dev_attr_dev);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> DevAttrError;<br><br>error = device_create_sys_dev_entry(dev);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">goto</span> SysEntryError;<br><br>devtmpfs_create_node(dev);<br>&#125;<br><br><span class="hljs-keyword">if</span> (dev-&gt;bus)<br>blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,<br>     BUS_NOTIFY_ADD_DEVICE, dev);<br><br>    <span class="hljs-comment">// uevent 通知</span><br>kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);<br><br><span class="hljs-keyword">if</span> (dev-&gt;fwnode &amp;&amp; !dev-&gt;fwnode-&gt;dev) &#123;<br>dev-&gt;fwnode-&gt;dev = dev;<br>fw_devlink_link_device(dev);<br>&#125;<br><br>    <span class="hljs-comment">// 完成 device 和 driver 的匹配，若匹配成功，执行 probe 函数</span><br>bus_probe_device(dev);<br><span class="hljs-keyword">if</span> (parent)<br>klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,<br>       &amp;parent-&gt;p-&gt;klist_children);<br><br><span class="hljs-keyword">if</span> (dev-&gt;class) &#123;<br>mutex_lock(&amp;dev-&gt;class-&gt;p-&gt;mutex);<br><span class="hljs-comment">/* tie the class to the device */</span><br>klist_add_tail(&amp;dev-&gt;p-&gt;knode_class,<br>       &amp;dev-&gt;class-&gt;p-&gt;klist_devices);<br><br><span class="hljs-comment">/* notify any interfaces that the device is here */</span><br>list_for_each_entry(class_intf,<br>    &amp;dev-&gt;class-&gt;p-&gt;interfaces, node)<br><span class="hljs-keyword">if</span> (class_intf-&gt;add_dev)<br>class_intf-&gt;add_dev(dev, class_intf);<br>mutex_unlock(&amp;dev-&gt;class-&gt;p-&gt;mutex);<br>&#125;<br>done:<br>put_device(dev);<br><span class="hljs-keyword">return</span> error;<br><br>    <span class="hljs-comment">// 错误处理 ...</span><br><span class="hljs-keyword">goto</span> done;<br>&#125;<br>EXPORT_SYMBOL_GPL(device_add);<br></code></pre></td></tr></table></figure><p>关键的一些操作已经添加了注释，这里还需要强调一下 <code>bus_probe_device</code>。</p><p>当设备和驱动匹配成功之后，会执行一些初始化操作，这一步必不可少，因为很多脏活累活都是在 probe 回调函数中完成的。</p><p>该 probe 函数就在 <code>device_driver</code> 结构中，而完成匹配+执行 probe 函数的任务，就交给了 <code>bus_probe_device</code>，其关键函数调用链如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">bus_probe_device<br>    --&gt; device_initial_probe<br>        --&gt; __device_attach<br>            --&gt; __device_attach_driver<br>                --&gt; driver_match_device<br>                --&gt; driver_probe_device<br>                    --&gt; really_probe<br>                        --&gt; driver-&gt;probe/bus-&gt;probe<br></code></pre></td></tr></table></figure><p>如果弄清楚了 <code>device_register</code> 的操作，那么 <code>device_unregister</code> 对你来说应该不是难事，只需要反向执行注册时执行的操作即可，详细操作可以参考 <code>device_del</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">device_unregister</span><span class="hljs-params">(struct device *dev)</span></span><br><span class="hljs-function"></span>&#123;<br>pr_debug(<span class="hljs-string">&quot;device: &#x27;%s&#x27;: %s\n&quot;</span>, dev_name(dev), __func__);<br>device_del(dev);<br>put_device(dev);<br>&#125;<br>EXPORT_SYMBOL_GPL(device_unregister);<br></code></pre></td></tr></table></figure><h3 id="2-4-驱动"><a href="#2-4-驱动" class="headerlink" title="2.4 驱动"></a>2.4 驱动</h3><h4 id="2-4-1-数据结构"><a href="#2-4-1-数据结构" class="headerlink" title="2.4.1 数据结构"></a>2.4.1 数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> &#123;</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*name;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span>*<span class="hljs-title">bus</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span>*<span class="hljs-title">owner</span>;</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*mod_name;<span class="hljs-comment">/* used for built-in modules */</span><br><br><span class="hljs-keyword">bool</span> suppress_bind_attrs;<span class="hljs-comment">/* disables bind/unbind via sysfs */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">probe_type</span> <span class="hljs-title">probe_type</span>;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span>*<span class="hljs-title">of_match_table</span>;</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">acpi_device_id</span>*<span class="hljs-title">acpi_match_table</span>;</span><br><br><span class="hljs-keyword">int</span> (*probe) (struct device *dev);<br><span class="hljs-keyword">void</span> (*sync_state)(struct device *dev);<br><span class="hljs-keyword">int</span> (*remove) (struct device *dev);<br><span class="hljs-keyword">void</span> (*shutdown) (struct device *dev);<br><span class="hljs-keyword">int</span> (*suspend) (struct device *dev, <span class="hljs-keyword">pm_message_t</span> state);<br><span class="hljs-keyword">int</span> (*resume) (struct device *dev);<br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">groups</span>;</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">dev_groups</span>;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pm_ops</span> *<span class="hljs-title">pm</span>;</span><br><span class="hljs-keyword">void</span> (*coredump) (struct device *dev);<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">driver_private</span> *<span class="hljs-title">p</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>关键字段含义：</p><ul><li>name：驱动名称，bus 通常会将该名称与设备名匹配</li><li>bus：归属于哪个总线</li><li>owner：该驱动的拥有者，一般为 THIS_MODULE</li><li>probe：当驱动和设备匹配之后，会执行该函数，对设备初始化</li><li>remove：设备从系统中移出或者系统关闭的时候，执行该函数</li></ul><h4 id="2-4-2-驱动注册-注销"><a href="#2-4-2-驱动注册-注销" class="headerlink" title="2.4.2 驱动注册/注销"></a>2.4.2 驱动注册/注销</h4><p>驱动 注册/注销 对应 <code>driver_register</code> 和 <code>driver_unregister</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">driver_register</span><span class="hljs-params">(struct device_driver *drv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> ret;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> *<span class="hljs-title">other</span>;</span><br><br><span class="hljs-keyword">if</span> (!drv-&gt;bus-&gt;p) &#123;<br>pr_err(<span class="hljs-string">&quot;Driver &#x27;%s&#x27; was unable to register with bus_type &#x27;%s&#x27; because the bus was not initialized.\n&quot;</span>,<br>   drv-&gt;name, drv-&gt;bus-&gt;name);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><br>    <span class="hljs-comment">// 判断回调函数是否完备</span><br><span class="hljs-keyword">if</span> ((drv-&gt;bus-&gt;probe &amp;&amp; drv-&gt;probe) ||<br>    (drv-&gt;bus-&gt;remove &amp;&amp; drv-&gt;remove) ||<br>    (drv-&gt;bus-&gt;shutdown &amp;&amp; drv-&gt;shutdown))<br>pr_warn(<span class="hljs-string">&quot;Driver &#x27;%s&#x27; needs updating - please use &quot;</span><br><span class="hljs-string">&quot;bus_type methods\n&quot;</span>, drv-&gt;name);<br><br>    <span class="hljs-comment">// 根据 driver 名称在bus中查找该driver是否已注册</span><br>other = driver_find(drv-&gt;name, drv-&gt;bus);<br><span class="hljs-keyword">if</span> (other) &#123;<br>pr_err(<span class="hljs-string">&quot;Error: Driver &#x27;%s&#x27; is already registered, &quot;</span><br><span class="hljs-string">&quot;aborting...\n&quot;</span>, drv-&gt;name);<br><span class="hljs-keyword">return</span> -EBUSY;<br>&#125;<br><br>    <span class="hljs-comment">// 将 driver 添加到 bus 中，同时完成匹配+probe操作</span><br>ret = bus_add_driver(drv);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">return</span> ret;<br>ret = driver_add_groups(drv, drv-&gt;groups);<br><span class="hljs-keyword">if</span> (ret) &#123;<br>bus_remove_driver(drv);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>    <span class="hljs-comment">// uevent 通知</span><br>kobject_uevent(&amp;drv-&gt;p-&gt;kobj, KOBJ_ADD);<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>EXPORT_SYMBOL_GPL(driver_register);<br></code></pre></td></tr></table></figure><p>与 device 类似，添加一个驱动时，也需要查找有没有匹配的设备，如果有，就执行 probe 函数，这一步是在 <code>bus_probe_device</code> 中完成的，其函数调用链如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">bus_add_driver<br>    --&gt; driver_attach<br>        --&gt; __device_attach<br>            --&gt; __device_attach_driver<br>                --&gt; driver_match_device<br>                --&gt; driver_probe_device<br>                    --&gt; really_probe<br>                        --&gt; driver-&gt;probe/bus-&gt;probe<br></code></pre></td></tr></table></figure><p>同理，驱动的注销对应 <code>driver_unregister</code>，详细操作位于 <code>bus_remove_driver</code>，也基本是注册驱动时的逆向操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">driver_unregister</span><span class="hljs-params">(struct device_driver *drv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!drv || !drv-&gt;p) &#123;<br>WARN(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Unexpected driver unregister!\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>driver_remove_groups(drv, drv-&gt;groups);<br>bus_remove_driver(drv);<br>&#125;<br>EXPORT_SYMBOL_GPL(driver_unregister);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>driver</category>
      
      <category>framework</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kernel &amp;&amp; nic &amp;&amp; napic</title>
    <link href="/2022/02/23/linux/network/kernel%20&amp;&amp;%20nic%20&amp;&amp;%20napi/"/>
    <url>/2022/02/23/linux/network/kernel%20&amp;&amp;%20nic%20&amp;&amp;%20napi/</url>
    
    <content type="html"><![CDATA[<h2 id="1-kernel-与-nic-交互"><a href="#1-kernel-与-nic-交互" class="headerlink" title="1. kernel 与 nic 交互"></a>1. kernel 与 nic 交互</h2><p>接收数据帧的过程中，kernel 与网卡有两种交互方式：</p><ol><li>中断（interrupt）</li><li>轮询（polling）</li></ol><h3 id="1-1-中断方式"><a href="#1-1-中断方式" class="headerlink" title="1.1 中断方式"></a>1.1 中断方式</h3><p>如果要保证低延迟（laytency）则可以考虑中断的方式，保证一有数据就通过硬件中断通知 CPU，然后中断处理函数读取数据包，存放到上层的输入队列，再通知内核</p><h3 id="1-2-轮询方式"><a href="#1-2-轮询方式" class="headerlink" title="1.2 轮询方式"></a>1.2 轮询方式</h3><p>采用 polling 的方式，定期检查网络设备中是否有数据，如果有数据，就连续将数据读出，从而提高吞吐量</p><h3 id="1-3-中断轮询结合"><a href="#1-3-中断轮询结合" class="headerlink" title="1.3 中断轮询结合"></a>1.3 中断轮询结合</h3><p>既然这两者都有一定的局限，为何不将它们结合起来？这就是 NAPI（new api）的工作方式了。</p><p>NIC 接收到数据之后，通过中断通知 kernel，但是硬件中断处理函数并不分配 skb，也不读取数据包，而是将相应设备（napi_struct）添加到 poll 队列中，取消该网卡的硬件中断，触发下半部的软中断，由下半部的异步方式一次性读取完成设备上的所有数据或者达到配额上限，该步骤完成之后，重新启用网卡中断。</p><h3 id="1-4-中断上半部-VS-中断下半部"><a href="#1-4-中断上半部-VS-中断下半部" class="headerlink" title="1.4 中断上半部 VS 中断下半部"></a>1.4 中断上半部 VS 中断下半部</h3><p>大家知道，（硬件）中断是为了快速相应外部设备的一些事件，Linux 为了简化中断逻辑，减少竞争，规定中断不能被抢占（non-preemptive），也是不可重入的（nonreentrant），这就要求中断处理函数应该尽快完成。</p><p>那么一些比较繁重的任务（比如数据包的协议栈处理）如何完成呢？答案是下半部分。</p><p>中断被划分为上半部和下半部，上半部在中断上下文中快速执行，下半部则是以异步的方式完成特定的工作。Linux 提供的下半部解决方案有：</p><ol><li>软中断</li><li>tasklet</li><li>workqueue</li><li>kthread</li></ol><p>前两者不依赖进程环境，可用于执行“不可休眠的任务”；后两个依赖于进程环境，执行期间可以休眠。</p><h3 id="1-5-softirq-internal"><a href="#1-5-softirq-internal" class="headerlink" title="1.5 softirq internal"></a>1.5 softirq internal</h3><h4 id="1-5-1-什么是软中断"><a href="#1-5-1-什么是软中断" class="headerlink" title="1.5.1 什么是软中断"></a>1.5.1 什么是软中断</h4><p>其实软中断这个名称有一点误导性，因为它和中断其实没有太大联系。只是采用了向量（数组）的方式来存放针对不同下标的处理函数，与硬件的处理比较类似，因而得名。</p><p>通过源码也能发现，结构非常简单，通过大小为 NR_SOFTIRQS(系统共计软中断数量)的数组来存放处理函数，注册软中断只需要设置对应项的 <code>softirq_action.action</code> 即可</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softirq_action</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">void</span>(*action)(struct softirq_action *);<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softirq_action</span> <span class="hljs-title">softirq_vec</span>[<span class="hljs-title">NR_SOFTIRQS</span>];</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">open_softirq</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nr, <span class="hljs-keyword">void</span> (*action)(struct softirq_action *))</span></span><br><span class="hljs-function"></span>&#123;<br>softirq_vec[nr].action = action;<br>&#125;<br></code></pre></td></tr></table></figure><p>网络子系统的初始化函数 <code>net_dev_init</code> 中注册了两个软中断处理函数 <code>net_tx_action</code> <code>net_rx_action</code>，一个对应发包（tx），一个对应收包（rx）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init <span class="hljs-title">net_dev_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//...</span><br>    open_softirq(NET_TX_SOFTIRQ, net_tx_action);<br>    open_softirq(NET_RX_SOFTIRQ, net_rx_action);<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-5-2-软中断做了什么"><a href="#1-5-2-软中断做了什么" class="headerlink" title="1.5.2 软中断做了什么"></a>1.5.2 软中断做了什么</h4><p>软中断由 <code>ksoftirqd</code> 这个内核线程来处理，对应的入口函数为 <code>run_ksoftirqd</code>，系统初始化的时候，会在每一个核心上都启动一个该线程(kernel-softirqd) </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">smp_hotplug_thread</span> <span class="hljs-title">softirq_threads</span> =</span> &#123;<br>.store= &amp;ksoftirqd,<br>.thread_should_run= ksoftirqd_should_run,<br>.thread_fn= run_ksoftirqd,<br>.thread_comm= <span class="hljs-string">&quot;ksoftirqd/%u&quot;</span>,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> __init <span class="hljs-keyword">int</span> <span class="hljs-title">spawn_ksoftirqd</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>cpuhp_setup_state_nocalls(CPUHP_SOFTIRQ_DEAD, <span class="hljs-string">&quot;softirq:dead&quot;</span>, <span class="hljs-literal">NULL</span>,<br>  takeover_tasklets);<br>BUG_ON(smpboot_register_percpu_thread(&amp;softirq_threads));<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>early_initcall(spawn_ksoftirqd);<br></code></pre></td></tr></table></figure><p>入口函数 <code>run_ksoftirqd</code> 实际上只是对于 <code>__do_softirq</code> 的一层封装，简化之后对应下面的逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">asmlinkage __visible <span class="hljs-keyword">void</span> __softirq_entry __do_softirq(<span class="hljs-keyword">void</span>)<br>&#123;<br><span class="hljs-comment">// ...</span><br><br>pending = local_softirq_pending();<br><br>restart:<br><span class="hljs-comment">/* Reset the pending bitmask before enabling irqs */</span><br>set_softirq_pending(<span class="hljs-number">0</span>);<br><br>local_irq_enable();<br><br>h = softirq_vec;<br><br><span class="hljs-keyword">while</span> ((softirq_bit = ffs(pending))) &#123;<br><br>h += softirq_bit - <span class="hljs-number">1</span>;<br>h-&gt;action(h);<br>h++;<br>pending &gt;&gt;= softirq_bit;<br>&#125;<br><br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>软中断通过 pending(u16) 来表示待处理的信号，借助 pending 的每一个 bit 来开启或关闭软中断，通过 <code>ffs(pending)</code> 可以获取等待处理的软中断信号。因此，在 while 循环中，就可以通过 bit 下标，获取到相应中断处理函数之后直接回调。对于接收数据包而言，就来到了 <code>net_rx_action</code> 函数中。</p><h2 id="2-非-NAPI-VS-NAPI"><a href="#2-非-NAPI-VS-NAPI" class="headerlink" title="2. 非 NAPI VS NAPI"></a>2. 非 NAPI VS NAPI</h2><p>NAPI 虽然有很多优势，但对于硬件有一定的要求：</p><ol><li>设备需要有足够的缓冲区，从而保存多个数据包</li><li>需要可以禁用中断，而不影响其它的操作</li></ol><p>因此，仍然有一些旧设备不支持 NAPI，但是 NAPI 框架使用了一些 trick，很好地兼容了旧逻辑，因此这里不妨先介绍一下 NAPI 工作模式。</p><h3 id="2-1-NAPI-工作方式"><a href="#2-1-NAPI-工作方式" class="headerlink" title="2.1 NAPI 工作方式"></a>2.1 NAPI 工作方式</h3><p>NAPI 作用于驱动上，流程如下：</p><ol><li>网卡收到数据包，关闭其对应的中断，并且将该网络设备添加到 poll_list 中</li><li>在软中断循环中，检测到需要进行 net_rx_action，并针对 poll_list 的每一个网卡，都进行 poll</li><li>每一个网络设备轮询时的限额或者时间用完了之后，重启启用网卡硬件中断</li></ol><p>接下来详细说明</p><h4 id="2-1-1-数据结构"><a href="#2-1-1-数据结构" class="headerlink" title="2.1.1 数据结构"></a>2.1.1 数据结构</h4><p>网络数据接收的过程中，一个非常重要的数据结构是 per-cpu 变量 <code>softnet_data</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// net/dev/core.c</span><br>DEFINE_PER_CPU_ALIGNED(struct softnet_data, softnet_data); <span class="hljs-comment">// per cpu</span><br>EXPORT_PER_CPU_SYMBOL(softnet_data);<br><br><span class="hljs-comment">// include/linux/netdevice.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softnet_data</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">poll_list</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff_head</span><span class="hljs-title">process_queue</span>;</span><br><br><span class="hljs-comment">/* stats */</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>processed;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>time_squeeze;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>received_rps;<br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>dropped;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff_head</span><span class="hljs-title">input_pkt_queue</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">napi_struct</span><span class="hljs-title">backlog</span>;</span><br><br><span class="hljs-comment">// other stuff, need to be configure in kbuild</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>关键字段含义：</p><ul><li>poll_list：需要轮询的设备列表，对应 napi_struct</li><li>process_queue/input_pkt_queue：用于 Non-NAPI 设备，通过 backlog 队列进行处理</li><li>processed/time_squeeze/received_rps：统计信息</li></ul><p>其中 Non-NAPI 设备的字段留在后面详解，这里主要关注 poll_list 这个通用字段。</p><p>poll_list 可以说是连接硬件中断和软中断的<strong>桥梁</strong>，它是一个链表，每当有一个网络设备需要轮询时，就添加到 <code>softnet_data.poll_list</code> 中，从而在 net_rx_action 当中异步轮询。</p><p>poll_list 保存的是 napi_struct 结构，第一眼就知道它绝对是 NAPI 的 C位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">napi_struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">poll_list</span>;</span><br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>       state;<br>    <span class="hljs-keyword">int</span>         weight;<br>    <span class="hljs-keyword">int</span>         (*poll)(struct napi_struct *, <span class="hljs-keyword">int</span>);<br>    <span class="hljs-comment">// GRO, netpoll，timer</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span>   *<span class="hljs-title">dev</span>;</span> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span>      *<span class="hljs-title">skb</span>;</span> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">dev_list</span>;</span>  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span>   <span class="hljs-title">napi_hash_node</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>        napi_id;   <br>&#125;;<br></code></pre></td></tr></table></figure><p>重要字段含义：</p><ul><li>weight：轮询的限额</li><li>poll：轮询回调函数</li></ul><p>两个概念要提一下：预算（budget）和权重（weight）。预算代表了所有要轮询的设备在一次软件中断中总共能够处理的帧的输入；限制预算的原因是防止软中断占用CPU时间过长，从而影响其他进程和软中断（硬件中断不受影响）。现在除了总预算外，为了公平起见，对每个设备也需要分配一定的权重（weight），限制每个设备最大的帧读取量，weidght 越大说明该设备性能越高。</p><p>poll 函数是 NAPI 的核心，当设备与驱动匹配的时候，会调用驱动的 probe 函数，此时就可以通过 <code>netif_napi_add</code> 注册相应的 NAPI 设备，这样该网络设备接收到数据包并产生中断以后，就可以获取到对应的 napi_struct 并间接传递给 net_rx_action。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">netif_napi_add</span><span class="hljs-params">(struct net_device *dev, struct napi_struct *napi,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">int</span> (*poll)(struct napi_struct *, <span class="hljs-keyword">int</span>), <span class="hljs-keyword">int</span> weight)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (WARN_ON(test_and_set_bit(NAPI_STATE_LISTED, &amp;napi-&gt;state)))<br><span class="hljs-keyword">return</span>;<br><br>INIT_LIST_HEAD(&amp;napi-&gt;poll_list);<br>INIT_HLIST_NODE(&amp;napi-&gt;napi_hash_node);<br>hrtimer_init(&amp;napi-&gt;timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_PINNED);<br>napi-&gt;timer.function = napi_watchdog;<br>init_gro_hash(napi);<br>napi-&gt;skb = <span class="hljs-literal">NULL</span>;<br>INIT_LIST_HEAD(&amp;napi-&gt;rx_list);<br>napi-&gt;rx_count = <span class="hljs-number">0</span>;<br>napi-&gt;poll = poll; <span class="hljs-comment">// IMPORTANT!</span><br><br><span class="hljs-comment">// ... </span><br>set_bit(NAPI_STATE_SCHED, &amp;napi-&gt;state);<br>set_bit(NAPI_STATE_NPSVC, &amp;napi-&gt;state);<br>list_add_rcu(&amp;napi-&gt;dev_list, &amp;dev-&gt;napi_list);<br>napi_hash_add(napi);<br>&#125;<br>EXPORT_SYMBOL(netif_napi_add);<br></code></pre></td></tr></table></figure><h4 id="2-1-2-从硬件中断到软中断"><a href="#2-1-2-从硬件中断到软中断" class="headerlink" title="2.1.2 从硬件中断到软中断"></a>2.1.2 从硬件中断到软中断</h4><p>前面提到，硬件中断只需要做好一件事就好了：将网络设备的 napi_struct 添加到 <code>softnet_data.poll_list</code> 中，之后就交给软中断处理了。</p><p>收包的软中断处理函数为 <code>net_rx_action</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> __latent_entropy <span class="hljs-keyword">void</span> <span class="hljs-title">net_rx_action</span><span class="hljs-params">(struct softirq_action *h)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softnet_data</span> *<span class="hljs-title">sd</span> =</span> this_cpu_ptr(&amp;softnet_data);<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> time_limit = jiffies +<br>usecs_to_jiffies(netdev_budget_usecs);<br><span class="hljs-keyword">int</span> budget = netdev_budget; <span class="hljs-comment">// budget = 300</span><br>LIST_HEAD(<span class="hljs-built_in">list</span>);    <span class="hljs-comment">// 待轮询的所有设备</span><br>LIST_HEAD(repoll);  <span class="hljs-comment">// 因自身权重用完而需要下一次轮询的设备</span><br><br>local_irq_disable();<br>list_splice_init(&amp;sd-&gt;poll_list, &amp;<span class="hljs-built_in">list</span>);<br>local_irq_enable();<br><br>    <span class="hljs-comment">// 遍历每个设备的napi，直到所有设备都处理完，或者预算用完</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">napi_struct</span> *<span class="hljs-title">n</span>;</span><br><br><span class="hljs-keyword">if</span> (list_empty(&amp;<span class="hljs-built_in">list</span>)) &#123;<br><span class="hljs-keyword">if</span> (!sd_has_rps_ipi_waiting(sd) &amp;&amp; list_empty(&amp;repoll))<br><span class="hljs-keyword">goto</span> out;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// 取出链表中第一个待处理的设备</span><br>n = list_first_entry(&amp;<span class="hljs-built_in">list</span>, struct napi_struct, poll_list);<br>budget -= napi_poll(n, &amp;repoll);<br><br><span class="hljs-comment">// 预算（时间 or 次数）用完了</span><br><span class="hljs-keyword">if</span> (unlikely(budget &lt;= <span class="hljs-number">0</span> ||<br>     time_after_eq(jiffies, time_limit))) &#123;<br>sd-&gt;time_squeeze++;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br>local_irq_disable();<br><br>    <span class="hljs-comment">// 以下设备要重新被放入sd-&gt;poll_list</span><br>    <span class="hljs-comment">// 1. 因为预算用完，list 中尚未处理的设备，</span><br>    <span class="hljs-comment">// 2. 因设备本身权重用完而被放入 repoll 的设备</span><br>list_splice_tail_init(&amp;sd-&gt;poll_list, &amp;<span class="hljs-built_in">list</span>);<br>list_splice_tail(&amp;repoll, &amp;<span class="hljs-built_in">list</span>);<br>list_splice(&amp;<span class="hljs-built_in">list</span>, &amp;sd-&gt;poll_list);<br><br><span class="hljs-comment">// 不论是总预算还是设备 weight 的关系，本次执行未能完成所有设备及其所有数据的接收，重新调度 NET_RX_SOFTIRQ（设置 pending 标志位）</span><br><span class="hljs-keyword">if</span> (!list_empty(&amp;sd-&gt;poll_list))<br>__raise_softirq_irqoff(NET_RX_SOFTIRQ);<br><br>net_rps_action_and_irq_enable(sd);<br>out:<br>__kfree_skb_flush();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">napi_poll</span><span class="hljs-params">(struct napi_struct *n, struct list_head *repoll)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">void</span> *have;<br><span class="hljs-keyword">int</span> work, weight;<br><br>list_del_init(&amp;n-&gt;poll_list);<br><br>have = netpoll_poll_lock(n);<br><br>weight = n-&gt;weight;<br><br><span class="hljs-comment">// 调用 napi_struct 的 poll 函数</span><br>work = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (test_bit(NAPI_STATE_SCHED, &amp;n-&gt;state)) &#123;<br>work = n-&gt;poll(n, weight);<br>trace_napi_poll(n, work, weight);<br>&#125;<br><br><span class="hljs-keyword">if</span> (unlikely(work &gt; weight))<br>pr_err_once(<span class="hljs-string">&quot;NAPI poll function %pS returned %d, exceeding its budget of %d.\n&quot;</span>,<br>    n-&gt;poll, work, weight);<br><br><span class="hljs-keyword">if</span> (likely(work &lt; weight))<br><span class="hljs-keyword">goto</span> out_unlock;<br><br><span class="hljs-comment">/* Drivers must not modify the NAPI state if they</span><br><span class="hljs-comment"> * consume the entire weight.  In such cases this code</span><br><span class="hljs-comment"> * still &quot;owns&quot; the NAPI instance and therefore can</span><br><span class="hljs-comment"> * move the instance around on the list at-will.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(napi_disable_pending(n))) &#123;<br>napi_complete(n);<br><span class="hljs-keyword">goto</span> out_unlock;<br>&#125;<br><br><span class="hljs-keyword">if</span> (n-&gt;gro_bitmask) &#123;<br><span class="hljs-comment">/* flush too old packets</span><br><span class="hljs-comment"> * If HZ &lt; 1000, flush all packets.</span><br><span class="hljs-comment"> */</span><br>napi_gro_flush(n, HZ &gt;= <span class="hljs-number">1000</span>);<br>&#125;<br><br>gro_normal_list(n);<br><br><span class="hljs-comment">/* Some drivers may have called napi_schedule</span><br><span class="hljs-comment"> * prior to exhausting their budget.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(!list_empty(&amp;n-&gt;poll_list))) &#123;<br>pr_warn_once(<span class="hljs-string">&quot;%s: Budget exhausted after napi rescheduled\n&quot;</span>,<br>     n-&gt;dev ? n-&gt;dev-&gt;name : <span class="hljs-string">&quot;backlog&quot;</span>);<br><span class="hljs-keyword">goto</span> out_unlock;<br>&#125;<br><br>list_add_tail(&amp;n-&gt;poll_list, repoll);<br><br>out_unlock:<br>netpoll_poll_unlock(have);<br><br><span class="hljs-keyword">return</span> work;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-非-NAPI-工作方式"><a href="#2-1-非-NAPI-工作方式" class="headerlink" title="2.1 非 NAPI 工作方式"></a>2.1 非 NAPI 工作方式</h3><p>了解了 NAPI 这种中断和轮询相结合的收包方式之后？再来回顾一下经典的 backlog 队列模式，就能领会到 Linux 向下兼容的艺术。</p><p>对于不支持 NAPI 工作方式的网卡，在网卡的中断处理函数中会直接调用 netif_rx，其在中断上下文中执行，执行期间会关闭 CPU 的中断，工作完成再重新打开。<br>netif_rx 函数的工作最终主要由 enqueue_to_backlog 完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">hw interrupt handler<br>    --&gt; netif_rx<br>        --&gt; netif_rx_internal<br>            --&gt; enqueue_to_backlog<br>--&gt; ____napi_schedule<br>--&gt; raise net_rx_action (async)<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">enqueue_to_backlog</span><span class="hljs-params">(struct sk_buff *skb, <span class="hljs-keyword">int</span> cpu,</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *qtail)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">softnet_data</span> *<span class="hljs-title">sd</span>;</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> qlen;<br><br>sd = &amp;per_cpu(softnet_data, cpu);<br><br>local_irq_save(flags);<br><br>rps_lock(sd);<br><span class="hljs-keyword">if</span> (!netif_running(skb-&gt;dev))<br><span class="hljs-keyword">goto</span> drop;<br>qlen = skb_queue_len(&amp;sd-&gt;input_pkt_queue);<br><span class="hljs-keyword">if</span> (qlen &lt;= netdev_max_backlog &amp;&amp; !skb_flow_limit(skb, qlen)) &#123;<br><span class="hljs-keyword">if</span> (qlen) &#123;<br>enqueue:<br>__skb_queue_tail(&amp;sd-&gt;input_pkt_queue, skb);<br>input_queue_tail_incr_save(sd, qtail);<br>rps_unlock(sd);<br>local_irq_restore(flags);<br><span class="hljs-keyword">return</span> NET_RX_SUCCESS;<br>&#125;<br><br><span class="hljs-comment">/* Schedule NAPI for backlog device</span><br><span class="hljs-comment"> * We can use non atomic operation since we own the queue lock</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!__test_and_set_bit(NAPI_STATE_SCHED, &amp;sd-&gt;backlog.state)) &#123;<br><span class="hljs-keyword">if</span> (!rps_ipi_queued(sd))<br>____napi_schedule(sd, &amp;sd-&gt;backlog);<br>&#125;<br><span class="hljs-keyword">goto</span> enqueue;<br>&#125;<br><br>drop:<br><span class="hljs-comment">// handle exceptions</span><br>&#125;<br></code></pre></td></tr></table></figure><p>来看看 softnet_data 结构中与 non-napi 设备相关的字段，</p><ul><li><p>sd.input_pkt_queue<br>该队列仅用于 non-napi 设备。non-napi 设备会在驱动程序中（往往是中断处理函数）分配 skb，从寄存器读取数据到 skb，然后调用 netif_rx 把 skb 放到 sd-&gt;input_pkt_queue 中。注意，所有 non-napi 设备共享输入队列，即 per-cpu 的sd-&gt;input_pkt_queue。</p></li><li><p>sd.process_queue<br>刚才已经提到，non-napi 设备把 skb 放入 sd.input_pkt_queue，然后在下半部处理中使用 sd.backlog.poll 即proces_backlog 函数来处理 skb。改函数模拟了 NAPI 驱动的 poll 函数行为。作为对比，NAPI 设备的 poll 从设备私有队列读取。Non-NAPI 的 process_backlog 函数则从 non-napi 设备共享的输入队列 input_pkt_queue 中读取配额的数据。然后放入 sd.process_queue。</p></li><li><p>sd.backlog<br>用于 non-napi 设备，为了和 NAPI 接收架构兼容，所有的 non-napi 设备使用一个虚拟的 napi_struct，即这里的 sd.backlog。NAPI 设备把自己的 napi_struct 放入sd-&gt;poll_list，而所有的 non-napi 设备在 netif_rx 的时候把sd-&gt;backlog 放入 sd-&gt;poll_list。在中断下半部处理函数中，会通过 napi_poll 调用 backlog.poll 进行处理。<br>通过这种<strong>共享的虚拟 napi_struct</strong>方式，使得 non-napi 设备很好的融入了 NAPI 框架，使得 non-napi 和 NAPI 设备对下半部（net_rx_action）是透明的。不得不说，这是一个值得学习的精巧设计，让我们知道如何向前兼容旧的机制，如何让下层的变化对上层透明。</p></li></ul><h2 id="3-NAPI-示例"><a href="#3-NAPI-示例" class="headerlink" title="3. NAPI 示例"></a>3. NAPI 示例</h2>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>network</category>
      
      <category>napi</category>
      
      <category>nic</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>xdp</title>
    <link href="/2022/02/23/linux/network/xdp/"/>
    <url>/2022/02/23/linux/network/xdp/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-xdp"><a href="#什么是-xdp" class="headerlink" title="什么是 xdp"></a>什么是 xdp</h2>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>network</category>
      
      <category>xdp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>traffic control</title>
    <link href="/2022/02/22/linux/network/traffic%20control/"/>
    <url>/2022/02/22/linux/network/traffic%20control/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>network</category>
      
      <category>tc</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>neighbouring subsystem</title>
    <link href="/2022/02/22/linux/network/neigh%20system/"/>
    <url>/2022/02/22/linux/network/neigh%20system/</url>
    
    <content type="html"><![CDATA[<h2 id="1-what’s-neighbouring-subsystem"><a href="#1-what’s-neighbouring-subsystem" class="headerlink" title="1. what’s neighbouring subsystem"></a>1. what’s neighbouring subsystem</h2><p>邻居子系统是网络协议栈必不可少的一环，主要负责将 L3（network layer）地址转换为 L2（link layer）地址。</p><p>为了实现这个功能，Linux 实现了 Arp 协议（ipv4）以及 Neighbour Discovery Protocol（ipv6）。本章只会讨论 Arp 协议相关的内容。首选会介绍一下几个重要的数据结构，然后再根据协议栈汇总收发包的路径进行串讲。</p><h2 id="2-neighbouring-subsystem-internal"><a href="#2-neighbouring-subsystem-internal" class="headerlink" title="2. neighbouring subsystem internal"></a>2. neighbouring subsystem internal</h2><h3 id="2-1-more-details"><a href="#2-1-more-details" class="headerlink" title="2.1 more details"></a>2.1 more details</h3><p>当数据包经过 L2 时，需要 L2 目标地址，从而填充 L2 header，通过 neighbouring subsystem，可以通过 L3 地址来进行查询对应的 L2 地址，如果查不到，还可以发送 solicitation 数据包，通过 Arp 协议请求别的设备完成地址解析并相应该请求。</p><p>我们绝大部分使用的都是 Ethernet，因此 L2 的目标/源地址都是 MAC 地址。</p><h3 id="2-2-data-structure"><a href="#2-2-data-structure" class="headerlink" title="2.2 data structure"></a>2.2 data structure</h3><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">neighbour</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">neighbour</span> __<span class="hljs-title">rcu</span>    *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">neigh_table</span>    *<span class="hljs-title">tbl</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">neigh_parms</span>    *<span class="hljs-title">parms</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>        confirmed;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>        updated;<br>    <span class="hljs-keyword">rwlock_t</span>        lock;<br>    <span class="hljs-keyword">refcount_t</span>        refcnt;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>        arp_queue_len_bytes;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff_head</span>    <span class="hljs-title">arp_queue</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span>    <span class="hljs-title">timer</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>        used;<br>    <span class="hljs-keyword">atomic_t</span>        probes;<br>    __u8            flags;<br>    __u8            nud_state;<br>    __u8            type;<br>    __u8            dead;<br>    u8            protocol;<br>    <span class="hljs-keyword">seqlock_t</span>        ha_lock;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>        ha[ALIGN(MAX_ADDR_LEN, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>))] __aligned(<span class="hljs-number">8</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hh_cache</span>        <span class="hljs-title">hh</span>;</span><br>    <span class="hljs-keyword">int</span>            (*output)(struct neighbour *, struct sk_buff *);<br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">neigh_ops</span>    *<span class="hljs-title">ops</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">gc_list</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span>        <span class="hljs-title">rcu</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span>    *<span class="hljs-title">dev</span>;</span><br>    u8            primary_key[<span class="hljs-number">0</span>];<br>&#125; __randomize_layout;<br><br>关键字段的含义：<br><br><span class="hljs-number">1.</span> next：neighbour 在哈希表中的下一个节点<br><span class="hljs-number">2.</span> tbl：neighbour 所在的 neigh_table<br><span class="hljs-number">3.</span> confirmed：neighbour 的验证时间（arp 协议）<br><span class="hljs-number">4.</span> timer：对应 neigh_timer_handler 回调函数，会定时判定该 neighbour 的 Neighbour Unreachability Detection State（NUD）<br><span class="hljs-number">5.</span> ha：neighbour 的硬件地址<br><span class="hljs-number">6.</span> hh：L2 头部信息缓存<br><span class="hljs-number">7.</span> nud_state：Neighbour Unreachability Detection State（NUD），会随着时间动态更新<br><span class="hljs-number">8.</span> dead：neighbour 是否已经失效<br><span class="hljs-number">9.</span> primary_key：neighbour 的 L3 地址，用于在 neigh_table 中进行哈希查找<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">neigh_table</span> &#123;</span><br>    <span class="hljs-keyword">int</span>            family;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>        entry_size;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>        key_len;<br>    __be16            protocol;<br>    __u32            (*hash)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *pkey,<br>                    <span class="hljs-keyword">const</span> struct net_device *dev,<br>                    __u32 *hash_rnd);<br>    <span class="hljs-keyword">bool</span>            (*key_eq)(<span class="hljs-keyword">const</span> struct neighbour *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *pkey);<br>    <span class="hljs-keyword">int</span>            (*constructor)(struct neighbour *);<br>    <span class="hljs-keyword">int</span>            (*pconstructor)(struct pneigh_entry *);<br>    <span class="hljs-keyword">void</span>            (*pdestructor)(struct pneigh_entry *);<br>    <span class="hljs-keyword">void</span>            (*proxy_redo)(struct sk_buff *skb);<br>    <span class="hljs-keyword">int</span>            (*is_multicast)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *pkey);<br>    <span class="hljs-keyword">bool</span>            (*allow_add)(<span class="hljs-keyword">const</span> struct net_device *dev,<br>                         struct netlink_ext_ack *extack);<br>    <span class="hljs-keyword">char</span>            *id;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">neigh_parms</span>    <span class="hljs-title">parms</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">parms_list</span>;</span><br>    <span class="hljs-keyword">int</span>            gc_interval;<br>    <span class="hljs-keyword">int</span>            gc_thresh1;<br>    <span class="hljs-keyword">int</span>            gc_thresh2;<br>    <span class="hljs-keyword">int</span>            gc_thresh3;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>        last_flush;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">delayed_work</span>    <span class="hljs-title">gc_work</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span>     <span class="hljs-title">proxy_timer</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff_head</span>    <span class="hljs-title">proxy_queue</span>;</span><br>    <span class="hljs-keyword">atomic_t</span>        entries;<br>    <span class="hljs-keyword">atomic_t</span>        gc_entries;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">gc_list</span>;</span><br>    <span class="hljs-keyword">rwlock_t</span>        lock;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>        last_rand;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">neigh_statistics</span>    __<span class="hljs-title">percpu</span> *<span class="hljs-title">stats</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">neigh_hash_table</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">nht</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pneigh_entry</span>    **<span class="hljs-title">phash_buckets</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>关键字段含义：</p><ol><li>next：每一个 L2 协议都会创建自己的 neigh_table，因此需要通过链表来进行管理</li><li>family：protocol 协议簇，AF_INET 表示 ipv4，AF_INET6 表示 ipv6</li><li>entry_size，key_len，hash：哈希表有关的配置</li><li>constructor，pconstructor，pdestructor：neighbour 的初始化以及析构函数</li><li>id：neigh_table 的名称</li><li>params：neigh_table 的配置，包含了很多属性</li><li>phash_buckets：哈希表（哈希桶 + 链表）</li></ol><p>neighbour 作为哈希表的 value 存在于 neigh_table 当中，而哈希表的 key 就是 L3 地址。因此通过 skb ip头中的目标地址，可以快速找到对应的 neighbour。</p><h3 id="2-3-从-Layer3-到-Layer2"><a href="#2-3-从-Layer3-到-Layer2" class="headerlink" title="2.3 从 Layer3 到 Layer2"></a>2.3 从 Layer3 到 Layer2</h3><p>发送数据包时，要通过下面的函数调用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">ip_local_out<br>    --&gt; ip_output<br>        --&gt; ip_finish_output<br>            --&gt; ip_finish_output2<br>                --&gt; neigh_output<br>                    --&gt; dev_queue_xmit<br></code></pre></td></tr></table></figure><p>其中，从 L3 到 L2 的转换对应 <code>ip_finish_output2</code> 中 <code>neigh_output</code> 的调用。下面来看具体实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ip_finish_output2</span><span class="hljs-params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dst_entry</span> *<span class="hljs-title">dst</span> =</span> skb_dst(skb);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtable</span> *<span class="hljs-title">rt</span> =</span> (struct rtable *)dst;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span> *<span class="hljs-title">dev</span> =</span> dst-&gt;dev;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> hh_len = LL_RESERVED_SPACE(dev);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">neighbour</span> *<span class="hljs-title">neigh</span>;</span><br>    <span class="hljs-keyword">bool</span> is_v6gw = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// ...</span><br><br>    rcu_read_lock_bh();<br><br>    <span class="hljs-comment">// 1. 查询 neigh</span><br>    neigh = ip_neigh_for_gw(rt, skb, &amp;is_v6gw);<br>    <span class="hljs-keyword">if</span> (!IS_ERR(neigh)) &#123;<br>        <span class="hljs-keyword">int</span> res;<br><br>        sock_confirm_neigh(skb, neigh);<br><br>        <span class="hljs-comment">// 2. 进入 Layer2</span><br>        res = neigh_output(neigh, skb, is_v6gw);<br>        rcu_read_unlock_bh();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    rcu_read_unlock_bh();<br><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>ip_finish_output2</code> 中首先通过 <code>ip_neigh_for_gw</code> 获取了 neigh，然后调用 <code>neigh_output</code> 进入 Layer2 并完成后续的操作。前者其实非常简单，最后调用了下面的函数进行查询</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>\*<br>ip_neigh_for_gw<br>    --&gt; ip_neigh_gw4<br>        --&gt; __ipv4_neigh_lookup_noref<br>            --&gt; ___neigh_lookup_noref<br>*\<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">neighbour</span> *___<span class="hljs-title">neigh_lookup_noref</span>(</span><br><span class="hljs-class">    <span class="hljs-keyword">struct</span> <span class="hljs-title">neigh_table</span> *<span class="hljs-title">tbl</span>,</span><br><span class="hljs-class">    <span class="hljs-title">bool</span> (*<span class="hljs-title">key_eq</span>)(<span class="hljs-title">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title">neighbour</span> *<span class="hljs-title">n</span>, <span class="hljs-title">const</span> <span class="hljs-title">void</span> *<span class="hljs-title">pkey</span>),</span><br><span class="hljs-class">    __<span class="hljs-title">u32</span> (*<span class="hljs-title">hash</span>)(<span class="hljs-title">const</span> <span class="hljs-title">void</span> *<span class="hljs-title">pkey</span>,</span><br><span class="hljs-class">              <span class="hljs-title">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span> *<span class="hljs-title">dev</span>,</span><br><span class="hljs-class">              __<span class="hljs-title">u32</span> *<span class="hljs-title">hash_rnd</span>),</span><br><span class="hljs-class">    <span class="hljs-title">const</span> <span class="hljs-title">void</span> *<span class="hljs-title">pkey</span>,</span><br><span class="hljs-class">    <span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span> *<span class="hljs-title">dev</span>)</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">neigh_hash_table</span> *<span class="hljs-title">nht</span> =</span> rcu_dereference_bh(tbl-&gt;nht);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">neighbour</span> *<span class="hljs-title">n</span>;</span><br>    u32 hash_val;<br><br>    hash_val = hash(pkey, dev, nht-&gt;hash_rnd) &gt;&gt; (<span class="hljs-number">32</span> - nht-&gt;hash_shift);<br>    <span class="hljs-keyword">for</span> (n = rcu_dereference_bh(nht-&gt;hash_buckets[hash_val]);<br>         n != <span class="hljs-literal">NULL</span>;<br>         n = rcu_dereference_bh(n-&gt;next)) &#123;<br>        <span class="hljs-keyword">if</span> (n-&gt;dev == dev &amp;&amp; key_eq(n, pkey))<br>            <span class="hljs-keyword">return</span> n;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>___neigh_lookup_noref</code> 函数完成了一个简单的 hash_bucket 查询：计算出 hash_val，取出 hash_val 对应的链表，遍历链表，并按照 key_eq 函数判定哈希值是否相等。</p><p>有了 neigh 之后，就可以根据这个邻居开始真正的邻居子系统之旅，接下来的 <code>neigh_output</code> 函数中有两条路径，分别为 <code>neigh_hh_output</code> 和 <code>neighbour-&gt;output</code>，跟踪源码，前者最终会调用 <code>dev_start_xmit</code> 进入驱动层发送数据包，而后者在这里对应 <code>neigh_resolve_output</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">neigh_output</span><span class="hljs-params">(struct neighbour *n, struct sk_buff *skb,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">bool</span> skip_cache)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hh_cache</span> *<span class="hljs-title">hh</span> =</span> &amp;n-&gt;hh;<br><br>    <span class="hljs-keyword">if</span> ((n-&gt;nud_state &amp; NUD_CONNECTED) &amp;&amp; hh-&gt;hh_len &amp;&amp; !skip_cache)<br>        <span class="hljs-keyword">return</span> neigh_hh_output(hh, skb);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> n-&gt;output(n, skb);<br>&#125;<br></code></pre></td></tr></table></figure><p>关键点在于，何时直接发送数据包？何时调用 output 回调函数？这主要是由 <code>n-&gt;nud_state</code> 决定的。nud_state 从何而来，那就不得不提 Arp 协议的实现了</p><h3 id="2-4-Arp-协议"><a href="#2-4-Arp-协议" class="headerlink" title="2.4 Arp 协议"></a>2.4 Arp 协议</h3><p>前面说到，<code>neigh_output</code> 需要根据 nud_state 选择一个合适的分支，这一步很关键，只有当状态为 <code>NUD_CONNECTED</code> 时才会通过该邻居发送数据包。</p><p>nud_state 全称为 <strong>Neighbour Unreachability Detection State</strong>，也就是 Arp 协议解析的状态，其中，<code>NUD_CONNECTED</code> 表示已经建立连接，<code>NUD_STALE</code> 表示已经过期，<code>NUD_DELAY</code> 表示延迟到期，<code>NUD_PROBE</code> 表示正在探测，<code>NUD_FAILED</code> 表示失败。只有当 neighbour 处于 <code>NUD_CONNECTED</code> 状态时，表示该邻居是可达的，才能继续发送数据包，否则需要通过 Arp 协议更新状态，直到状态转换为 <code>NUD_CONNECTED</code> 才能重新发送。</p><p>ARP 协议中用到的状态完整定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUD_INCOMPLETE    0x01</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUD_REACHABLE    0x02</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUD_STALE    0x04</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUD_DELAY    0x08</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUD_PROBE    0x10</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUD_FAILED    0x20</span><br><br><span class="hljs-comment">/* Dummy states */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUD_NOARP    0x40</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUD_PERMANENT    0x80</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUD_NONE    0x00</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUD_IN_TIMER    (NUD_INCOMPLETE|NUD_REACHABLE|NUD_DELAY|NUD_PROBE)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUD_VALID    (NUD_PERMANENT|NUD_NOARP|NUD_REACHABLE|NUD_PROBE|NUD_STALE|NUD_DELAY)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUD_CONNECTED    (NUD_PERMANENT|NUD_NOARP|NUD_REACHABLE)</span><br></code></pre></td></tr></table></figure><p>ARP 协议最复杂的地方也在于此，需要一个完备的状态机，才不至于迷失在各种状态的转化中。</p><p><img src="/images/arp-state-machine.png" alt="arp state machine"></p><ol><li>如何转换为 <code>NUD_REACHABLE</code> 状态？<br><code>NUD_REACHABLE</code> 约等于 <code>NUD_CONNECTED</code>，如果该状态的 neighbour 是可以发送数据包的，同时，其状态也会缓存下来<br>有两个方式可以转换到该状态：1) 发送 solicit 数据包，并在规定时间内收到了肯定应答；2) 收到了上层协议的确认包</li><li>如何转换为 <code>NUD_INCOMPLETE</code> 状态？<br><code>NUD_INCOMPLETE</code> 表示已经发送了 solicit 数据包，但是还没有收到应答，此时无有效的 Layer2 Address<br><code>NUD_INCOMPLETE</code> 只能从初始的 <code>NUD_NONE</code> 而来，最终也只能转换为 <code>NUD_FAILED</code> 状态</li><li><code>NUD_STALE</code> <code>NUD_DELAY</code> <code>NUD_PROBE</code> 状态表示什么？<br><code>NUD_STALE</code> 表示虽然已经缓存 neighbour 信息，但是已经过期，当 neighbour 位于这个状态时，会在下一次发送数据包时触发 reachability 的检测，并且转换为 <code>NUD_DELAY</code> 状态<br><code>NUD_DELAY</code> 表示一个可以等待 reachability 确认的时间窗口，当完成了 solicit 确认之后，也会转换为 <code>NUD_INCOMPLETE</code> 状态<br>位于 <code>NUD_DELAY</code>  超出容忍的最长时间之后，会进入到 <code>NUD_PROBE</code> 状态，此时，会像 <code>NUD_INCOMPLETE</code> 一样循环发送 solicit 数据包，等待应答或者直到发送次数用完，表明本次 Arp 请求失败</li></ol><h3 id="2-5-用户与-neighbouring-subsystem-交互"><a href="#2-5-用户与-neighbouring-subsystem-交互" class="headerlink" title="2.5 用户与 neighbouring subsystem 交互"></a>2.5 用户与 neighbouring subsystem 交互</h3><p>在讲解 netlink 的时候提到过，NETLINK_ROUTE 不仅包含了路由子系统，还包含了邻居子系统，因此，和 neighbour 相关的操作也是通过 rtnetlink 暴露出去的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init <span class="hljs-title">neigh_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    rtnl_register(PF_UNSPEC, RTM_NEWNEIGH, neigh_add, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    rtnl_register(PF_UNSPEC, RTM_DELNEIGH, neigh_delete, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    rtnl_register(PF_UNSPEC, RTM_GETNEIGH, neigh_get, neigh_dump_info, <span class="hljs-number">0</span>);<br><br>    rtnl_register(PF_UNSPEC, RTM_GETNEIGHTBL, <span class="hljs-literal">NULL</span>, neightbl_dump_info,<br>              <span class="hljs-number">0</span>);<br>    rtnl_register(PF_UNSPEC, RTM_SETNEIGHTBL, neightbl_set, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如 <code>ip neigh show</code> 这条指令，就对应了 <code>neigh_dump_info</code> 这个回调函数。</p><p>如果想进一步深入了解，可以在掌握了 netlink 的基础上，通过 strace/funcgraph 等工具来进行内核代码追踪，相信你能有更加深刻的理解。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>network</category>
      
      <category>neighbour</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>netlink</title>
    <link href="/2022/02/22/linux/network/netlink/"/>
    <url>/2022/02/22/linux/network/netlink/</url>
    
    <content type="html"><![CDATA[<h2 id="1-netlink-简介"><a href="#1-netlink-简介" class="headerlink" title="1. netlink 简介"></a>1. netlink 简介</h2><h3 id="1-1-netlink-是什么"><a href="#1-1-netlink-是什么" class="headerlink" title="1.1 netlink 是什么"></a>1.1 netlink 是什么</h3><p>netlink 是一种 进程间通信（inter process communication IPC） 机制，为用户空间和内核空间进程之间（当然也可以是两个内核进程之间）提供了一种双向异步的通信方式。</p><p>netlink 依托成熟的 socket api 提供服务，增加了 AF_NETLINK 这个协议簇，依靠 sock_ops 对应的各种回调函数（sendmsg，recvmsg）来实现 netlink 的功能。</p><h3 id="1-2-netlink-优点"><a href="#1-2-netlink-优点" class="headerlink" title="1.2 netlink 优点"></a>1.2 netlink 优点</h3><p>相比如其他的 IPC 方式，netlink 有下面几点优势：</p><ol><li>不需要通过 poll 操作来获取数据，像普通 socket 编程一样 recvmsg 即可，接口简单</li><li>全双工异步通信</li><li>netlink 支持广播和多播</li></ol><h3 id="1-3-netlink-示例"><a href="#1-3-netlink-示例" class="headerlink" title="1.3 netlink 示例"></a>1.3 netlink 示例</h3><p>前面说到，netlink 通过 socket 向用户提供操作接口，具体应该怎么用呢？下面是其工作示意图</p><p><img src="/images/netlink-api.png" alt="netlink api"></p><h2 id="2-netlink-internal"><a href="#2-netlink-internal" class="headerlink" title="2. netlink internal"></a>2. netlink internal</h2><h3 id="2-1-netlink-api"><a href="#2-1-netlink-api" class="headerlink" title="2.1 netlink api"></a>2.1 netlink api</h3><p>前面说到，可以用 socket api 来操控 netlink，我们就从 <code>socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE)</code> 的几个参数入手</p><ol><li>AF_NETLINK，指定该 socket 的协议簇为 NETLINK，这样能通过 <code>netlink_family_ops.create</code> 回调函数创建 socket 的内部结构</li></ol><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_proto_family</span> <span class="hljs-title">netlink_family_ops</span> =</span> &#123;<br>    .family = PF_NETLINK,<br>    .create = netlink_create,<br>    .owner    = THIS_MODULE,    <span class="hljs-comment">/* for consistency 8) */</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>SOCK_RAW，与主题无关，暂不讨论</li><li>NRETLINK_ROUTE，指定 NETLINK 的类型，因为 NETLINK 在内核中被各个模块使用，所以需要通过这个字段区分究竟是哪个模块，而 netlink socket 相当于一个多路复用器，通过在内核中保存的一个针对不同 protocol 的 netlink_table，查表就能获取到对应的回调函数。</li></ol> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">netlink_table</span> *<span class="hljs-title">nl_table</span> __<span class="hljs-title">read_mostly</span>;</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">netlink_create</span><span class="hljs-params">(struct net *net, struct socket *sock, <span class="hljs-keyword">int</span> protocol,</span></span><br><span class="hljs-params"><span class="hljs-function">              <span class="hljs-keyword">int</span> kern)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 1. 查表</span><br>    netlink_lock_table();<br>    <span class="hljs-keyword">if</span> (nl_table[protocol].registered &amp;&amp;<br>        try_module_get(nl_table[protocol].<span class="hljs-keyword">module</span>))<br>        <span class="hljs-keyword">module</span> = nl_table[protocol].<span class="hljs-keyword">module</span>;<br>    <span class="hljs-keyword">else</span><br>        err = -EPROTONOSUPPORT;<br>    cb_mutex = nl_table[protocol].cb_mutex;<br>    bind = nl_table[protocol].bind;<br>    unbind = nl_table[protocol].unbind;<br>    netlink_unlock_table();<br><br>    <span class="hljs-comment">// 2. 赋值</span><br>    nlk = nlk_sk(sock-&gt;sk);<br>    nlk-&gt;<span class="hljs-keyword">module</span> = <span class="hljs-keyword">module</span>;<br>    nlk-&gt;netlink_bind = bind;<br>    nlk-&gt;netlink_unbind = unbind;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-netlink’s-protocols"><a href="#2-2-netlink’s-protocols" class="headerlink" title="2.2 netlink’s protocols"></a>2.2 netlink’s protocols</h3><p>下面来看一下 netlink 处理不同 protocol 的方式</p><p>netlink 通过 <code>netlink_kernel_create</code> 来初始化一种 protocol，该函数接收三个参数：</p><ol><li>net：network namespace</li><li>unit：也就是将 protocol 作为 netlink_table 的下标，</li><li>cfg：配置选项，提供 input/bind/unbind 等回调函数，以及别的一些配置信息，保存到 nl_table 中</li></ol><p>也就是说，netlink 将 protocol 作为 nl_table 的下标，不同的 protocol 提供不同的 cfg 即可，这是一种典型的<strong>策略模式</strong>，下面分别是 NETLINK_ROUTE 和 NETLINK_KOBJECT_UEVENT 两种 protocol 对应的初始化函数，so easy</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __net_init <span class="hljs-title">rtnetlink_net_init</span><span class="hljs-params">(struct net *net)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">netlink_kernel_cfg</span> <span class="hljs-title">cfg</span> =</span> &#123;<br>        .groups        = RTNLGRP_MAX,<br>        .input        = rtnetlink_rcv,<br>        .cb_mutex    = &amp;rtnl_mutex,<br>        .flags        = NL_CFG_F_NONROOT_RECV,<br>        .bind        = rtnetlink_bind,<br>    &#125;;<br><br>    sk = netlink_kernel_create(net, NETLINK_ROUTE, &amp;cfg);<br>    <span class="hljs-keyword">if</span> (!sk)<br>        <span class="hljs-keyword">return</span> -ENOMEM;<br>    net-&gt;rtnl = sk;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uevent_net_init</span><span class="hljs-params">(struct net *net)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uevent_sock</span> *<span class="hljs-title">ue_sk</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">netlink_kernel_cfg</span> <span class="hljs-title">cfg</span> =</span> &#123;<br>        .groups    = <span class="hljs-number">1</span>,<br>        .input = uevent_net_rcv,<br>        .flags    = NL_CFG_F_NONROOT_RECV<br>    &#125;;<br>    <span class="hljs-comment">// ...</span><br><br>    ue_sk-&gt;sk = netlink_kernel_create(net, NETLINK_KOBJECT_UEVENT, &amp;cfg);<br>    <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-deeper-into-netlink’s-api"><a href="#2-3-deeper-into-netlink’s-api" class="headerlink" title="2.3 deeper into netlink’s api"></a>2.3 deeper into netlink’s api</h3><p>前面提到，通过 socket api 可以直接操作 netlink，那具体到每种操作，对应怎样的内核执行路径呢？下面来进行探究</p><ol><li>sendmsg 系统调用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">___sys_sendmsg<br>    --&gt; sock_sendmsg<br>        --&gt; sock-&gt;ops-&gt;sendmsg(sock, msg, msg_data_left(msg)) = netlink_sendmsg<br>            --&gt; netlink_unicast <br>                --&gt; netlink_unicast_kernel<br>                    --&gt; nlk-&gt;netlink_rcv = cfg-&gt;input<br>                        --&gt; rtnetlink_rcv<br></code></pre></td></tr></table></figure><p>sys_sendmsg 最终会调用到 <code>sock_ops-&gt;sendmsg</code>，从而触发 AF_NETLINK 对应的 <code>netlink_sendmsg</code> 回调函数。</p><p>前面也说到，netlink 可以对应单播或者广播，这里以 unicast，也就是单播的执行路径为例，最终触发了 <code>cfg-&gt;input</code> 中传入的 rev 函数，对于 rtnetlink 而言，就会调用 <code>rtnetlink_rcv</code>。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">rtnetlink_rcv<br>    --&gt; netlink_rcv_skb<br>        --&gt; rtnetlink_rcv_msg<br>            --&gt; rtnl_get_link(family, type)<br>                --&gt; netlink_dump_start(rtnl, skb, nlh, &amp;c)<br>                    --&gt; netlink_lookup<br>                    --&gt; netlink_dump<br>                        --&gt; alloc_skb<br>                        --&gt; skb_reserve<br>                        --&gt; netlink_skb_set_owner_r<br>                        --&gt; nlk-&gt;dump_done_errno = cb-&gt;dump(skb, cb) // 执行 rtnl_dump_ifinfo/rtnl_dump_all 回调函数<br>                        --&gt; __netlink_sendskb(sk, skb)<br>                            --&gt; netlink_deliver_tap(sock_net(sk), skb)<br>                            --&gt; skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb) //将skb加入到用户态 sock的 sk_receive_queue 队列<br>                            --&gt; sk-&gt;sk_data_ready(sk) = sock_def_readable // 唤醒 netlink_recvmsg 进行接收<br>                               --&gt;  wake_up_interruptible_sync_poll<br></code></pre></td></tr></table></figure><ol start="2"><li>recvmsg 系统调用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">__sys_recvmmsg<br>    --&gt;___sys_recvmsg<br>        --&gt; sock-&gt;ops-&gt;recvmsg(socket, msg, msg_data_left(msg))<br>            --&gt; netlink_recvmsg<br>                --&gt; skb_recv_datagram<br>                    --&gt; __skb_recv_datagram<br>                        --&gt; __skb_try_recv_datagram or __skb_wait_for_more_packets<br>                            --&gt; __skb_try_recv_from_queue // 从 sk-&gt;sk_receive_queue 中取出 skb<br></code></pre></td></tr></table></figure><p>在 rtnl_get_link 这一步，会根据传入的下标取出 <code>rtnl_msg_handlers</code> 数组中的 link，从而执行 <code>link-&gt;doit</code> 回调函数</p><p>而该数组中的内容是系统初始化时就设置好的，在 <code>rtnetlink_init</code> 中，通过 <code>rtnl_register</code> 初始化了一系列操作对应的处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> __init <span class="hljs-title">rtnetlink_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (register_pernet_subsys(&amp;rtnetlink_net_ops))<br>        panic(<span class="hljs-string">&quot;rtnetlink_init: cannot initialize rtnetlink\n&quot;</span>);<br><br>    register_netdevice_notifier(&amp;rtnetlink_dev_notifier);<br><br>    rtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink,<br>              rtnl_dump_ifinfo, <span class="hljs-number">0</span>);<br>    rtnl_register(PF_UNSPEC, RTM_SETLINK, rtnl_setlink, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    rtnl_register(PF_UNSPEC, RTM_NEWLINK, rtnl_newlink, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    rtnl_register(PF_UNSPEC, RTM_DELLINK, rtnl_dellink, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br>    rtnl_register(PF_UNSPEC, RTM_GETADDR, <span class="hljs-literal">NULL</span>, rtnl_dump_all, <span class="hljs-number">0</span>);<br>    rtnl_register(PF_UNSPEC, RTM_GETROUTE, <span class="hljs-literal">NULL</span>, rtnl_dump_all, <span class="hljs-number">0</span>);<br>    rtnl_register(PF_UNSPEC, RTM_GETNETCONF, <span class="hljs-literal">NULL</span>, rtnl_dump_all, <span class="hljs-number">0</span>);<br><br>    rtnl_register(PF_UNSPEC, RTM_NEWLINKPROP, rtnl_newlinkprop, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    rtnl_register(PF_UNSPEC, RTM_DELLINKPROP, rtnl_dellinkprop, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br>    rtnl_register(PF_BRIDGE, RTM_NEWNEIGH, rtnl_fdb_add, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    rtnl_register(PF_BRIDGE, RTM_DELNEIGH, rtnl_fdb_del, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    rtnl_register(PF_BRIDGE, RTM_GETNEIGH, rtnl_fdb_get, rtnl_fdb_dump, <span class="hljs-number">0</span>);<br><br>    rtnl_register(PF_BRIDGE, RTM_GETLINK, <span class="hljs-literal">NULL</span>, rtnl_bridge_getlink, <span class="hljs-number">0</span>);<br>    rtnl_register(PF_BRIDGE, RTM_DELLINK, rtnl_bridge_dellink, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    rtnl_register(PF_BRIDGE, RTM_SETLINK, rtnl_bridge_setlink, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br>    rtnl_register(PF_UNSPEC, RTM_GETSTATS, rtnl_stats_get, rtnl_stats_dump,<br>              <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>rtnl_register</code> 函数原型为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rtnl_register</span><span class="hljs-params">(<span class="hljs-keyword">int</span> protocol, <span class="hljs-keyword">int</span> msgtype,</span></span><br><span class="hljs-params"><span class="hljs-function">           rtnl_doit_func doit, rtnl_dumpit_func dumpit,</span></span><br><span class="hljs-params"><span class="hljs-function">           <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><p>几个参数的含义分别为：</p><ol><li>protocol：具体的协议</li><li>msgtype：消息类型，后面会提到</li><li>doit：注册到 rtnl_msg_handlers 中的 link-&gt;doit</li><li>dumpit：注册到 rtnl_msg_handlers 中的 link-&gt;dumpit</li><li>flags：doit/dumpit 的参数</li></ol><p>rtnetlink 字面意思是 <code>route table netlink</code>，其实它包含的范围更大，邻居子系统也是通过 rtnetlink 暴露出去的，都可以从上面的 msgtype 参数可以看出来。</p><p>这样解释还是有一些抽象，但其实 Linux 中一些网络相关的常用指令都是以 rtnetlink 为基础，就比如 <code>ip addr show</code></p><p>这条指令，会显示所有网络设备的地址信息，背后就是调用了 msgtype 为 RTM_GETADDR 的 <code>rtnl_dump_all</code> ，通过 <a href="https://github.com/brendangregg/perf-tools/blob/master/kernel/funcgraph">funcgraph</a> 可以查看详细的内核函数调用链，从而验证这一点。</p><p>事实上，NETLINK_ROUTE 可以按照下面进行划分：</p><ol><li>LINK (network interfaces)</li><li>ADDR (network addresses)</li><li>ROUTE (network messages)</li><li>NEIGH (neighbouring subsystem messages)</li><li>RULE (policy rouing rules)</li><li>QDISC (queueing disciplines)</li><li>TCLASS (traffic classes)</li><li>ACTIOn (packet action api)</li><li>NEIGHTBL (neighbouring table)</li><li>ADDRLABEL (address labeling)</li></ol><p>不仅是路由子系统，几乎所有 L3 和 L2 的功能，都通过 rtnetlink 暴露出去</p><h2 id="3-generic-netlink-protocol"><a href="#3-generic-netlink-protocol" class="headerlink" title="3. generic netlink protocol"></a>3. generic netlink protocol</h2><p>netlink 协议簇数最大 32 个（MAX_LINKS），为支持更多的协议簇，开发了通用 netlink 簇 NETLINK_GENERIC。generic netlink 以 netlink 协议为基础，多做了一层多路复用，从而能够支持更多的子系统（netlink 本身已经完成了一次多路复用）。</p><p>同理，generic netlink 也需要通过 <code>netlink_kernel_create</code> 初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __net_init <span class="hljs-title">genl_pernet_init</span><span class="hljs-params">(struct net *net)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">netlink_kernel_cfg</span> <span class="hljs-title">cfg</span> =</span> &#123;<br>        .input        = genl_rcv,<br>        .flags        = NL_CFG_F_NONROOT_RECV,<br>    &#125;;<br><br>    net-&gt;genl_sock = netlink_kernel_create(net, NETLINK_GENERIC, &amp;cfg);<br><br>    <span class="hljs-keyword">if</span> (!net-&gt;genl_sock &amp;&amp; net_eq(net, &amp;init_net))<br>        panic(<span class="hljs-string">&quot;GENL: Cannot initialize generic netlink\n&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (!net-&gt;genl_sock)<br>        <span class="hljs-keyword">return</span> -ENOMEM;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，generic netlink socket 的 <code>nlk-&gt;netlink_rcv</code> 会对应 <code>genl_rcv</code>，在这个函数中，主要是查找对应的 generic family，然后调用其对应的 <code>doit</code> 回调函数。</p><p>这一点其实不难理解，netlink 本身支持多种协议簇，所以维护了一张 nl_table，保存了所有协议对应的处理方式，以 protocol 作为下标，取出对应的协议回调函数即可，这是第一层<strong>多路复用</strong>。</p><p>而 generic netlink 在这个基础上进一步维护了多路复用，同理也是维护一张表格，通过二级协议类型 <code>genl_family</code> 作为下标，道理其实非常相似。</p><p>genl_family 可以通过 genl_register_family/genl_unregister_family 进行注册和注销。</p><p>只不过有一点不大一样，genl_family 用到了 <code>struct idr</code> 这个结构，相比数组而言更加灵活，这里不过多赘述。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>network</category>
      
      <category>netlink</category>
      
      <category>ipc</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ipv4 routing system</title>
    <link href="/2022/02/22/linux/network/routing/"/>
    <url>/2022/02/22/linux/network/routing/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>network</category>
      
      <category>route</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Engineer Culture</title>
    <link href="/2022/02/20/life/engineer%20culture/"/>
    <url>/2022/02/20/life/engineer%20culture/</url>
    
    <content type="html"><![CDATA[<p>看了一篇<a href="https://www.cnblogs.com/schips/p/14816477.html">为什么要工程师文化-博客</a>，深有感触，觉得对作为程序员的自己有很强的警示作用</p><h2 id="从程序员说起"><a href="#从程序员说起" class="headerlink" title="从程序员说起"></a>从程序员说起</h2><p>成为一名计算机学院的学生以来，我并没有把自己当做一个工程师，而是目标成为一个程序员，而程序员在我的印象中，有下面几个特点：</p><ol><li>思维缜密</li><li>虽然累但是挣钱多</li><li>沉默寡言，不善攀谈</li></ol><p>这也符合大部分对于程序员的刻板印象，但是这样就够了吗？直到我仔细读完了上面那篇文章，才有了更进一步的领悟。</p><p>作为一名工科的学生，首要任务是当一名合格的工程师！何谓工程师？</p><p>邓爷爷说过，科学是第一生产力，但是要真正将科技落实，还是要看一个国家的技术实力，技术靠谁？工程师！</p><p>简单来说，工程师就是那些将科学理论付诸于实践的人，那么如何区分初级和高级工程师呢？这里又想多说一句，很多从计算机培训班出来的程序员，只能找到月薪几千的工作，还在为上万的工资奋斗，而985科班出来的学生，大部分都拿到了年薪40w以上的offer，区别在哪里呢？大家都是臭写代码的，真的有那么大区别吗？还别说，真有。</p><p>在我看来，正如区分低级程序员和高级程序员一样，低级工程师和高级工程师的主要区分点也在于有没有扎实的专业素养，能够科学地运用各种技能，解决实际中遇到的问题，而不是只懂得借鉴前人的经验，抄谁不会啊！</p><p>而这些都不算真正的主题，高级工程师该如何更进一步提高自己呢？诶，那就不得不提<strong>创造力</strong>这一点了。</p><p>真正优秀的工程师，时时刻刻都在发挥自己的<strong>创造力</strong>，去解决问题，因为这些困难往往是前人没有遇到过的。最典型的莫过于发明家了。发明家不同于科学家，科学家常常是通过各种实验，观察，猜测发现一些科学的规律，发明家则是通过自己的聪明才智，去创造一些可以解决问题的东西。</p><h2 id="工程师文化"><a href="#工程师文化" class="headerlink" title="工程师文化"></a>工程师文化</h2><p>上面着重谈到了创造力，不过，应该如何培养创造力呢？创造力是与生俱来吗？</p><p>创造力需要土壤！</p><p>土壤需要养料！</p><p>养料 = 自由 + 效率 ！</p><p>很羡慕国外 google 这样公司的氛围：没有国内996压力，那么高的年薪也可以过一个非常体面的生活，上上下下都在鼓励创新，也在持续招聘高素质人才，可以说是形成了一个良性循环，已经成为了培养优秀程序员（树木）的森林了。</p><p>当程序员没有那么多生活上的压力，自然可以将重心放在工作上，我觉得程序员是最愿意为解决问题而 work hard 的一类群体了，同时轻松的工作分为也能提高大家的工作效率，那么 good ideas 不是一抓一大把？</p><p>反观国内的现状，各种房贷车贷加班的压力让人喘不过气，哪里谈得上创造呢？还不都是去 github copy 一些代码，然后再去修改，完成任务算事，创造力从何谈起呢？</p><h2 id="自省"><a href="#自省" class="headerlink" title="自省"></a>自省</h2><p>当然，说这些并不是我已经达到了高级甚至更加富有创造力的标准了，而是给从前的自己一个警醒：学习源码可以，但是一定要有自己的思考。</p><p>想必作为学生，模仿是学习路上必不可少的一点，不过一定要弄清楚问题在哪里：模仿不是终点，而是为了更好地创造。</p><p>也读了很多源码了，其实很多原理并不复杂，思路也是类似的，为什么人家可以做到这些呢？其实不仅是他们已经付出了更多的努力，而且还敢于敢于面对问题，敢于尝试，敢于试错。</p><p>勇敢点，多学多思考，相信时间的力量吧！</p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
      <category>thinking</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>netfilter</title>
    <link href="/2022/02/15/linux/network/netfilter/"/>
    <url>/2022/02/15/linux/network/netfilter/</url>
    
    <content type="html"><![CDATA[<h2 id="1-netfilter-简介"><a href="#1-netfilter-简介" class="headerlink" title="1. netfilter 简介"></a>1. netfilter 简介</h2><h2 id="1-1-什么是-netfilter"><a href="#1-1-什么是-netfilter" class="headerlink" title="1.1 什么是 netfilter"></a>1.1 什么是 netfilter</h2><p>如今的 netfilter 遍布 Linux network system 的各个角落，我们首先来回顾一下其发展历史。</p><p>早些的 Linux 版本中，也存在用来进行 ip 过滤、管理等操作的框架，不论是 ipchains 还是 ipfwadm（ip firewall admin），功能都比较局限。直到 netfilter 出现，作为一个统一且易于扩展的框架，应用到内核当中。</p><p>netfilter 允许用户注册各种回调函数，并且在特定的场合（netfilter hooks）按照特定的条件触发，在内核收发 skb 数据包的链路中，存在多处这样的 hook，不仅可以用来记录连接信息（logging），甚至可以更改 skb 头部的一些字段（mangle），更改 ip 地址（NAT），丢弃数据包（防火墙）</p><h3 id="1-2-思路"><a href="#1-2-思路" class="headerlink" title="1.2 思路"></a>1.2 思路</h3><p>netfilter 是内核中的一个重要模块，同时也需要和用户程序进行交互，因此下面分为两大部分进行讲解：</p><ol><li>netfilter 功能，如 NAT，修改数据包头部，连接追踪，包过滤，网络统计等</li><li>iptables 如何起作用的</li></ol><h2 id="2-netfilter-框架"><a href="#2-netfilter-框架" class="headerlink" title="2. netfilter 框架"></a>2. netfilter 框架</h2><p>刚刚讲到，netfilter 通过不同的 hook 生效，首先就来看究竟有哪些 hooks</p><h3 id="2-1-netfilter-hooks"><a href="#2-1-netfilter-hooks" class="headerlink" title="2.1 netfilter hooks"></a>2.1 netfilter hooks</h3><p>在 <code>include/uapi/linux/netfilter.h</code> 中，定义了下面的五种最广为人知的 hooks</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">nf_inet_hooks</span> &#123;</span><br>    NF_INET_PRE_ROUTING,   <span class="hljs-comment">// 在 ip 包的路由前调用</span><br>    NF_INET_LOCAL_IN,      <span class="hljs-comment">// dst 地址为本机时，上交给传输层时调用</span><br>    NF_INET_FORWARD,       <span class="hljs-comment">// 转发 ip 包时调用</span><br>    NF_INET_LOCAL_OUT,     <span class="hljs-comment">// 发送数据包，从传输层发送到 ip 层时调用</span><br>    NF_INET_POST_ROUTING,  <span class="hljs-comment">// 发送数据包，经过邻居子系统之前调用</span><br>    NF_INET_NUMHOOKS,<br>    NF_INET_INGRESS = NF_INET_NUMHOOKS,<br>&#125;;<br></code></pre></td></tr></table></figure><p>对上面几个 hook 类型不熟悉也没关系，可以先结合下面这张内核收发包路径图强化一下认识：</p><p><img src="/images/sysnet-outline.png" alt="内核网络框架"></p><p>netfilter 框架提供了一种比较便捷的使用 hooks 的方式：NF_HOOK</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">NF_HOOK</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> pf, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> hook, struct net *net, struct sock *sk, struct sk_buff *skb,</span></span><br><span class="hljs-params"><span class="hljs-function">    struct net_device *in, struct net_device *out,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">int</span> (*okfn)(struct net *, struct sock *, struct sk_buff *))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ret = nf_hook(pf, hook, net, sk, skb, in, out, okfn);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">1</span>)<br>        ret = okfn(net, sk, skb);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释一下这里的参数：</p><ol><li>pf：protocol family，即 ipv4 或 ipv6</li><li>hook：hook 类型，可以参考上面的 enum nf_inet_hooks</li><li>skb：当前正在处理的数据包</li><li>in：网络输入设备</li><li>out：网络输出设备</li><li>okfn：该 hook 结束时调用的函数，仅接收 skb 作为参数</li></ol><p>这个函数返回 <code>nf_hook</code> 的结果，<code>nf_hook</code> 中，就是简单判定一下 hook 类型，取出对应的回调函数，交给 <code>nf_hook_slow</code> 进行处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nf_hook</span><span class="hljs-params">(<span class="hljs-keyword">u_int8_t</span> pf, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> hook, struct net *net,</span></span><br><span class="hljs-params"><span class="hljs-function">              struct sock *sk, struct sk_buff *skb,</span></span><br><span class="hljs-params"><span class="hljs-function">              struct net_device *indev, struct net_device *outdev,</span></span><br><span class="hljs-params"><span class="hljs-function">              <span class="hljs-keyword">int</span> (*okfn)(struct net *, struct sock *, struct sk_buff *))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_entries</span> *<span class="hljs-title">hook_head</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">1</span>;<br><br>    rcu_read_lock();<br>    <span class="hljs-keyword">switch</span> (pf) &#123;<br>    <span class="hljs-keyword">case</span> NFPROTO_IPV4:<br>        hook_head = rcu_dereference(net-&gt;nf.hooks_ipv4[hook]);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> NFPROTO_IPV6:<br>        hook_head = rcu_dereference(net-&gt;nf.hooks_ipv6[hook]);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">default</span>:<br>        WARN_ON_ONCE(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (hook_head) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_state</span> <span class="hljs-title">state</span>;</span><br><br>        nf_hook_state_init(&amp;state, hook, pf, indev, outdev,<br>                   sk, net, okfn);<br><br>        ret = nf_hook_slow(skb, &amp;state, hook_head, <span class="hljs-number">0</span>);<br>    &#125;<br>    rcu_read_unlock();<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终该函数返回一个表示处理状态的值，有下面几个选项：</p><ol><li>NF_DROP 丢弃数据包</li><li>NF_ACCEPT 接受数据包</li><li>NF_STOLEN 数据包被抢占</li><li>NF_QUEUE 将数据包放入队列</li><li>NF_REPEAT 该 hook 函数应该重新调用</li></ol><p>具体使用时候就很简单了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ip_rcv</span><span class="hljs-params">(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,</span></span><br><span class="hljs-params"><span class="hljs-function">       struct net_device *orig_dev)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net</span> *<span class="hljs-title">net</span> =</span> dev_net(dev);<br><br>    skb = ip_rcv_core(skb, net);<br>    <span class="hljs-keyword">if</span> (skb == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> NET_RX_DROP;<br><br>    <span class="hljs-keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,<br>               net, <span class="hljs-literal">NULL</span>, skb, dev, <span class="hljs-literal">NULL</span>,<br>               ip_rcv_finish);<br>&#125;<br></code></pre></td></tr></table></figure><p>比如上面的 <code>ip_rcv</code>，传入必要的参数，以及 <code>ip_rcv_finish</code> 这个 okfn，从而在该 hook 执行结束之后接着通过 <code>ip_rcv_finish</code> 处理 skb 数据包。</p><h3 id="2-2-netfilter-registration"><a href="#2-2-netfilter-registration" class="headerlink" title="2.2 netfilter registration"></a>2.2 netfilter registration</h3><p>不论有多少 hook，最终还是由用户的回调函数来决定具体的操作（框架+机制），那么回调函数是如何注册的呢？先来看 nf_hook_ops 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nf_hookfn</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *priv,</span></span><br><span class="hljs-params"><span class="hljs-function">                   struct sk_buff *skb,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">const</span> struct nf_hook_state *state)</span></span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_ops</span> &#123;</span><br>    <span class="hljs-comment">/* User fills in from here down. */</span><br>    nf_hookfn        *hook;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span>    *<span class="hljs-title">dev</span>;</span><br>    <span class="hljs-keyword">void</span>            *priv;<br>    <span class="hljs-keyword">u_int8_t</span>        pf;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>        hooknum;<br>    <span class="hljs-comment">/* Hooks are ordered in ascending priority. */</span><br>    <span class="hljs-keyword">int</span>            priority;<br>&#125;;<br></code></pre></td></tr></table></figure><p>来看几个重要字段的含义：</p><ol><li>hook：回调函数</li><li>dev：设备</li><li>pf：协议族，可以参考上面的 enum nf_inet_hooks</li><li>priority：优先级，所有 <code>nf_hook_ops</code> 按照从小到大的顺序组织，数值越小，优先级越高</li></ol><p>有两个函数可以注册 hook：</p><ol><li>nf_register_net_hook</li><li>nf_register_net_hooks</li></ol><p>后者其实只是传入一个 <code>nf_hook_ops</code> 数组，循环调用 <code>nf_register_net_hook</code> 罢了，前者最核心的处理逻辑在于传入旧的 <code>nf_hook_entries</code> 列表以及新添加的 <code>nf_hook_ops</code>，并返回一个新的 <code>nf_hook_entries</code> 列表，我们来看一下具体实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_ops</span> <span class="hljs-title">dummy_ops</span> =</span> &#123;<br>    .hook = accept_all,<br>    .priority = INT_MIN,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> struct nf_hook_entries *</span><br><span class="hljs-function"><span class="hljs-title">nf_hook_entries_grow</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct nf_hook_entries *old,</span></span><br><span class="hljs-params"><span class="hljs-function">             <span class="hljs-keyword">const</span> struct nf_hook_ops *reg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i, alloc_entries, nhooks, old_entries;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_ops</span> **<span class="hljs-title">orig_ops</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_ops</span> **<span class="hljs-title">new_ops</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_entries</span> *<span class="hljs-title">new</span>;</span><br>    <span class="hljs-keyword">bool</span> inserted = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 1. 计算需要分配的空间</span><br>    alloc_entries = <span class="hljs-number">1</span>;<br>    old_entries = old ? old-&gt;num_hook_entries : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (old) &#123;<br>        orig_ops = nf_hook_entries_get_hook_ops(old);<br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; old_entries; i++) &#123;<br>            <span class="hljs-keyword">if</span> (orig_ops[i] != &amp;dummy_ops)<br>                alloc_entries++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (alloc_entries &gt; MAX_HOOK_COUNT)<br>        <span class="hljs-keyword">return</span> ERR_PTR(-E2BIG);<br><br>    <span class="hljs-keyword">new</span> = allocate_hook_entries_size(alloc_entries);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>)<br>        <span class="hljs-keyword">return</span> ERR_PTR(-ENOMEM);<br><br>    new_ops = nf_hook_entries_get_hook_ops(<span class="hljs-keyword">new</span>);<br><br>    <span class="hljs-comment">// 2. 按照 priority 插入到合适的位置</span><br>    i = <span class="hljs-number">0</span>;<br>    nhooks = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; old_entries) &#123;<br>        <span class="hljs-keyword">if</span> (orig_ops[i] == &amp;dummy_ops) &#123;<br>            ++i;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (inserted || reg-&gt;priority &gt; orig_ops[i]-&gt;priority) &#123;<br>            new_ops[nhooks] = (<span class="hljs-keyword">void</span> *)orig_ops[i];<br>            <span class="hljs-keyword">new</span>-&gt;hooks[nhooks] = old-&gt;hooks[i];<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            new_ops[nhooks] = (<span class="hljs-keyword">void</span> *)reg;<br>            <span class="hljs-keyword">new</span>-&gt;hooks[nhooks].hook = reg-&gt;hook;<br>            <span class="hljs-keyword">new</span>-&gt;hooks[nhooks].priv = reg-&gt;priv;<br>            inserted = <span class="hljs-literal">true</span>;<br>        &#125;<br>        nhooks++;<br>    &#125;<br><br>    <span class="hljs-comment">// 3. !inserted 表示之前没有任何表项，直接插入</span><br>    <span class="hljs-keyword">if</span> (!inserted) &#123;<br>        new_ops[nhooks] = (<span class="hljs-keyword">void</span> *)reg;<br>        <span class="hljs-keyword">new</span>-&gt;hooks[nhooks].hook = reg-&gt;hook;<br>        <span class="hljs-keyword">new</span>-&gt;hooks[nhooks].priv = reg-&gt;priv;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>nf_hook_entries_grow</code> 大致可以分为两个部分：</p><ol><li>计算需要分配的空间</li><li>按照 priority 将 reg 插入到合适的位置</li></ol><p>可以看出，alloc_entries 表示的分配表项数目为 <code>1 + num_of_old_entries</code>，其中 num_of_old_entries 则是原有表项数目。之所以要与 <code>dummy_ops</code> 进行比较，是因为 <code>dummy_ops</code> 并不消耗空间，只需要一个指针指向其即可，分配空间处理的是那些有意义的表项</p><p>根据 priority 插入 reg 的过程也挺简单，和插入排序比较相似，只不过这里不仅需要插入一个表项，还需要按序将旧表中的所有内容拷贝过来，再重新体会一下上面的代码，应该比较容易理解。</p><h3 id="2-3-netfilter-front-end-iptables"><a href="#2-3-netfilter-front-end-iptables" class="headerlink" title="2.3 netfilter front end - iptables"></a>2.3 netfilter front end - iptables</h3><p>iptables 作为 netfilter 的前端，在内核中分别对应 ipv4 和 ipv6 的实现，这里只讨论前者的实现机制。</p><p>为了与用户空间进行交互，iptables 使用了 <code>struct xt_table</code> 进行表示，拿过滤数据包的表格为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILTER_VALID_HOOKS ((1 &lt;&lt; NF_INET_LOCAL_IN) | \</span><br><span class="hljs-meta">                (1 &lt;&lt; NF_INET_FORWARD) | \</span><br><span class="hljs-meta">                (1 &lt;&lt; NF_INET_LOCAL_OUT))</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xt_table</span> <span class="hljs-title">packet_filter</span> =</span> &#123;<br>    .name        = <span class="hljs-string">&quot;filter&quot;</span>,<br>    .valid_hooks    = FILTER_VALID_HOOKS,<br>    .me        = THIS_MODULE,<br>    .af        = NFPROTO_IPV4,<br>    .priority    = NF_IP_PRI_FILTER,<br>    .table_init    = iptable_filter_table_init,<br>&#125;;<br></code></pre></td></tr></table></figure><p>之前也都接触过类似于 name，me，af，priority 这样的字段，这里不必多言，重心放在 <code>table_init</code> 对应的 <code>iptable_filter_table_init</code> 回调函数上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __net_init <span class="hljs-title">iptable_filter_table_init</span><span class="hljs-params">(struct net *net)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipt_replace</span> *<span class="hljs-title">repl</span>;</span><br>    <span class="hljs-keyword">int</span> err;<br><br>    <span class="hljs-comment">// 1. 判断是否已经存在 iptable_filter 表</span><br>    <span class="hljs-keyword">if</span> (net-&gt;ipv4.iptable_filter)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 2. 创建 iptable_filter 表</span><br>    repl = ipt_alloc_initial_table(&amp;packet_filter);<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 3. 注册 iptable_filter 表为 net-&gt;ipv4.iptable_filter，同时将 filter_ops 注册到 iptables 管理结构中</span><br>    err = ipt_register_table(net, &amp;packet_filter, repl, filter_ops,<br>                 &amp;net-&gt;ipv4.iptable_filter);<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是典型的三步走：</p><ol><li>判断是否已经初始化完成</li><li>未初始化则首先分配空间</li><li>调用对应的注册函数</li></ol><p>再来看 <code>ipt_register_table</code>，该函数主要做了四件事：</p><ol><li>分配新表所用内存</li><li>将 table 注册到 <code>net-&gt;xt.tables</code> 结构中</li><li>设置 <code>net-&gt;ipv4.xxx_table</code> 为传入的 ops</li><li>注册 netfilter hooks</li></ol><p>也就是说，不仅要完成和 iptables 相关的注册，也要完成 netfilter 相关的注册。</p><p>之后的很多关键回调操作，其实都会根据已经设置的 <code>net-&gt;ipv4.xxx_table</code> 进行相应回调</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">iptable_nat_do_chain</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *priv,</span></span><br><span class="hljs-params"><span class="hljs-function">                     struct sk_buff *skb,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-keyword">const</span> struct nf_hook_state *state)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ipt_do_table(skb, state, state-&gt;net-&gt;ipv4.nat_table);<br>&#125;<br></code></pre></td></tr></table></figure><p>很多人可能还会好奇，iptables 这条命令是如何与内核进行交互的呢？通过 <code>strace iptables -nvL</code> 可以发现，用到了名为 getsockopt 的系统调用。</p><p>顺着这条线索，可以去查看和 iptables 相关的 <code>.getsockopt &amp;&amp; .setsockopt</code> 回调函数，果然发现了 <code>nf_getsockopt</code> 以及 <code>nf_setsockopt</code>，只不过这两个函数是在 <code>ip_getsockopt</code> 和 <code>ip_setsockopt</code> 中被调用的，其函数调用链如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">sys_getsockopt<br>    --&gt; .getsockopt = ip_getsockopt<br>        --&gt; nf_getsockopt<br>            --&gt; nf_sockopt_ops-&gt;get = do_ipt_get_ctl<br>                --&gt; dispatch cmd ...<br></code></pre></td></tr></table></figure><p>在 <code>nf_sockopt_ops-&gt;get</code> 对应的 <code>do_ipt_get_ctl</code> 操作中，会根据用户输入指令派发相应的操作。同理，<code>do_ipt_set_ctl</code> 的逻辑可能要稍复杂一些，不过根据前面的知识，相信你也能啃下这块骨头，其源码位于 <code>net/ipv4/netfilter/ip_tables.c</code>。</p><p>还有一点值得一提，那就是 <code>nf_sockopt_ops</code> 其实是针对网络各个协议表格的统一抽象，除了 iptables，其它的比如 arptables，ip6tables，ebtables 等等，也都有其对应的 nf_sockopt_ops 结构体，并且可以通过 <code>nf_register_sockopt</code> 注册到系统中，然后通过 <code>nf_sockopt_find</code> 查询出来并加以使用。这种抽象大大降低了编码复杂度，并且可以更加有序地管理各种表格。</p><h3 id="2-3-netfilter-功能"><a href="#2-3-netfilter-功能" class="headerlink" title="2.3 netfilter 功能"></a>2.3 netfilter 功能</h3><p>接下来的几个小节，都是对 netfilter 的具体功能进行讲解。</p><p>首先要明确 netfilter 框架为我们提供了什么，然后才能利用好它。</p><p>netfilter 框架可以简化为 <strong>hooks + 回调函数</strong>，那么如果想要在网络收发包路径上的特定位置，做一些特殊操作，注册回调函数就好了嘛。hooks 不仅可以由用户在内核运行时注册，还可以直接在源码中声明并注册，拿来即用。</p><h4 id="2-3-1-Connection-Tracking"><a href="#2-3-1-Connection-Tracking" class="headerlink" title="2.3.1 Connection Tracking"></a>2.3.1 Connection Tracking</h4><p>TODO</p><h4 id="2-3-2-NAT"><a href="#2-3-2-NAT" class="headerlink" title="2.3.2 NAT"></a>2.3.2 NAT</h4><p>NAT 即 network address translation，网络地址转换，也是通过注册 nf_hook_ops 来实现，对应下面这些 ops</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_ops</span> <span class="hljs-title">nf_nat_ipv4_ops</span>[] =</span> &#123;<br>    <span class="hljs-comment">/* Before packet filtering, change destination */</span><br>    &#123;<br>        .hook        = nf_nat_ipv4_in,<br>        .pf        = NFPROTO_IPV4,<br>        .hooknum    = NF_INET_PRE_ROUTING,<br>        .priority    = NF_IP_PRI_NAT_DST,<br>    &#125;,<br>    <span class="hljs-comment">/* After packet filtering, change source */</span><br>    &#123;<br>        .hook        = nf_nat_ipv4_out,<br>        .pf        = NFPROTO_IPV4,<br>        .hooknum    = NF_INET_POST_ROUTING,<br>        .priority    = NF_IP_PRI_NAT_SRC,<br>    &#125;,<br>    <span class="hljs-comment">/* Before packet filtering, change destination */</span><br>    &#123;<br>        .hook        = nf_nat_ipv4_local_fn,<br>        .pf        = NFPROTO_IPV4,<br>        .hooknum    = NF_INET_LOCAL_OUT,<br>        .priority    = NF_IP_PRI_NAT_DST,<br>    &#125;,<br>    <span class="hljs-comment">/* After packet filtering, change source */</span><br>    &#123;<br>        .hook        = nf_nat_ipv4_fn,<br>        .pf        = NFPROTO_IPV4,<br>        .hooknum    = NF_INET_LOCAL_IN,<br>        .priority    = NF_IP_PRI_NAT_SRC,<br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在四个 hook 点对应关系如下：</p><ol><li>PRE_ROUTING – nf_nat_ipv4_in</li><li>POST_ROUTING – nf_nat_ipv4_out</li><li>LOCAL_OUT – nf_nat_ipv4_local_fn</li><li>LOCAL_IN – nf_nat_ipv4_fn</li></ol><p>模块初始化时，会通过 <code>nf_nat_register_fn</code> 注册这四个 nf_hook_ops，这里不再赘述。</p><p>经过层层调用，最终会根据协议类型，调用相应的 manipulate 函数，比如 tcp 对应 <code>tcp_manip_pkt</code>，udp 对应 <code>udp_manip_pkt</code> …… 调用链如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">nf_nat_inet_fn<br>    --&gt; nf_nat_packet<br>        --&gt; nf_nat_manip_pkt<br>            --&gt; nf_nat_ipv4_manip_pkt<br>                --&gt; l4proto_manip_pkt<br>                    --&gt; tcp_manip_pkt/udp_manip_pkt/icmp_manip_pkt/sctp_manip_pkt<br>                --&gt; csum_replace4<br></code></pre></td></tr></table></figure><p>在 Layer4 相关的协议中，还需要进一步判断到底是 DNAT 还是 SNAT，判断逻辑如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (maniptype == NF_NAT_MANIP_SRC) &#123;<br>    <span class="hljs-comment">/* Get rid of src port */</span><br>    newport = tuple-&gt;src.u.tcp.port;<br>    portptr = &amp;hdr-&gt;source;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">/* Get rid of dst port */</span><br>    newport = tuple-&gt;dst.u.tcp.port;<br>    portptr = &amp;hdr-&gt;dest;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改完数据包的头部之后，切记还要更新 checksum，不然等待数据包的只有无尽的 checksum error。</p><h4 id="2-4-2-Firewall"><a href="#2-4-2-Firewall" class="headerlink" title="2.4.2 Firewall"></a>2.4.2 Firewall</h4><p>防火墙其实是相对比较简单的功能了，因为它只是通过某些特定条件，判定数据包是否需要被拦截，如果需要被拦截，则直接返回 NF_DROP 即可，否则啥都不做就好。</p><p>同时，大部分防火墙规则是用户自定义的，并不由 Linux 本身提供，因此这里也不必多言。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>network</category>
      
      <category>netfilter</category>
      
      <category>nf_hook</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>bridge</title>
    <link href="/2022/02/15/linux/network/bridge/"/>
    <url>/2022/02/15/linux/network/bridge/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Overlook"><a href="#1-Overlook" class="headerlink" title="1. Overlook"></a>1. Overlook</h2><h3 id="1-1-什么是-bridge"><a href="#1-1-什么是-bridge" class="headerlink" title="1.1 什么是 bridge"></a>1.1 什么是 bridge</h3><p>即使你之前没有听说过 bridge 这种新奇玩意，但凡是学过计算机网络的同学，对交换机（switch）总有所耳闻吧。</p><p>通常所说的<strong>交换机</strong>工作在 OSI 参考模型的<strong>数据链路层</strong>，使用 MAC 地址转发数据，通过学习得到 MAC 地址到目标端口的映射表，依据这张表决定转发的下一个设备，并且有广播和单播等多种能力。</p><p>bridge 是 Linux 软件模拟出来的一种<strong>类似</strong>交换机的虚拟设备。</p><h3 id="1-2-如何使用-bridge"><a href="#1-2-如何使用-bridge" class="headerlink" title="1.2 如何使用 bridge"></a>1.2 如何使用 bridge</h3><p>主流 Linux 发行版都提供了 bridge 相关的命令行工具，比如 arch 可以通过 <code>sudo pacman -S bridge-utils</code> 安装。<br>使用方式如下表所示：</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">addbr bridge</td><td align="center">创建网桥</td><td align="center">brctl addbr br10</td></tr><tr><td align="center">delbr bridge</td><td align="center">删除网桥</td><td align="center">brctl delbr br10</td></tr><tr><td align="center">addif bridge device</td><td align="center">将网卡接口接入网桥</td><td align="center">brctl addif br10 eth0</td></tr><tr><td align="center">delif bridge device</td><td align="center">删除网桥接入的网卡接口</td><td align="center">brctl delif br10 eth0</td></tr><tr><td align="center">show bridge</td><td align="center">查询网桥信息</td><td align="center">brctl show br10</td></tr><tr><td align="center">stp bridge {on</td><td align="center">off}</td><td align="center">启用禁用</td></tr><tr><td align="center">showstp bridge</td><td align="center">查看网桥 STP 信息</td><td align="center">brctl showstp br10</td></tr><tr><td align="center">setfd bridge time</td><td align="center">设置网桥延迟</td><td align="center">brctl setfd br10 10</td></tr><tr><td align="center">showmacs bridge</td><td align="center">查看 mac 信息</td><td align="center">brctl showmacs br10</td></tr></tbody></table><h2 id="2-bridge-internal"><a href="#2-bridge-internal" class="headerlink" title="2. bridge internal"></a>2. bridge internal</h2><p>光练不读源码假把式，还需要深入到 Linux 源码，来看看 bridge 究竟有没有那么神奇</p><h3 id="2-1-初始化网桥"><a href="#2-1-初始化网桥" class="headerlink" title="2.1 初始化网桥"></a>2.1 初始化网桥</h3><p>万物不及初始化，bridge 模块通过 <code>br_init</code> 完成这项任务</p><p>在 <code>br_init</code> 中，将 <code>br_ioctl_hook</code> 设置为了 <code>br_ioctl_deviceless_stub</code>，brctl 的所有指令，都会触发该回调函数，通过不同的 command（cmd），分发（dispatch）不同的操作函数即可，如果对应到硬件上，相当于多路复用器。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init <span class="hljs-title">br_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> err;<br><br>    <span class="hljs-comment">// 注册 stp protocol</span><br>    err = stp_proto_register(&amp;br_stp_proto);<br>    <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;<br>        pr_err(<span class="hljs-string">&quot;bridge: can&#x27;t register sap for STP\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> err;<br>    &#125;<br><br>    <span class="hljs-comment">// forwarding database 初始化</span><br>    err = br_fdb_init();<br>    <span class="hljs-keyword">if</span> (err)<br>        <span class="hljs-keyword">goto</span> err_out;<br><br>    <span class="hljs-comment">// 注册 bridge net sys</span><br>    err = register_pernet_subsys(&amp;br_net_ops);<br>    <span class="hljs-keyword">if</span> (err)<br>        <span class="hljs-keyword">goto</span> err_out1;<br>    <br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// netlink 初始化</span><br>    err = br_netlink_init();<br>    <br>    <span class="hljs-comment">// 设置 bridge ioctl 回调函数</span><br>    brioctl_set(br_ioctl_deviceless_stub);<br><br>    <span class="hljs-comment">// 错误处理</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>br_ioctl_deviceless_stub</code> 逻辑也非常简单，对于不同的 command 派发（dispatch）不同的操作，比如 <code>br_add_bridge</code> 和 <code>br_delete_bridge</code> 两个增删的操作，分别对应了 <code>SIOCBRADDBR</code> 和 <code>SIOCBRDELBR</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">br_ioctl_deviceless_stub</span><span class="hljs-params">(struct net *net, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">void</span> __user *uarg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (cmd) &#123;<br>    <span class="hljs-keyword">case</span> SIOCGIFBR:<br>    <span class="hljs-keyword">case</span> SIOCSIFBR:<br>        <span class="hljs-keyword">return</span> old_deviceless(net, uarg);<br><br>    <span class="hljs-keyword">case</span> SIOCBRADDBR:<br>    <span class="hljs-keyword">case</span> SIOCBRDELBR:<br>    &#123;<br>        <span class="hljs-keyword">char</span> buf[IFNAMSIZ];<br><br>        <span class="hljs-keyword">if</span> (!ns_capable(net-&gt;user_ns, CAP_NET_ADMIN))<br>            <span class="hljs-keyword">return</span> -EPERM;<br><br>        <span class="hljs-keyword">if</span> (copy_from_user(buf, uarg, IFNAMSIZ))<br>            <span class="hljs-keyword">return</span> -EFAULT;<br><br>        buf[IFNAMSIZ<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (cmd == SIOCBRADDBR)<br>            <span class="hljs-keyword">return</span> br_add_bridge(net, buf);<br><br>        <span class="hljs-keyword">return</span> br_del_bridge(net, buf);<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -EOPNOTSUPP;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-添加网桥"><a href="#2-2-添加网桥" class="headerlink" title="2.2 添加网桥"></a>2.2 添加网桥</h3><p>可以先从一个基础的<strong>添加网桥</strong>操作入手，详细解释一下要经历哪些必不可少的步骤</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">br_add_bridge</span><span class="hljs-params">(struct net *net, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span> *<span class="hljs-title">dev</span>;</span><br>    <span class="hljs-keyword">int</span> res;<br><br>    <span class="hljs-comment">// 1. 创建设备</span><br>    dev = alloc_netdev(<span class="hljs-keyword">sizeof</span>(struct net_bridge), name, NET_NAME_UNKNOWN,<br>               br_dev_setup);<br><br>    <span class="hljs-keyword">if</span> (!dev)<br>        <span class="hljs-keyword">return</span> -ENOMEM;<br><br>    dev_net_set(dev, net);<br>    <span class="hljs-comment">// 2. 设置 rtnl_link_ops</span><br>    dev-&gt;rtnl_link_ops = &amp;br_link_ops;<br><br>    <span class="hljs-comment">// 3. 注册网络设备</span><br>    res = register_netdev(dev);<br>    <span class="hljs-keyword">if</span> (res)<br>        free_netdev(dev);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>br_ioctl_deviceless_stub</code> 中可以看到，添加网桥对应 <code>br_add_bridge</code>，<code>br_add_bridge</code> 主要做了下面几件事：</p><ol><li>创建 bridge device，并且通过 <code>br_dev_setup</code> 初始化该设备</li><li>设置 dev 对应的 <code>rtnl_link_ops</code> 为  <code>br_link_ops</code></li><li>调用 <code>register_netdev</code> 将网桥设备注册到系统中</li></ol><p><code>br_dev_setup</code> 用于完成内存分配之后的初始化操作，主要设置了 bridge 设备的一些字段，比如关键的 <code>dev-&gt;netdev_ops</code>，是网桥设备对上层的接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_device_ops</span> <span class="hljs-title">br_netdev_ops</span> =</span> &#123;<br>.ndo_open = br_dev_open,<br>.ndo_stop = br_dev_stop,<br>.ndo_init = br_dev_init,<br>.ndo_uninit = br_dev_uninit,<br>.ndo_start_xmit = br_dev_xmit,<br>.ndo_get_stats64 = br_get_stats64,<br>.ndo_set_mac_address = br_set_mac_address,<br>.ndo_set_rx_mode = br_dev_set_multicast_list,<br>.ndo_change_rx_flags = br_dev_change_rx_flags,<br>.ndo_change_mtu = br_change_mtu,<br>.ndo_do_ioctl = br_dev_ioctl,<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_NET_POLL_CONTROLLER</span><br>.ndo_netpoll_setup = br_netpoll_setup,<br>.ndo_netpoll_cleanup = br_netpoll_cleanup,<br>.ndo_poll_controller = br_poll_controller,<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>.ndo_add_slave = br_add_slave,<br>.ndo_del_slave = br_del_slave,<br>.ndo_fix_features        = br_fix_features,<br>.ndo_fdb_add = br_fdb_add,<br>.ndo_fdb_del = br_fdb_delete,<br>.ndo_fdb_dump = br_fdb_dump,<br>.ndo_fdb_get = br_fdb_get,<br>.ndo_bridge_getlink = br_getlink,<br>.ndo_bridge_setlink = br_setlink,<br>.ndo_bridge_dellink = br_dellink,<br>.ndo_features_check = passthru_features_check,<br>&#125;;<br></code></pre></td></tr></table></figure><p>删除设备的源码也留给读者自己研读。</p><h3 id="2-3-添加网桥-slave-设备"><a href="#2-3-添加网桥-slave-设备" class="headerlink" title="2.3 添加网桥 slave 设备"></a>2.3 添加网桥 slave 设备</h3><p>网桥设备创建完成后需要在其下面添加 slave 设备才能使网桥设备正常工作起来，主要任务在 <code>ndo_add_slave</code> 对应的 <code>br_add_slave</code> 方法中完成，调用链为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">br_netdev_ops-&gt;ndo_add_slave = br_add_slave<br>    --&gt; br_add_if<br>        --&gt; br_get_rx_handler<br>        --&gt; netdev_rx_handler_register<br></code></pre></td></tr></table></figure><p>最终来到了 <code>netdev_rx_handler_register</code> 中，将从设备的 <code>dev-&gt;rx_handler</code> 实例赋值为 <code>br_handle_frame</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">netdev_rx_handler_register</span><span class="hljs-params">(struct net_device *dev,</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">rx_handler_func_t</span> *rx_handler,</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">void</span> *rx_handler_data)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (netdev_is_rx_handler_busy(dev))<br><span class="hljs-keyword">return</span> -EBUSY;<br><br><span class="hljs-keyword">if</span> (dev-&gt;priv_flags &amp; IFF_NO_RX_HANDLER)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-comment">/* Note: rx_handler_data must be set before rx_handler */</span><br>rcu_assign_pointer(dev-&gt;rx_handler_data, rx_handler_data);<br>rcu_assign_pointer(dev-&gt;rx_handler, rx_handler);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>EXPORT_SYMBOL_GPL(netdev_rx_handler_register);<br></code></pre></td></tr></table></figure><h3 id="2-4-网桥与网络收发包路径"><a href="#2-4-网桥与网络收发包路径" class="headerlink" title="2.4 网桥与网络收发包路径"></a>2.4 网桥与网络收发包路径</h3><p>之所以强调了上一步的 <code>dev-&gt;rx_handler</code>，是因为在收包的关键处理函数 <code>__netif_receive_skb_core</code> 中，对于附加在网桥上的<strong>从属设备</strong>而言，会获取并调用 <code>skb-&gt;dev-&gt;rx_handler</code> ，也就是 <code>br_add_if</code> 时设置的 <code>br_handle_frame</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __netif_receive_skb_core(struct sk_buff **pskb, <span class="hljs-keyword">bool</span> pfmemalloc,<br>    struct packet_type **ppt_prev)<br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    rx_handler = rcu_dereference(skb-&gt;dev-&gt;rx_handler);<br><span class="hljs-keyword">if</span> (rx_handler) &#123;<br><span class="hljs-keyword">if</span> (pt_prev) &#123;<br>ret = deliver_skb(skb, pt_prev, orig_dev);<br>pt_prev = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">switch</span> (rx_handler(&amp;skb)) &#123;<br><span class="hljs-keyword">case</span> RX_HANDLER_CONSUMED:<br>ret = NET_RX_SUCCESS;<br><span class="hljs-keyword">goto</span> out;<br><span class="hljs-keyword">case</span> RX_HANDLER_ANOTHER:<br><span class="hljs-keyword">goto</span> another_round;<br><span class="hljs-keyword">case</span> RX_HANDLER_EXACT:<br>deliver_exact = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">case</span> RX_HANDLER_PASS:<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>BUG();<br>&#125;<br>&#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>反之，如果不是附加在网桥上的 net_device，就不存在 <code>dev-&gt;rx_handler</code>，也就不会经历上述流程。</p><p>接下来就探究 <code>br_handle_frame</code> 究竟做了什么。</p><p>首先通过 perf/funcgraph 等工具，可以查看 <code>br_handle_frame</code> 的调用链，大致如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs text">br_handle_frame<br>    --&gt; br_handle_frame_finish<br>        --&gt; br_forward<br>            --&gt; __br_forward<br>                --&gt; br_forward_finish<br>                    --&gt; br_dev_queue_push_xmit<br>                        --&gt; dev_queue_xmit<br><br>...<br>br_handle_frame<br>    --&gt; br_handle_frame_finish<br>        --&gt; br_flood<br>            --&gt; __br_forward<br>                --&gt; br_forward_finish<br>                    --&gt; br_dev_queue_push_xmit<br>                        --&gt; dev_queue_xmit<br>            --&gt; __br_forward<br>                --&gt; br_forward_finish<br>                    --&gt; br_dev_queue_push_xmit<br>                        --&gt; dev_queue_xmit<br>            --&gt; __br_forward<br>                --&gt; br_forward_finish<br>                    --&gt; br_dev_queue_push_xmit<br>                        --&gt; dev_queue_xmit<br><br>...<br>br_handle_frame<br>    --&gt; br_handle_frame_finish<br>        --&gt; br_pass_frame_up<br>            --&gt; br_netif_receive_skb<br>                --&gt; netif_receive_skb<br>                    --&gt; netif_receive_skb_internal<br>                        --&gt; __netif_receive_skb_list<br>                            --&gt; __netif_receive_skb_list_core<br>                                --&gt; __netif_receive_skb_core<br>                                    --&gt; <br></code></pre></td></tr></table></figure><p>在 <code>br_handle_frame_finish</code> 中，有四条处理数据包的路径，也是网桥的几个<strong>核心能力</strong>，分别是：</p><ol><li>br_forward</li><li>br_flood</li><li>br_multicast_flood</li><li>br_pass_frame_up</li></ol><p>其中最后一条路径是处理发向本地的数据包，不是发往本地的数据包，若能在 fdb 中找到对应的表项，则调用 br_forward，否则进行洪泛，通过一些标志位的判断走不通的路径。</p><h4 id="2-4-1-br-forward"><a href="#2-4-1-br-forward" class="headerlink" title="2.4.1 br_forward"></a>2.4.1 br_forward</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">br_forward</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct net_bridge_port *to,</span></span><br><span class="hljs-params"><span class="hljs-function">struct sk_buff *skb, <span class="hljs-keyword">bool</span> local_rcv, <span class="hljs-keyword">bool</span> local_orig)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (unlikely(!to))<br><span class="hljs-keyword">goto</span> out;<br><br><span class="hljs-comment">/* redirect to backup link if the destination port is down */</span><br><span class="hljs-keyword">if</span> (rcu_access_pointer(to-&gt;backup_port) &amp;&amp; !netif_carrier_ok(to-&gt;dev)) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_bridge_port</span> *<span class="hljs-title">backup_port</span>;</span><br><br>backup_port = rcu_dereference(to-&gt;backup_port);<br><span class="hljs-keyword">if</span> (unlikely(!backup_port))<br><span class="hljs-keyword">goto</span> out;<br>to = backup_port;<br>&#125;<br><br><span class="hljs-keyword">if</span> (should_deliver(to, skb)) &#123;<br><span class="hljs-keyword">if</span> (local_rcv)<br>deliver_clone(to, skb, local_orig);<br><span class="hljs-keyword">else</span><br>__br_forward(to, skb, local_orig);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>out:<br><span class="hljs-keyword">if</span> (!local_rcv)<br>kfree_skb(skb);<br>&#125;<br>EXPORT_SYMBOL_GPL(br_forward);<br></code></pre></td></tr></table></figure><p>上面仅仅是针对 <code>__br_forward</code> 的一层封装，关键点在于下面这个函数。首先需要思考：什么是转发？</p><p>转发是将数据包从一个设备发送到另一个设备，然后触发网络设备的回调函数，剩下的流程 Linux 已经为我们安排好了，因此<strong>转发</strong>最关键的操作，就是将 <code>skb-&gt;dev</code> 设置为目标设备，然后通过 <code>dev_queue_xmit</code> 交给设备驱动来处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __br_forward(<span class="hljs-keyword">const</span> struct net_bridge_port *to,<br> struct sk_buff *skb, <span class="hljs-keyword">bool</span> local_orig)<br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// !important</span><br>indev = skb-&gt;dev;<br>skb-&gt;dev = to-&gt;dev;<br>    <span class="hljs-comment">// ...</span><br><br>NF_HOOK(NFPROTO_BRIDGE, br_hook,<br>net, <span class="hljs-literal">NULL</span>, skb, indev, skb-&gt;dev,<br>br_forward_finish);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-2-br-flood"><a href="#2-4-2-br-flood" class="headerlink" title="2.4.2 br_flood"></a>2.4.2 br_flood</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">br_flood</span><span class="hljs-params">(struct net_bridge *br, struct sk_buff *skb,</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-keyword">enum</span> br_pkt_type pkt_type, <span class="hljs-keyword">bool</span> local_rcv, <span class="hljs-keyword">bool</span> local_orig)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_bridge_port</span> *<span class="hljs-title">prev</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_bridge_port</span> *<span class="hljs-title">p</span>;</span><br><br>list_for_each_entry_rcu(p, &amp;br-&gt;port_list, <span class="hljs-built_in">list</span>) &#123;<br><span class="hljs-comment">/* Do not flood unicast traffic to ports that turn it off, nor</span><br><span class="hljs-comment"> * other traffic if flood off, except for traffic we originate</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">switch</span> (pkt_type) &#123;<br><span class="hljs-keyword">case</span> BR_PKT_UNICAST:<br><span class="hljs-keyword">if</span> (!(p-&gt;flags &amp; BR_FLOOD))<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> BR_PKT_MULTICAST:<br><span class="hljs-keyword">if</span> (!(p-&gt;flags &amp; BR_MCAST_FLOOD) &amp;&amp; skb-&gt;dev != br-&gt;dev)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> BR_PKT_BROADCAST:<br><span class="hljs-keyword">if</span> (!(p-&gt;flags &amp; BR_BCAST_FLOOD) &amp;&amp; skb-&gt;dev != br-&gt;dev)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">/* Do not flood to ports that enable proxy ARP */</span><br><span class="hljs-keyword">if</span> (p-&gt;flags &amp; BR_PROXYARP)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> ((p-&gt;flags &amp; (BR_PROXYARP_WIFI | BR_NEIGH_SUPPRESS)) &amp;&amp;<br>    BR_INPUT_SKB_CB(skb)-&gt;proxyarp_replied)<br><span class="hljs-keyword">continue</span>;<br><br>prev = maybe_deliver(prev, p, skb, local_orig);<br><span class="hljs-keyword">if</span> (IS_ERR(prev))<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!prev)<br><span class="hljs-keyword">goto</span> out;<br><br><span class="hljs-keyword">if</span> (local_rcv)<br>deliver_clone(prev, skb, local_orig);<br><span class="hljs-keyword">else</span><br>__br_forward(prev, skb, local_orig);<br><span class="hljs-keyword">return</span>;<br><br>out:<br><span class="hljs-keyword">if</span> (!local_rcv)<br>kfree_skb(skb);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数也会调用 <code>__br_forward</code> 进行处理，只不过遍历了 <code>bridge-&gt;port_list</code>，依次进行转发（maybe_deliver 中也调用了 __br_forward 函数）</p><h4 id="2-4-3-br-pass-frame-up"><a href="#2-4-3-br-pass-frame-up" class="headerlink" title="2.4.3 br_pass_frame_up"></a>2.4.3 br_pass_frame_up</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">br_pass_frame_up</span><span class="hljs-params">(struct sk_buff *skb)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span> *<span class="hljs-title">indev</span>, *<span class="hljs-title">brdev</span> =</span> BR_INPUT_SKB_CB(skb)-&gt;brdev;<br><br>    <span class="hljs-comment">// ....</span><br><br>indev = skb-&gt;dev;<br>skb-&gt;dev = brdev;<br>skb = br_handle_vlan(br, <span class="hljs-literal">NULL</span>, vg, skb);<br><span class="hljs-keyword">if</span> (!skb)<br><span class="hljs-keyword">return</span> NET_RX_DROP;<br><br><span class="hljs-keyword">return</span> NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,<br>       dev_net(indev), <span class="hljs-literal">NULL</span>, skb, indev, <span class="hljs-literal">NULL</span>,<br>       br_netif_receive_skb);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后会重新调用 <code>netif_receive_skb</code> ，但此时 skb-&gt;dev 已经替换为网桥设备，网桥上没有注册rx_handler，因此不会再次进入 <code>br_handle_frame</code>，而是会调用 ptype 协议链上对应的协议处理函数进入上层处理</p><h3 id="2-5-fdb"><a href="#2-5-fdb" class="headerlink" title="2.5 fdb"></a>2.5 fdb</h3><p>fdb 全称为 forwarding database，也就是维护 MAC 地址到设备端口之间的映射数据表。用于辅助 forward，flood，multicast 等核心功能。</p><p>别看它名字很高大上，其实原理非常简答，就是通过增删改查操作维护这张映射表，同时通过一些过期策略维护数据的时效性。这里不多赘述。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>network</category>
      
      <category>docker</category>
      
      <category>bridge</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>veth</title>
    <link href="/2022/02/13/linux/network/veth/"/>
    <url>/2022/02/13/linux/network/veth/</url>
    
    <content type="html"><![CDATA[<h2 id="1-veth-是什么"><a href="#1-veth-是什么" class="headerlink" title="1. veth 是什么"></a>1. veth 是什么</h2><p>veth ，又名虚拟网络设备对，主要是用于解决不同网络命名空间之间的通信。</p><p>说起网络名称空间（network namespace），大家应该都不陌生，这是 Linux 用来隔离容器网络环境的一项技术，主要隔离的资源有：</p><ol><li>iptables</li><li>路由规则表</li><li>网络设备列表</li></ol><p>虽然不同 namespace 之间是隔离的，但也有办法让它们之间完成通信，veth 就是其中的一种比较常见的解决方式。</p><p>可以将 veth 看成是两块通过网线连接的网卡，只要将其中之一放置到网络命名空间 A，另一个放置到网络命名空间 B，那么两个不同的网络命名空间就能够通信。</p><p>众所周知，网线是一个冷酷无情的传输设备，从一端发送的数据会沿着线路传输到另一端，交付给另一端的设备，这一切是由硬件来完成的，不需要我们去干预，不过对于 veth 这种软件模拟的方式来说，就需要动一番脑子了。</p><p>常用的 veth 的使用方式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一对 veth</span><br>ip link add veth0 <span class="hljs-built_in">type</span> veth peer name veth1<br><span class="hljs-comment"># 启动设备</span><br>ip link <span class="hljs-built_in">set</span> dev veth0 up<br>ip link <span class="hljs-built_in">set</span> dev veth1 up<br><span class="hljs-comment"># 设置 namespace</span><br>ip link <span class="hljs-built_in">set</span> veth0 netns netns0<br>ip link <span class="hljs-built_in">set</span> veth1 netns netns1<br><span class="hljs-comment"># 设置 veth0/1 的 ip</span><br>ip netns <span class="hljs-built_in">exec</span> ns0 ip a a 10.1.1.2/24 dev veth0<br>ip netns <span class="hljs-built_in">exec</span> ns1 ip a a 10.1.1.3/24 dev veth1<br><span class="hljs-comment"># ping 测试</span><br>ip netns <span class="hljs-built_in">exec</span> ns0 ping -I veth0 10.1.1.3<br></code></pre></td></tr></table></figure><p><img src="/images/sysnet-veth.png" alt="communicate between network namespaces through veth"></p><h2 id="2-veth-internal"><a href="#2-veth-internal" class="headerlink" title="2. veth internal"></a>2. veth internal</h2><p>下面分别从 创建，初始化，发送数据 三个角度来剖析 veth 源码。</p><h3 id="2-1-创建-veth-pair"><a href="#2-1-创建-veth-pair" class="headerlink" title="2.1 创建 veth pair"></a>2.1 创建 veth pair</h3><p>使用 ip 命令创建一对 veth 时，会通过 netlink 触发 <code>rtnl_link_ops.newlink</code> 回调函数，如果感兴趣，可以看我的另一篇文章 <a href="/2022/02/22/linux/network/netlink/" title="[netlink 机制]">[netlink 机制]</a> ，对应 <code>veth_newlink</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">veth_newlink</span><span class="hljs-params">(struct net *src_net, struct net_device *dev,</span></span><br><span class="hljs-params"><span class="hljs-function">            struct nlattr *tb[], struct nlattr *data[],</span></span><br><span class="hljs-params"><span class="hljs-function">            struct netlink_ext_ack *extack)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 首先设置和注册 peer</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">// ...</span><br><br>    net = rtnl_link_get_net(src_net, tbp);<br>    <span class="hljs-keyword">if</span> (IS_ERR(net))<br>        <span class="hljs-keyword">return</span> PTR_ERR(net);<br><br>    peer = rtnl_create_link(net, ifname, name_assign_type,<br>                &amp;veth_link_ops, tbp, extack);<br>    <br>    <span class="hljs-comment">// ...</span><br><br>    err = register_netdevice(peer);<br>    put_net(net);<br>    net = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> err_register_peer;<br><br>    netif_carrier_off(peer);<br><br>    err = rtnl_configure_link(peer, ifmp);<br>    <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> err_configure_peer;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 之后注册 dev</span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-comment">//...</span><br><br>    err = register_netdevice(dev);<br><br>    netif_carrier_off(dev);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 关联 dev 和 peer</span><br><span class="hljs-comment">     */</span><br><br>    priv = netdev_priv(dev);<br>    rcu_assign_pointer(priv-&gt;peer, peer);<br><br>    priv = netdev_priv(peer);<br>    rcu_assign_pointer(priv-&gt;peer, dev);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 错误处理 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>veth 由两个设备组成，其中 dev 在调用 <code>veth_newlink</code> 之前已经创建完成了，接下来首先需要通过 <code>rtnl_create_link</code> 创建另一个设备 peer，并通过 <code>register_netdevice</code> 分别将 peer 和 dev 注册到系统的 netdevice 列表当中</p><p>下一步是 veth 的核心：通过 priv 字段关联 dev 和 peer，即 <code>rcu_assign_pointer(priv-&gt;peer, peer)</code> 和 <code>rcu_assign_pointer(priv-&gt;peer, dev)</code></p><p>这里有必要解释一下 <code>net_device</code> 的结构，以及 <code>netdev_priv</code> 的作用</p><p>Kernel 使用 <code>net_device</code> 来对网络设备进行抽象，但是不同厂商的设备规格有一定差别，所以 net_device 结构体采用了<strong>面向对象</strong>的思想，不仅有所有设备共有的结构（基类），还保留了私有数据的存储空间（子类），私有结构一般保存在 net_device 对象结束之后的位置（不难从 <code>netdev_priv</code> 中的 <code>sizeof(struct net_device</code> 得到证实），从而可以轻松使用强制类型转换分别获取到父类和子类，示意图如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text"><br>|------------|\<br>| net_device | \<br>|            | / sizeof net_device<br>|------------|/<br>|------------|\<br>| xx_private | \<br>|            | / sizeof private struct<br>|------------|/<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">netdev_priv</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct net_device *dev)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">char</span> *)dev + ALIGN(<span class="hljs-keyword">sizeof</span>(struct net_device), NETDEV_ALIGN);<br>&#125;<br></code></pre></td></tr></table></figure><p>而对于 veth 来说，这个 private 字段就是 <code>struct veth_priv</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">veth_priv</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span> __<span class="hljs-title">rcu</span>    *<span class="hljs-title">peer</span>;</span><br>    <span class="hljs-keyword">atomic64_t</span>        dropped;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_prog</span>        *_<span class="hljs-title">xdp_prog</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">veth_rq</span>        *<span class="hljs-title">rq</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>        requested_headroom;<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过私有结构中的 peer 字段就能关联另一个 <code>net_device</code>，这下你应该理解了 veth <strong>pair</strong> 是如何成双结对的了。</p><h3 id="2-2-初始化-veth"><a href="#2-2-初始化-veth" class="headerlink" title="2.2 初始化 veth"></a>2.2 初始化 veth</h3><p>创建好 veth 之后，还需要通过 <code>rtnl_link_ops.setup</code> 进行初始化才能使用，对应 <code>veth_setup</code></p><p>该函数中主要设置了 veth 对应 net_device 的一些字段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">veth_setup</span><span class="hljs-params">(struct net_device *dev)</span></span><br><span class="hljs-function"></span>&#123;<br>    ether_setup(dev);<br>    dev-&gt;netdev_ops = &amp;veth_netdev_ops;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>最重要的是通过 <code>dev-&gt;netdev_ops = &amp;veth_netdev_ops;</code> 设置了收发包的处理函数，典型的 Linux 回调设计模式。</p><p>在 veth <strong>模块</strong>的初始化操作中，还将 veth_netdev_ops 注册到了 rtnetlink 中，从而可以通过 netlink 向外提供服务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> __init <span class="hljs-keyword">int</span> <span class="hljs-title">veth_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> rtnl_link_register(&amp;veth_link_ops);<br>&#125;<br></code></pre></td></tr></table></figure><p>像 <code>ip link add veth0 type veth peer name veth1</code> 这些和 veth 相关的网络命令，都会通过 netlink socket，最终交由 veth_link_ops 中的回调函数处理。</p><h3 id="2-3-发送数据"><a href="#2-3-发送数据" class="headerlink" title="2.3 发送数据"></a>2.3 发送数据</h3><p>在驱动层，内核通过 <code>netdev_ops-&gt;ndo_start_xmit</code> 发送数据包，前面说到，<code>veth_setup</code> 函数中已经将 netdev_ops 设置为 <code>veth_netdev_ops</code>，其中 <code>ndo_start_xmit</code> 对应下面的 <code>veth_xmit</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">netdev_tx_t</span> <span class="hljs-title">veth_xmit</span><span class="hljs-params">(struct sk_buff *skb, struct net_device *dev)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">veth_priv</span> *<span class="hljs-title">rcv_priv</span>, *<span class="hljs-title">priv</span> =</span> netdev_priv(dev);<br>    rcu_read_lock();<br>    rcv = rcu_dereference(priv-&gt;peer);<br>    <br>    <span class="hljs-keyword">if</span> (likely(veth_forward_skb(rcv, skb, rq, rcv_xdp) == NET_RX_SUCCESS)) &#123;<br>        <span class="hljs-keyword">if</span> (!rcv_xdp)<br>            dev_lstats_add(dev, length);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>drop:<br>        atomic64_inc(&amp;priv-&gt;dropped);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (rcv_xdp)<br>        __veth_xdp_flush(rq);<br><br>    rcu_read_unlock();<br><br>    <span class="hljs-keyword">return</span> NETDEV_TX_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>来看该函数的逻辑：首先获取到了 <code>veth_priv</code> 结构中的 peer，也就是 veth 的对端虚拟网络设备，接下来调用 <code>veth_forward_skb</code>，将数据包转发到 peer 上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">veth_forward_skb</span><span class="hljs-params">(struct net_device *dev, struct sk_buff *skb,</span></span><br><span class="hljs-params"><span class="hljs-function">                struct veth_rq *rq, <span class="hljs-keyword">bool</span> xdp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> __dev_forward_skb(dev, skb) ?: xdp ?<br>        veth_xdp_rx(rq, skb) :<br>        netif_rx(skb);<br>&#125;<br></code></pre></td></tr></table></figure><p>其实，无论什么时候，将数据包从网络层发送到网络设备上，最重要的都是设置 skb 对应的 net_device，从而调用对应的 <code>net_device_ops-&gt;ndo_start_xmit</code>。veth 数据包既然要发送到另一端的设备上，只需要将 skb-&gt;dev 设置为 peer 即可，之后便可以走正常的网络包接收路径 <code>netif_rx</code>。</p><p><code>netif_rx</code> 操作中，主要是将数据包放置到了 <code>backlog</code> 队列中，触发自底向上的收包流程，从这里开始，便与物理网络设备无异了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">netif_rx_internal</span><span class="hljs-params">(struct sk_buff *skb)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// ...</span><br>    ret = enqueue_to_backlog(skb, get_cpu(), &amp;qtail);<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>很有意思的一点是，从 veth_xmit 这个发送数据包的路径，转移到了 netif_rx_internal 这个接收数据包的路径，利用好 veth 这个特点，可以完成很多有趣的事情。比如 docker 中的桥接模式，就是非常典型的应用。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>network</category>
      
      <category>namespace</category>
      
      <category>veth</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/02/13/linux/network/network_system/"/>
    <url>/2022/02/13/linux/network/network_system/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>do_execve 源码解析</title>
    <link href="/2022/02/12/linux/execve/"/>
    <url>/2022/02/12/linux/execve/</url>
    
    <content type="html"><![CDATA[<p>大家都知道，Linux 下面的可执行文件格式为 elf ，全称是 executable linkable format，中文名为“可执行可链接文件”，这种文件是以二进制的方式存储的，我们也可以将其称为二进制对象（binary object）。</p><p>以 gcc 为例，最终需要将很多 ‘.c’ 文件编译为一个 elf 格式的可执行文件，最终才能在 Linux 上运行，那么问题来了，Linux 是如何识别 elf 这种格式，又是如何将其和<strong>进程</strong>结合在一起的呢？接下来我们来研究研究。</p><h2 id="1-do-execv"><a href="#1-do-execv" class="headerlink" title="1. do_execv"></a>1. do_execv</h2><h3 id="1-1-strace-大法好"><a href="#1-1-strace-大法好" class="headerlink" title="1.1 strace 大法好"></a>1.1 strace 大法好</h3><p>以 shell 为例，只需要指定路径+参数，系统就能执行这个程序了，但这背后就是一个黑箱，摸不着也猜不透，那有什么办法可以一窥究竟呢？strace！</p><p>strace 是追踪系统调用的利器，只有明确了你想要的功能是通过哪个系统调用暴露出去的，才不至于在查阅源码的时候像一个无头苍蝇。</p><p>通过 <code>strace ls</code> 这条指令，得到了下面的输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs text">execve(&quot;/usr/bin/ls&quot;, [&quot;ls&quot;], 0x7ffd2dbd43d0 /* 40 vars */) = 0<br>......<br></code></pre></td></tr></table></figure><p>最关键的信息是 <code>execve()</code>，对应的系统调用为 sys_execve，这就是执行程序的第一步：将可执行程序的<code>路径+参数</code>传递给 sys_execve 系统调用</p><p>其实在这之前，shell 也为我们做了很多准备工作：</p><ol><li>读取并且解析命令</li><li>读取 shell 的环境变量</li><li>读取 <code>.bashrc/.zshrc</code> 等配置文件</li><li>依次在 <code>PATH</code> 环境变量表示的路径中，查找是否有对应的可执行文件（shell 的内置指令不予讨论）</li></ol><p>最终才会调用 <code>execve(command, args, env);</code> 这个系统调用</p><h3 id="1-2-sys-execve"><a href="#1-2-sys-execve" class="headerlink" title="1.2 sys_execve"></a>1.2 sys_execve</h3><p><code>sys_execve</code> 接收三个参数，其含义还是非常清晰的，分别是：可执行程序路径，参数，环境变量</p><p><code>sys_execve</code> 最终调用了 <code>do_execveat_common</code> 这个核心处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fs/exec.c</span><br>SYSCALL_DEFINE3(execve,<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *, filename,<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *<span class="hljs-keyword">const</span> __user *, argv,<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *<span class="hljs-keyword">const</span> __user *, envp)<br>&#123;<br>    <span class="hljs-keyword">return</span> do_execve(getname(filename), argv, envp);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">do_execve</span><span class="hljs-params">(struct filename *filename,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *<span class="hljs-keyword">const</span> __user *__argv,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *<span class="hljs-keyword">const</span> __user *__envp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_arg_ptr</span> <span class="hljs-title">argv</span> =</span> &#123; .ptr.native = __argv &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_arg_ptr</span> <span class="hljs-title">envp</span> =</span> &#123; .ptr.native = __envp &#125;;<br>    <span class="hljs-keyword">return</span> do_execveat_common(AT_FDCWD, filename, argv, envp, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-do-execveat-common"><a href="#1-3-do-execveat-common" class="headerlink" title="1.3 do_execveat_common"></a>1.3 do_execveat_common</h3><p><code>do_execveat_common</code> 中，还是做了一些准备工作，比如验证 rlimit 是否超出上限，argv 和 envp 是否超出上限，stack 是否超出上限。</p><p>一系列检查无误之后，就将参数从用户空间拷贝到内核空间，将父进程的一些环境变量拷贝过来，并且执行 <code>bprm_execve</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">do_execveat_common</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct filename *filename,</span></span><br><span class="hljs-params"><span class="hljs-function">                  struct user_arg_ptr argv,</span></span><br><span class="hljs-params"><span class="hljs-function">                  struct user_arg_ptr envp,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-keyword">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linux_binprm</span> *<span class="hljs-title">bprm</span>;</span><br>    <span class="hljs-keyword">int</span> retval;<br><br>    <span class="hljs-keyword">if</span> (IS_ERR(filename))<br>        <span class="hljs-keyword">return</span> PTR_ERR(filename);<br><br>    <span class="hljs-comment">// 1. 检查 rlimit 是否超出上限</span><br>    <span class="hljs-keyword">if</span> ((current-&gt;flags &amp; PF_NPROC_EXCEEDED) &amp;&amp;<br>        atomic_read(&amp;current_user()-&gt;processes) &gt; rlimit(RLIMIT_NPROC)) &#123;<br>        retval = -EAGAIN;<br>        <span class="hljs-keyword">goto</span> out_ret;<br>    &#125;<br><br>    current-&gt;flags &amp;= ~PF_NPROC_EXCEEDED;<br><br>    <span class="hljs-comment">// 2. 分配 binary program 结构体</span><br>    bprm = alloc_bprm(fd, filename);<br>    <span class="hljs-keyword">if</span> (IS_ERR(bprm)) &#123;<br>        retval = PTR_ERR(bprm);<br>        <span class="hljs-keyword">goto</span> out_ret;<br>    &#125;<br><br>    <span class="hljs-comment">// 3. argv 和 envp 不能超出上限(其实没有意义)</span><br>    <span class="hljs-comment">// #define MAX_ARG_STRINGS 0x7FFFFFFF</span><br>    retval = count(argv, MAX_ARG_STRINGS);<br>    <span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> out_free;<br>    bprm-&gt;argc = retval;<br><br>    retval = count(envp, MAX_ARG_STRINGS);<br>    <span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> out_free;<br>    bprm-&gt;envc = retval;<br><br>    <span class="hljs-comment">// 4. 还是通过 rlimit 检查 stack 是否超出上限</span><br>    retval = bprm_stack_limits(bprm);<br>    <span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> out_free;<br><br>    <span class="hljs-comment">// 5. 将 参数/环境变量 从内核空间拷贝到用户空间</span><br>    retval = copy_string_kernel(bprm-&gt;filename, bprm);<br>    <span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> out_free;<br>    bprm-&gt;exec = bprm-&gt;p;<br><br>    <span class="hljs-comment">// 6. 将原先进程的 参数/环境变量 拷贝到新的进程</span><br>    retval = copy_strings(bprm-&gt;envc, envp, bprm);<br>    <span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> out_free;<br><br>    retval = copy_strings(bprm-&gt;argc, argv, bprm);<br>    <span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> out_free;<br><br>    <span class="hljs-comment">// 7. 执行 binary program</span><br>    retval = bprm_execve(bprm, fd, filename, flags);<br>out_free:<br>    free_bprm(bprm);<br><br>out_ret:<br>    putname(filename);<br>    <span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-bprm-execve"><a href="#1-4-bprm-execve" class="headerlink" title="1.4 bprm_execve"></a>1.4 bprm_execve</h3><p>到了 <code>bprm_execve</code> 就需要做一些真正有空的操作了，比如：检查 credentials，打开可执行程序文件，检查路径正确性。然后会跳转到 <code>exec_binprm</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bprm_execve</span><span class="hljs-params">(struct linux_binprm *bprm,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-keyword">int</span> fd, struct filename *filename, <span class="hljs-keyword">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> *<span class="hljs-title">displaced</span>;</span><br>    <span class="hljs-keyword">int</span> retval;<br><br>    <span class="hljs-comment">// 1. 取消任何跨越 execve 的 io_uring task</span><br>    io_uring_task_cancel();<br><br>    <span class="hljs-comment">// 2. 设置文件描述符不共享</span><br>    retval = unshare_files(&amp;displaced);<br>    <span class="hljs-keyword">if</span> (retval)<br>        <span class="hljs-keyword">return</span> retval;<br><br>    <span class="hljs-comment">// 3. 检查 binary program 的凭据</span><br>    retval = prepare_bprm_creds(bprm);<br>    <span class="hljs-keyword">if</span> (retval)<br>        <span class="hljs-keyword">goto</span> out_files;<br><br>    check_unsafe_exec(bprm);<br>    current-&gt;in_execve = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 4. 打开文件</span><br>    file = do_open_execat(fd, filename, flags);<br>    retval = PTR_ERR(file);<br>    <span class="hljs-keyword">if</span> (IS_ERR(file))<br>        <span class="hljs-keyword">goto</span> out_unmark;<br><br>    sched_exec();<br><br>    <span class="hljs-comment">// 5. 检查路径是否正确</span><br>    bprm-&gt;file = file;<br>    <span class="hljs-keyword">if</span> (bprm-&gt;fdpath &amp;&amp;<br>        close_on_exec(fd, rcu_dereference_raw(current-&gt;files-&gt;fdt)))<br>        bprm-&gt;interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;<br><br>    <span class="hljs-comment">// 6. 检查 security</span><br>    retval = security_bprm_creds_for_exec(bprm);<br>    <span class="hljs-keyword">if</span> (retval)<br>        <span class="hljs-keyword">goto</span> out;<br><br>    <span class="hljs-comment">// 7. 执行 binary program</span><br>    retval = exec_binprm(bprm);<br>    <span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> out;<br><br>    <span class="hljs-comment">// 8. 执行成功，释放资源</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5-exec-binprm"><a href="#1-5-exec-binprm" class="headerlink" title="1.5 exec_binprm"></a>1.5 exec_binprm</h3><p><code>exec_binprm</code> 中有一个非常重要的循环，在循环当中，调用了 <code>search_binary_handler</code></p><p>往下看就知道</p><p>看到这里你应该会有一个疑问：什么叫 binary handler？下面会详细解释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">exec_binprm</span><span class="hljs-params">(struct linux_binprm *bprm)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> old_pid, old_vpid;<br>    <span class="hljs-keyword">int</span> ret, depth;<br><br>    <span class="hljs-comment">// 1. 获取旧的 pid</span><br>    old_pid = current-&gt;pid;<br>    rcu_read_lock();<br>    old_vpid = task_pid_nr_ns(current, task_active_pid_ns(current-&gt;parent));<br>    rcu_read_unlock();<br><br>    <span class="hljs-comment">// 2. 允许最多4层的 binary format 改写</span><br>    <span class="hljs-keyword">for</span> (depth = <span class="hljs-number">0</span>;; depth++) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">exec</span>;</span><br>        <span class="hljs-keyword">if</span> (depth &gt; <span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">return</span> -ELOOP;<br><br>        <span class="hljs-comment">// 2.1 查找 binary handler，并且通过 binary handler 来执行文件</span><br>        ret = search_binary_handler(bprm);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> ret;<br>        <span class="hljs-keyword">if</span> (!bprm-&gt;interpreter)<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">// 2.2 成功找到 interpreter</span><br>        exec = bprm-&gt;file;<br>        bprm-&gt;file = bprm-&gt;interpreter;<br>        bprm-&gt;interpreter = <span class="hljs-literal">NULL</span>;<br><br>        allow_write_access(exec);<br>        <span class="hljs-keyword">if</span> (unlikely(bprm-&gt;have_execfd)) &#123;<br>            <span class="hljs-keyword">if</span> (bprm-&gt;executable) &#123;<br>                fput(exec);<br>                <span class="hljs-keyword">return</span> -ENOEXEC;<br>            &#125;<br>            bprm-&gt;executable = exec;<br>        &#125; <span class="hljs-keyword">else</span><br>            fput(exec);<br>    &#125;<br><br>    audit_bprm(bprm);<br>    trace_sched_process_exec(current, old_pid, bprm);<br>    ptrace_event(PTRACE_EVENT_EXEC, old_vpid);<br>    proc_exec_connector(current);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-search-binary-handler"><a href="#2-search-binary-handler" class="headerlink" title="2. search_binary_handler"></a>2. search_binary_handler</h2><p>众所周知，Linux 中策略和机制分离。换句话说，Linux 提供框架，而具体的机制由开发者来决定（当然也经常会提供默认的机制），binary handler 就是一个很鲜明的例子</p><p>虽然绝大多数的可执行程序格式为 elf，但还有各种各样的脚本啊，还有比较旧的可执行格式需要兼容，甚至可能还有更加现代化的格式…… 每一种格式的文件，都可以制定自己的执行机制（也就是各种回调函数）</p><p>再来看 <code>search_binary_handler</code> 就不难理解了：查找并执行对应格式的处理函数（binary handler）。</p><p>自然，遍历注册到系统中的 <code>binary format</code> 链表是最常见，也是最容易实现的方式。依次判定是否符合该格式，如果符合，就可以调用其特定的 <code>load_binary</code> 回调函数进行加载，如果所有格式的无法识别，本次 execve 也就失败了</p><p>Linux 支持下面的 binary format：</p><ol><li>binfmt_script - 支持需要解释器执行的脚本，文件以 “#!” 开头</li><li>binfmt_misc - 根据内核的运行时配置，支持不同的二进制格式</li><li>binfmt_elf - 支持 elf 格式</li><li>binfmt_aout - 支持 a.out 格式</li><li>binfmt_flat - 支持 flat 格式</li><li>binfmt_elf_fdpic - 支持 elf FDPIC 格式;</li><li>binfmt_em86 - 支持在 Alpha 架构上运行 intel 的 elf 二进制文件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search_binary_handler</span><span class="hljs-params">(struct linux_binprm *bprm)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">bool</span> need_retry = IS_ENABLED(CONFIG_MODULES);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linux_binfmt</span> *<span class="hljs-title">fmt</span>;</span><br>    <span class="hljs-keyword">int</span> retval;<br><br>    retval = prepare_binprm(bprm);<br>    <span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> retval;<br><br>    retval = security_bprm_check(bprm);<br>    <span class="hljs-keyword">if</span> (retval)<br>        <span class="hljs-keyword">return</span> retval;<br><br>    retval = -ENOENT;<br> retry:<br><br>    <span class="hljs-comment">// 遍历 binary format 链表，查找并调用相应的 load_binary 处理函数</span><br>    read_lock(&amp;binfmt_lock);<br>    list_for_each_entry(fmt, &amp;formats, lh) &#123;<br>        <span class="hljs-keyword">if</span> (!try_module_get(fmt-&gt;<span class="hljs-keyword">module</span>))<br>            <span class="hljs-keyword">continue</span>;<br>        read_unlock(&amp;binfmt_lock);<br><br>        retval = fmt-&gt;load_binary(bprm);<br><br>        read_lock(&amp;binfmt_lock);<br>        put_binfmt(fmt);<br>        <span class="hljs-keyword">if</span> (bprm-&gt;point_of_no_return || (retval != -ENOEXEC)) &#123;<br>            read_unlock(&amp;binfmt_lock);<br>            <span class="hljs-keyword">return</span> retval;<br>        &#125;<br>    &#125;<br>    read_unlock(&amp;binfmt_lock);<br><br>    <span class="hljs-keyword">if</span> (need_retry) &#123;<br>        <span class="hljs-keyword">if</span> (printable(bprm-&gt;buf[<span class="hljs-number">0</span>]) &amp;&amp; printable(bprm-&gt;buf[<span class="hljs-number">1</span>]) &amp;&amp;<br>            printable(bprm-&gt;buf[<span class="hljs-number">2</span>]) &amp;&amp; printable(bprm-&gt;buf[<span class="hljs-number">3</span>]))<br>            <span class="hljs-keyword">return</span> retval;<br>        <span class="hljs-keyword">if</span> (request_module(<span class="hljs-string">&quot;binfmt-%04x&quot;</span>, *(ushort *)(bprm-&gt;buf + <span class="hljs-number">2</span>)) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> retval;<br>        need_retry = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">goto</span> retry;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们需要关注两点：</p><ol><li>如何匹配可执行文件格式</li><li>如何载入可执行文件</li></ol><p>其实，Linux 中将这两个步骤合并到了 <code>load_binary</code> 中，若 load_binary 返回 <code>-ENOEXEC</code>，表明格式不匹配，就遍历剩下的可执行文件格式，如果格式匹配，就可以完成剩下的载入工作。</p><h3 id="2-1-load-binary"><a href="#2-1-load-binary" class="headerlink" title="2.1 load_binary"></a>2.1 load_binary</h3><p>有两种最为大家熟知的执行文件的方式：</p><ol><li>由 gcc 这样的编译器直接编译为 elf 格式的文件</li><li>在文件开头添加 <code>#! /bin/bash</code> 或者 <code>#! /usr/bin/python3</code> 的脚本</li></ol><p>后者对应 <code>load_script</code>，比较简单，就当作大餐前的小点心了</p><p>该函数中，首先是比较 bprm-&gt;buf 的开头两个字母是否为 <code>#!</code>，如果匹配成功，表明这是一个脚本，需要找到对应的解释器来执行，具体哪个解释器呢？就需要后面的 <code>/bin/bash</code> 或者 <code>/usr/bin/python3</code> 来指定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">load_script</span><span class="hljs-params">(struct linux_binprm *bprm)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *i_name, *i_sep, *i_arg, *i_end, *buf_end;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>    <span class="hljs-keyword">int</span> retval;<br><br>    <span class="hljs-comment">/* Not ours to exec if we don&#x27;t start with &quot;#!&quot;. */</span><br>    <span class="hljs-keyword">if</span> ((bprm-&gt;buf[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;#&#x27;</span>) || (bprm-&gt;buf[<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;!&#x27;</span>))<br>        <span class="hljs-keyword">return</span> -ENOEXEC;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>值得注意的是，在解释器的路径之后，还可以跟上对应的参数，load_script 函数都会解析出来，例如：<code>#! /usr/bin/env python3</code></p><h3 id="2-2-load-elf-binary"><a href="#2-2-load-elf-binary" class="headerlink" title="2.2 load_elf_binary"></a>2.2 load_elf_binary</h3><p>接下来是我们的重头戏：load_elf_binary</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">load_elf_binary</span><span class="hljs-params">(struct linux_binprm *bprm)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 1. 初始化参数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">interpreter</span> =</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* to shut gcc up */</span><br>     <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> load_addr = <span class="hljs-number">0</span>, load_bias = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> load_addr_set = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> error;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf_phdr</span> *<span class="hljs-title">elf_ppnt</span>, *<span class="hljs-title">elf_phdata</span>, *<span class="hljs-title">interp_elf_phdata</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf_phdr</span> *<span class="hljs-title">elf_property_phdata</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> elf_bss, elf_brk;<br>    <span class="hljs-keyword">int</span> bss_prot = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> retval, i;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> elf_entry;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> e_entry;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> interp_load_addr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> start_code, end_code, start_data, end_data;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> reloc_func_desc __maybe_unused = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> executable_stack = EXSTACK_DEFAULT;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elfhdr</span> *<span class="hljs-title">elf_ex</span> =</span> (struct elfhdr *)bprm-&gt;buf;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elfhdr</span> *<span class="hljs-title">interp_elf_ex</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">arch_elf_state</span> <span class="hljs-title">arch_state</span> =</span> INIT_ARCH_ELF_STATE;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pt_regs</span> *<span class="hljs-title">regs</span>;</span><br><br>    retval = -ENOEXEC;<br>    <span class="hljs-comment">/* 比较文件头的前四个字节，查看是否为 elf 魔数 */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(elf_ex-&gt;e_ident, ELFMAG, SELFMAG) != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> out;<br><br>    <span class="hljs-keyword">if</span> (elf_ex-&gt;e_type != ET_EXEC &amp;&amp; elf_ex-&gt;e_type != ET_DYN)<br>        <span class="hljs-keyword">goto</span> out;<br>    <span class="hljs-keyword">if</span> (!elf_check_arch(elf_ex))<br>        <span class="hljs-keyword">goto</span> out;<br>    <span class="hljs-keyword">if</span> (elf_check_fdpic(elf_ex))<br>        <span class="hljs-keyword">goto</span> out;<br>    <span class="hljs-keyword">if</span> (!bprm-&gt;file-&gt;f_op-&gt;mmap)<br>        <span class="hljs-keyword">goto</span> out;<br><br>    <span class="hljs-comment">// 2. 加载程序头表，通过 kernel_read 读入整个 program header table</span><br>    elf_phdata = load_elf_phdrs(elf_ex, bprm-&gt;file);<br>    <span class="hljs-keyword">if</span> (!elf_phdata)<br>        <span class="hljs-keyword">goto</span> out;<br><br>    elf_ppnt = elf_phdata;<br><br>    <span class="hljs-comment">// 3. 寻找和处理 .interpreter 段</span><br>    <span class="hljs-comment">// 解释器段的类型为 PT_INTERP，找到之后读入缓冲区</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; elf_ex-&gt;e_phnum; i++, elf_ppnt++) &#123;<br>        <span class="hljs-keyword">char</span> *elf_interpreter;<br><br>        <span class="hljs-keyword">if</span> (elf_ppnt-&gt;p_type == PT_GNU_PROPERTY) &#123;<br>            elf_property_phdata = elf_ppnt;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (elf_ppnt-&gt;p_type != PT_INTERP)<br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * This is the program interpreter used for shared libraries -</span><br><span class="hljs-comment">         * for now assume that this is an a.out format binary.</span><br><span class="hljs-comment">         */</span><br>        retval = -ENOEXEC;<br>        <span class="hljs-keyword">if</span> (elf_ppnt-&gt;p_filesz &gt; PATH_MAX || elf_ppnt-&gt;p_filesz &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">goto</span> out_free_ph;<br><br>        retval = -ENOMEM;<br>        elf_interpreter = kmalloc(elf_ppnt-&gt;p_filesz, GFP_KERNEL);<br>        <span class="hljs-keyword">if</span> (!elf_interpreter)<br>            <span class="hljs-keyword">goto</span> out_free_ph;<br><br>        <span class="hljs-comment">// 解释器段其实只是一个字符串，内容为解释器的文件绝对路径</span><br>        retval = elf_read(bprm-&gt;file, elf_interpreter, elf_ppnt-&gt;p_filesz,<br>                  elf_ppnt-&gt;p_offset);<br>        <span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">goto</span> out_free_interp;<br>        <span class="hljs-comment">/* make sure path is NULL terminated */</span><br>        retval = -ENOEXEC;<br>        <span class="hljs-keyword">if</span> (elf_interpreter[elf_ppnt-&gt;p_filesz - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>            <span class="hljs-keyword">goto</span> out_free_interp;<br><br>        <span class="hljs-comment">// 有了解释器的路径之后，就可以打开这个文件</span><br>        interpreter = open_exec(elf_interpreter);<br>        kfree(elf_interpreter);<br>        retval = PTR_ERR(interpreter);<br>        <span class="hljs-keyword">if</span> (IS_ERR(interpreter))<br>            <span class="hljs-keyword">goto</span> out_free_ph;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * If the binary is not readable then enforce mm-&gt;dumpable = 0</span><br><span class="hljs-comment">         * regardless of the interpreter&#x27;s permissions.</span><br><span class="hljs-comment">         */</span><br>        would_dump(bprm, interpreter);<br><br>        interp_elf_ex = kmalloc(<span class="hljs-keyword">sizeof</span>(*interp_elf_ex), GFP_KERNEL);<br>        <span class="hljs-keyword">if</span> (!interp_elf_ex) &#123;<br>            retval = -ENOMEM;<br>            <span class="hljs-keyword">goto</span> out_free_ph;<br>        &#125;<br><br>        <span class="hljs-comment">// 通过 kernel_read 读入 interpreter 的头部</span><br>        retval = elf_read(interpreter, interp_elf_ex,<br>                  <span class="hljs-keyword">sizeof</span>(*interp_elf_ex), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">goto</span> out_free_dentry;<br><br>        <span class="hljs-keyword">break</span>;<br><br>out_free_interp:<br>        kfree(elf_interpreter);<br>        <span class="hljs-keyword">goto</span> out_free_ph;<br>    &#125;<br><br>    elf_ppnt = elf_phdata;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; elf_ex-&gt;e_phnum; i++, elf_ppnt++)<br>        <span class="hljs-keyword">switch</span> (elf_ppnt-&gt;p_type) &#123;<br>        <span class="hljs-keyword">case</span> PT_GNU_STACK:<br>            <span class="hljs-keyword">if</span> (elf_ppnt-&gt;p_flags &amp; PF_X)<br>                executable_stack = EXSTACK_ENABLE_X;<br>            <span class="hljs-keyword">else</span><br>                executable_stack = EXSTACK_DISABLE_X;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> PT_LOPROC ... PT_HIPROC:<br>            retval = arch_elf_pt_proc(elf_ex, elf_ppnt,<br>                          bprm-&gt;file, <span class="hljs-literal">false</span>,<br>                          &amp;arch_state);<br>            <span class="hljs-keyword">if</span> (retval)<br>                <span class="hljs-keyword">goto</span> out_free_dentry;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>    <span class="hljs-comment">// 4. 检查并读取解释器的 program header table</span><br>    <span class="hljs-keyword">if</span> (interpreter) &#123;<br>        retval = -ELIBBAD;<br>        <span class="hljs-comment">/* Not an ELF interpreter */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(interp_elf_ex-&gt;e_ident, ELFMAG, SELFMAG) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">goto</span> out_free_dentry;<br>        <span class="hljs-comment">/* Verify the interpreter has a valid arch */</span><br>        <span class="hljs-keyword">if</span> (!elf_check_arch(interp_elf_ex) ||<br>            elf_check_fdpic(interp_elf_ex))<br>            <span class="hljs-keyword">goto</span> out_free_dentry;<br><br>        <span class="hljs-comment">// 载入 interpreter program headers</span><br>        interp_elf_phdata = load_elf_phdrs(interp_elf_ex,<br>                           interpreter);<br>        <span class="hljs-keyword">if</span> (!interp_elf_phdata)<br>            <span class="hljs-keyword">goto</span> out_free_dentry;<br><br>        <span class="hljs-comment">// 暂时忽略</span><br>        elf_property_phdata = <span class="hljs-literal">NULL</span>;<br>        elf_ppnt = interp_elf_phdata;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; interp_elf_ex-&gt;e_phnum; i++, elf_ppnt++)<br>            <span class="hljs-keyword">switch</span> (elf_ppnt-&gt;p_type) &#123;<br>            <span class="hljs-keyword">case</span> PT_GNU_PROPERTY:<br>                elf_property_phdata = elf_ppnt;<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> PT_LOPROC ... PT_HIPROC:<br>                retval = arch_elf_pt_proc(interp_elf_ex,<br>                              elf_ppnt, interpreter,<br>                              <span class="hljs-literal">true</span>, &amp;arch_state);<br>                <span class="hljs-keyword">if</span> (retval)<br>                    <span class="hljs-keyword">goto</span> out_free_dentry;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    &#125;<br><br>    retval = parse_elf_properties(interpreter ?: bprm-&gt;file,<br>                      elf_property_phdata, &amp;arch_state);<br>    <span class="hljs-keyword">if</span> (retval)<br>        <span class="hljs-keyword">goto</span> out_free_dentry;<br><br>    retval = arch_check_elf(elf_ex,<br>                !!interpreter, interp_elf_ex,<br>                &amp;arch_state);<br>    <span class="hljs-keyword">if</span> (retval)<br>        <span class="hljs-keyword">goto</span> out_free_dentry;<br><br>    <span class="hljs-comment">// 清除父进程的所有代码</span><br>    retval = begin_new_exec(bprm);<br>    <span class="hljs-keyword">if</span> (retval)<br>        <span class="hljs-keyword">goto</span> out_free_dentry;<br><br>    <span class="hljs-comment">// 设置 elf 可执行文件的特性</span><br>    SET_PERSONALITY2(*elf_ex, &amp;arch_state);<br>    <span class="hljs-keyword">if</span> (elf_read_implies_exec(*elf_ex, executable_stack))<br>        current-&gt;personality |= READ_IMPLIES_EXEC;<br><br>    <span class="hljs-keyword">if</span> (!(current-&gt;personality &amp; ADDR_NO_RANDOMIZE) &amp;&amp; randomize_va_space)<br>        current-&gt;flags |= PF_RANDOMIZE;<br><br>    setup_new_exec(bprm);<br><br>    <span class="hljs-comment">// 为下面的动态连接器执行获取内核空间 page</span><br>    retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),<br>                 executable_stack);<br>    <span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> out_free_dentry;<br>    <br>    elf_bss = <span class="hljs-number">0</span>;<br>    elf_brk = <span class="hljs-number">0</span>;<br><br>    start_code = ~<span class="hljs-number">0UL</span>;<br>    end_code = <span class="hljs-number">0</span>;<br>    start_data = <span class="hljs-number">0</span>;<br>    end_data = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 5. 装入目标程序的段</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>, elf_ppnt = elf_phdata;<br>        i &lt; elf_ex-&gt;e_phnum; i++, elf_ppnt++) &#123;<br>        <span class="hljs-keyword">int</span> elf_prot, elf_flags;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> k, vaddr;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> total_size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> alignment;<br><br>        <span class="hljs-keyword">if</span> (elf_ppnt-&gt;p_type != PT_LOAD)<br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span> (unlikely (elf_brk &gt; elf_bss)) &#123;<br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> nbyte;<br>                <br>            <span class="hljs-comment">/* There was a PT_LOAD segment with p_memsz &gt; p_filesz</span><br><span class="hljs-comment">               before this one. Map anonymous pages, if needed,</span><br><span class="hljs-comment">               and clear the area.  */</span><br>            retval = set_brk(elf_bss + load_bias,<br>                     elf_brk + load_bias,<br>                     bss_prot);<br>            <span class="hljs-keyword">if</span> (retval)<br>                <span class="hljs-keyword">goto</span> out_free_dentry;<br>            nbyte = ELF_PAGEOFFSET(elf_bss);<br>            <span class="hljs-keyword">if</span> (nbyte) &#123;<br>                nbyte = ELF_MIN_ALIGN - nbyte;<br>                <span class="hljs-keyword">if</span> (nbyte &gt; elf_brk - elf_bss)<br>                    nbyte = elf_brk - elf_bss;<br>                <span class="hljs-keyword">if</span> (clear_user((<span class="hljs-keyword">void</span> __user *)elf_bss +<br>                            load_bias, nbyte)) &#123;<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * This bss-zeroing can fail if the ELF</span><br><span class="hljs-comment">                     * file specifies odd protections. So</span><br><span class="hljs-comment">                     * we don&#x27;t check the return value</span><br><span class="hljs-comment">                     */</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        elf_prot = make_prot(elf_ppnt-&gt;p_flags, &amp;arch_state,<br>                     !!interpreter, <span class="hljs-literal">false</span>);<br><br>        elf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;<br><br>        vaddr = elf_ppnt-&gt;p_vaddr;<br>        <span class="hljs-keyword">if</span> (elf_ex-&gt;e_type == ET_EXEC || load_addr_set) &#123;<br>            elf_flags |= MAP_FIXED;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (elf_ex-&gt;e_type == ET_DYN) &#123;<br>            <span class="hljs-keyword">if</span> (interpreter) &#123;<br>                load_bias = ELF_ET_DYN_BASE;<br>                <span class="hljs-keyword">if</span> (current-&gt;flags &amp; PF_RANDOMIZE)<br>                    load_bias += arch_mmap_rnd();<br>                alignment = maximum_alignment(elf_phdata, elf_ex-&gt;e_phnum);<br>                <span class="hljs-keyword">if</span> (alignment)<br>                    load_bias &amp;= ~(alignment - <span class="hljs-number">1</span>);<br>                elf_flags |= MAP_FIXED;<br>            &#125; <span class="hljs-keyword">else</span><br>                load_bias = <span class="hljs-number">0</span>;<br><br>            load_bias = ELF_PAGESTART(load_bias - vaddr);<br><br>            total_size = total_mapping_size(elf_phdata,<br>                            elf_ex-&gt;e_phnum);<br>            <span class="hljs-keyword">if</span> (!total_size) &#123;<br>                retval = -EINVAL;<br>                <span class="hljs-keyword">goto</span> out_free_dentry;<br>            &#125;<br>        &#125;<br><br>        error = elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,<br>                elf_prot, elf_flags, total_size);<br>        <span class="hljs-keyword">if</span> (BAD_ADDR(error)) &#123;<br>            retval = IS_ERR((<span class="hljs-keyword">void</span> *)error) ?<br>                PTR_ERR((<span class="hljs-keyword">void</span>*)error) : -EINVAL;<br>            <span class="hljs-keyword">goto</span> out_free_dentry;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!load_addr_set) &#123;<br>            load_addr_set = <span class="hljs-number">1</span>;<br>            load_addr = (elf_ppnt-&gt;p_vaddr - elf_ppnt-&gt;p_offset);<br>            <span class="hljs-keyword">if</span> (elf_ex-&gt;e_type == ET_DYN) &#123;<br>                load_bias += error -<br>                             ELF_PAGESTART(load_bias + vaddr);<br>                load_addr += load_bias;<br>                reloc_func_desc = load_bias;<br>            &#125;<br>        &#125;<br>        k = elf_ppnt-&gt;p_vaddr;<br>        <span class="hljs-keyword">if</span> ((elf_ppnt-&gt;p_flags &amp; PF_X) &amp;&amp; k &lt; start_code)<br>            start_code = k;<br>        <span class="hljs-keyword">if</span> (start_data &lt; k)<br>            start_data = k;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Check to see if the section&#x27;s size will overflow the</span><br><span class="hljs-comment">         * allowed task size. Note that p_filesz must always be</span><br><span class="hljs-comment">         * &lt;= p_memsz so it is only necessary to check p_memsz.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (BAD_ADDR(k) || elf_ppnt-&gt;p_filesz &gt; elf_ppnt-&gt;p_memsz ||<br>            elf_ppnt-&gt;p_memsz &gt; TASK_SIZE ||<br>            TASK_SIZE - elf_ppnt-&gt;p_memsz &lt; k) &#123;<br>            <span class="hljs-comment">/* set_brk can never work. Avoid overflows. */</span><br>            retval = -EINVAL;<br>            <span class="hljs-keyword">goto</span> out_free_dentry;<br>        &#125;<br><br>        k = elf_ppnt-&gt;p_vaddr + elf_ppnt-&gt;p_filesz;<br><br>        <span class="hljs-keyword">if</span> (k &gt; elf_bss)<br>            elf_bss = k;<br>        <span class="hljs-keyword">if</span> ((elf_ppnt-&gt;p_flags &amp; PF_X) &amp;&amp; end_code &lt; k)<br>            end_code = k;<br>        <span class="hljs-keyword">if</span> (end_data &lt; k)<br>            end_data = k;<br>        k = elf_ppnt-&gt;p_vaddr + elf_ppnt-&gt;p_memsz;<br>        <span class="hljs-keyword">if</span> (k &gt; elf_brk) &#123;<br>            bss_prot = elf_prot;<br>            elf_brk = k;<br>        &#125;<br>    &#125;<br><br>    e_entry = elf_ex-&gt;e_entry + load_bias;<br>    elf_bss += load_bias;<br>    elf_brk += load_bias;<br>    start_code += load_bias;<br>    end_code += load_bias;<br>    start_data += load_bias;<br>    end_data += load_bias;<br><br>    <span class="hljs-comment">/* Calling set_brk effectively mmaps the pages that we need</span><br><span class="hljs-comment">     * for the bss and break sections.  We must do this before</span><br><span class="hljs-comment">     * mapping in the interpreter, to make sure it doesn&#x27;t wind</span><br><span class="hljs-comment">     * up getting placed where the bss needs to go.</span><br><span class="hljs-comment">     */</span><br>    retval = set_brk(elf_bss, elf_brk, bss_prot);<br>    <span class="hljs-keyword">if</span> (retval)<br>        <span class="hljs-keyword">goto</span> out_free_dentry;<br>    <span class="hljs-keyword">if</span> (likely(elf_bss != elf_brk) &amp;&amp; unlikely(padzero(elf_bss))) &#123;<br>        retval = -EFAULT; <span class="hljs-comment">/* Nobody gets to see this, but.. */</span><br>        <span class="hljs-keyword">goto</span> out_free_dentry;<br>    &#125;<br><br>    <span class="hljs-comment">// 填写程序入口的地址</span><br>    <span class="hljs-comment">// 如果有 interpreter，设置为 interpreter 的入口地址，否则就是正常的入口</span><br><br>    <span class="hljs-keyword">if</span> (interpreter) &#123;<br>        elf_entry = load_elf_interp(interp_elf_ex,<br>                        interpreter,<br>                        load_bias, interp_elf_phdata,<br>                        &amp;arch_state);<br>        <span class="hljs-keyword">if</span> (!IS_ERR((<span class="hljs-keyword">void</span> *)elf_entry)) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * load_elf_interp() returns relocation</span><br><span class="hljs-comment">             * adjustment</span><br><span class="hljs-comment">             */</span><br>            interp_load_addr = elf_entry;<br>            elf_entry += interp_elf_ex-&gt;e_entry;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (BAD_ADDR(elf_entry)) &#123;<br>            retval = IS_ERR((<span class="hljs-keyword">void</span> *)elf_entry) ?<br>                    (<span class="hljs-keyword">int</span>)elf_entry : -EINVAL;<br>            <span class="hljs-keyword">goto</span> out_free_dentry;<br>        &#125;<br>        reloc_func_desc = interp_load_addr;<br><br>        allow_write_access(interpreter);<br>        fput(interpreter);<br><br>        kfree(interp_elf_ex);<br>        kfree(interp_elf_phdata);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        elf_entry = e_entry;<br>        <span class="hljs-keyword">if</span> (BAD_ADDR(elf_entry)) &#123;<br>            retval = -EINVAL;<br>            <span class="hljs-keyword">goto</span> out_free_dentry;<br>        &#125;<br>    &#125;<br><br>    kfree(elf_phdata);<br><br>    set_binfmt(&amp;elf_format);<br><br>    <span class="hljs-comment">// 填写目标文件的参数，环境变量等必要信息</span><br><br>    retval = create_elf_tables(bprm, elf_ex,<br>              load_addr, interp_load_addr, e_entry);<br>    <span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> out;<br><br>    <span class="hljs-comment">// 调整内存映射内容</span><br>    mm = current-&gt;mm;<br>    mm-&gt;end_code = end_code;<br>    mm-&gt;start_code = start_code;<br>    mm-&gt;start_data = start_data;<br>    mm-&gt;end_data = end_data;<br>    mm-&gt;start_stack = bprm-&gt;p;<br><br>    <span class="hljs-keyword">if</span> ((current-&gt;flags &amp; PF_RANDOMIZE) &amp;&amp; (randomize_va_space &gt; <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * For architectures with ELF randomization, when executing</span><br><span class="hljs-comment">         * a loader directly (i.e. no interpreter listed in ELF</span><br><span class="hljs-comment">         * headers), move the brk area out of the mmap region</span><br><span class="hljs-comment">         * (since it grows up, and may collide early with the stack</span><br><span class="hljs-comment">         * growing down), and into the unused ELF_ET_DYN_BASE region.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_ARCH_HAS_ELF_RANDOMIZE) &amp;&amp;<br>            elf_ex-&gt;e_type == ET_DYN &amp;&amp; !interpreter) &#123;<br>            mm-&gt;brk = mm-&gt;start_brk = ELF_ET_DYN_BASE;<br>        &#125;<br><br>        mm-&gt;brk = mm-&gt;start_brk = arch_randomize_brk(mm);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> compat_brk_randomized</span><br>        current-&gt;brk_randomized = <span class="hljs-number">1</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (current-&gt;personality &amp; MMAP_PAGE_ZERO) &#123;<br>        <span class="hljs-comment">/* Why this, you ask???  Well SVr4 maps page 0 as read-only,</span><br><span class="hljs-comment">           and some applications &quot;depend&quot; upon this behavior.</span><br><span class="hljs-comment">           Since we do not have the power to recompile these, we</span><br><span class="hljs-comment">           emulate the SVr4 behavior. Sigh. */</span><br>        error = vm_mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, PAGE_SIZE, PROT_READ | PROT_EXEC,<br>                MAP_FIXED | MAP_PRIVATE, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    regs = current_pt_regs();<br><br>    finalize_exec(bprm);<br>    <br>    <span class="hljs-comment">// 将用户进程的 pt_regs 中的 sp pc 分别设置好，这样，从系统调用返回的时候，就自动跳转到指定的位置执行了</span><br>    start_thread(regs, elf_entry, bprm-&gt;p);<br>    retval = <span class="hljs-number">0</span>;<br>out:<br>    <span class="hljs-keyword">return</span> retval;<br><br>    <span class="hljs-comment">// 发生错误，清理分配的结构体</span><br>out_free_dentry:<br>    kfree(interp_elf_ex);<br>    kfree(interp_elf_phdata);<br>    allow_write_access(interpreter);<br>    <span class="hljs-keyword">if</span> (interpreter)<br>        fput(interpreter);<br>out_free_ph:<br>    kfree(elf_phdata);<br>    <span class="hljs-keyword">goto</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-register-binfmt-amp-amp-unregister-binfmt"><a href="#2-3-register-binfmt-amp-amp-unregister-binfmt" class="headerlink" title="2.3 register_binfmt &amp;&amp; unregister_binfmt"></a>2.3 register_binfmt &amp;&amp; unregister_binfmt</h3><p>在 <code>search_binary_handler</code> 中，遍历了 formats 这个链表并依次调用 <code>load_binary</code> 回调函数，也就是说，formats 保存的就是系统支持的所有可执行程序格式</p><p>前面说到，Linux 提供策略，具体机制由开发人员决定，自然，不同种类的格式需要注册到系统中才能生效，也就有了 register &amp;&amp; unregister 两种操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">LIST_HEAD</span><span class="hljs-params">(formats)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register_binfmt</span><span class="hljs-params">(struct linux_binfmt *fmt)</span></span><br><span class="hljs-function"></span>&#123;<br>    __register_binfmt(fmt, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> __register_binfmt(struct linux_binfmt * fmt, <span class="hljs-keyword">int</span> insert)<br>&#123;<br>    BUG_ON(!fmt);<br>    <span class="hljs-keyword">if</span> (WARN_ON(!fmt-&gt;load_binary))<br>        <span class="hljs-keyword">return</span>;<br>    write_lock(&amp;binfmt_lock);<br>    insert ? list_add(&amp;fmt-&gt;lh, &amp;formats) :<br>         list_add_tail(&amp;fmt-&gt;lh, &amp;formats);<br>    write_unlock(&amp;binfmt_lock);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unregister_binfmt</span><span class="hljs-params">(struct linux_binfmt * fmt)</span></span><br><span class="hljs-function"></span>&#123;<br>    write_lock(&amp;binfmt_lock);<br>    list_del(&amp;fmt-&gt;lh);<br>    write_unlock(&amp;binfmt_lock);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>execve</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>wsl 开发环境配置</title>
    <link href="/2022/02/12/toss/wsl%20configuration/"/>
    <url>/2022/02/12/toss/wsl%20configuration/</url>
    
    <content type="html"><![CDATA[<h2 id="1-WSL2-安装"><a href="#1-WSL2-安装" class="headerlink" title="1. WSL2 安装"></a>1. WSL2 安装</h2><h3 id="1-1-安装和启动-wsl"><a href="#1-1-安装和启动-wsl" class="headerlink" title="1.1 安装和启动 wsl"></a>1.1 安装和启动 wsl</h3><p>首先使用管理员权限(windows + R)打开 powershell/cmd/windows terminal，输入下面的指令，也就是打开 <code>windows subsystem for linux</code> 的功能</p><figure class="highlight powershell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs powershell">dism.exe /online /<span class="hljs-built_in">enable-feature</span> /featurename:Microsoft<span class="hljs-literal">-Windows</span><span class="hljs-literal">-Subsystem</span><span class="hljs-literal">-Linux</span> /all /norestart<br>dism.exe /online /<span class="hljs-built_in">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart<br>wsl -<span class="hljs-literal">-set</span><span class="hljs-literal">-default</span><span class="hljs-literal">-version</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>重启电脑，这一步就完成了</p><h3 id="1-2-安装-Linux-发行版"><a href="#1-2-安装-Linux-发行版" class="headerlink" title="1.2 安装 Linux 发行版"></a>1.2 安装 Linux 发行版</h3><p>这一步骤也极其简单：在 <code>Microsoft Store</code> 中下载 ubuntu 或者 kali 发行版，就可以打开使用了。</p><p>不过今天要在这里着重强调的，不是 ubuntu 这种“入门”级别的 Linux 发行版的 wsl 配置，而是 <code>Arch Linux.yyds</code> 的配置。</p><p>详细的配置可以参考<a href="https://github.com/yuk7/ArchWSL/blob/master/i18n/README_zh-cn.md">github文档</a>，这里简要说明一下，分为几个步骤：</p><ol><li>去 github 项目下载 Arch.zip，解压（文件夹位置慎重存放，因为一旦开启 <code>arch linux wsl</code>，该文件夹位置将无法移动）；</li><li>双击 Arch 程序，此时会启动一个命令行窗口，完成注册表等信息的更改，等待安装完成，此时会提示 <code>Installation Complete!</code></li><li>启动 Arch 程序，可以通过 Windows Terminal（因为此时已经注册到系统当中了），也可以双击刚刚的 Arch 程序打开命令行窗口</li></ol><p>注意，如果你已经安装了 Ubuntu 等别的发型版，会出现多个 Wsl 系统，虽然它们可以共存，但有一个会默认打开，可以通过 powershell 中的 <code>wslconfig</code> 命令修改默认版本，（如果使用 vscode wsl 连接，需要将 Arch 设置为默认的 wsl，因为该扩展暂时不支持 arch 的识别`</p><h2 id="2-Arch-Linux-配置"><a href="#2-Arch-Linux-配置" class="headerlink" title="2. Arch Linux 配置"></a>2. Arch Linux 配置</h2><h3 id="2-1-导入密钥"><a href="#2-1-导入密钥" class="headerlink" title="2.1 导入密钥"></a>2.1 导入密钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman-key --init &amp;&amp; pacman-key --populate archlinux &amp;&amp; pacman-key --refresh-keys<br></code></pre></td></tr></table></figure><h3 id="2-2-更新软件源"><a href="#2-2-更新软件源" class="headerlink" title="2.2 更新软件源"></a>2.2 更新软件源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch&#x27;</span> &gt;&gt; /etc/pacman.d/mirrorlist<br>pacman -Syy<br></code></pre></td></tr></table></figure><h3 id="2-3-安装常用开发软件"><a href="#2-3-安装常用开发软件" class="headerlink" title="2.3 安装常用开发软件"></a>2.3 安装常用开发软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -yS openssh zsh <span class="hljs-built_in">which</span> wget curl git aria2 bison flex texinfo gperf libtool patchutils bc zlib expat vi vim neovim rsync fd exa ripgrep tree cloc man python2 <span class="hljs-comment"># 基本软件</span><br>pacman -yS clang llvm gdb clang-format cmake make ccls <span class="hljs-comment"># 编译必备</span><br>pacman -yS ltrace libelf libbcc strace pahole bpftrace perf netmap trace-cmd liburing base-devel devtools <span class="hljs-comment"># 开发必备</span><br></code></pre></td></tr></table></figure><h3 id="2-4-zsh-配置"><a href="#2-4-zsh-配置" class="headerlink" title="2.4 zsh 配置"></a>2.4 zsh 配置</h3><p>首先将默认 shell 修改为 zsh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chsh -s `<span class="hljs-built_in">which</span> zsh` <span class="hljs-comment"># 上一步已经安装了 zsh &amp; which </span><br></code></pre></td></tr></table></figure><p>下载 <code>oh-my-zsh</code>（若这一步中无法连接 github，可以使用 hub.fastgit.org 等国内镜像作为替代）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh<br>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc<br></code></pre></td></tr></table></figure><p></br></br></p><p>配置 zsh 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/paulirish/git-open.git <span class="hljs-variable">$ZSH_CUSTOM</span>/plugins/git-open<br>git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="hljs-variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting<br>git <span class="hljs-built_in">clone</span> git://github.com/zsh-users/zsh-autosuggestions <span class="hljs-variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions<br></code></pre></td></tr></table></figure><p>配置 <code>~/.zshrc</code> 中的 <code>plugins</code> 配置为 <code>plugins=(其他的插件 git-open zsh-autosuggestions zsh-autosuggestions z extract python)</code>（可以参考 <code>~/.oh-my-zsh/plugin</code> 中的插件目录，自行取舍）</p><p></br></br></p><p>配置 zsh 主题</p><p>查看 <a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">github wiki</a>，找到属于你自己的主题，之后在 <code>~/.zshrc</code> 中修改 <code>ZSH_THEME=&#39;xxx&#39;</code> 中的主题名称。</p><p></br></br></p><p>配置 zsh alias</p><p>在 <code>~/.zshrc</code> 中配置下面信息（个人习惯），当然你也可以根据个人喜好配置属于自己的快捷键，或者你可以采用 oh-my-zsh 已经配置好的 <strong>zsh alias</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> ls=exa <span class="hljs-comment"># 需要安装 exa</span><br><span class="hljs-built_in">alias</span> clo=<span class="hljs-string">&quot;git clone &quot;</span><br><span class="hljs-built_in">alias</span> rm=trash   <span class="hljs-comment"># 需要安装 trash-cli</span><br></code></pre></td></tr></table></figure><h3 id="2-5-python-配置"><a href="#2-5-python-配置" class="headerlink" title="2.5 python 配置"></a>2.5 python 配置</h3><p>安装 pip3/pip2:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl https://bootstrap.pypa.io/get-pip.py -o get-pip3.py <span class="hljs-comment"># get pip3</span><br>python3 get-pip3.py<br>pip config <span class="hljs-built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple <span class="hljs-comment"># set pip source</span><br>curl https://bootstrap.pypa.io/pip/2.7/get-pip.py -o get-pip2.py <span class="hljs-comment"># get pip2 </span><br>sudo python2 get-pip2.py<br></code></pre></td></tr></table></figure><h3 id="2-6-nvim-vim-配置"><a href="#2-6-nvim-vim-配置" class="headerlink" title="2.6 nvim(vim) 配置"></a>2.6 nvim(vim) 配置</h3><p>通过 curl 下载 <code>vim-plug</code> 这个插件管理工具（这里使用了国内的源，你也可以自己找合适的源，建议通过 hub.fastgit.org/gitclone.com/github.com.cnpmjs.org 这几个网站查找）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fLo ~/.vim/<span class="hljs-built_in">autoload</span>/plug.vim --create-dirs \<br>    https://ghproxy.fsou.cc/https://github.com/junegunn/vim-plug/blob/master/plug.vim<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/hsqStephenZhang/neovim-config.git ~/.config/nvim<br></code></pre></td></tr></table></figure><p>接着修改 <code>~/.config/nvim/init.vim</code> 并自行修改配置文件中的一些选项，比如插件设置，快捷键设置</p><p>打开 nvim，命令模式下输入 <code>:PlugInstall</code>，完成插件的安装</p><h3 id="2-7-Rust-配置"><a href="#2-7-Rust-配置" class="headerlink" title="2.7 Rust 配置"></a>2.7 Rust 配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --proto <span class="hljs-string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh<br></code></pre></td></tr></table></figure><p>然后选择 custom 安装，将默认 rust 发行版修改为 nightly，其余的按照 default 选项安装即可，</p><p>配置cargo 国内源，修改/创建 <code>~/.cargo/config</code> 为下面的内容：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[source.crates-io]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><br><span class="hljs-comment"># 替换成你偏好的镜像源</span><br><span class="hljs-attr">replace-with</span> = <span class="hljs-string">&#x27;ustc&#x27;</span><br><br><span class="hljs-comment"># 清华大学</span><br><span class="hljs-section">[source.tuna]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;</span><br><br><span class="hljs-comment"># 中国科学技术大学</span><br><span class="hljs-section">[source.ustc]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br><br><span class="hljs-comment"># 上海交通大学</span><br><span class="hljs-section">[source.sjtu]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;</span><br><br><span class="hljs-comment"># rustcc社区</span><br><span class="hljs-section">[source.rustcc]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;git://crates.rustcc.cn/crates.io-index&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-8-git-配置"><a href="#2-8-git-配置" class="headerlink" title="2.8 git 配置"></a>2.8 git 配置</h3><p>配置用户名和邮箱</p><p>修改配置文件 <code>~/.gitconfig</code>，或者通过 <code>git config --global</code> 来设置 email,name 等属性，甚至可以设置 git 镜像网站，用来加速项目下载，比如在 <code>~/.gitconfig</code> 添加下面这条配置，可以加速国内 clone 速度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[url <span class="hljs-string">&quot;https://hub.fastgit.org&quot;</span>]<br>    insteadOf = https://github.com<br></code></pre></td></tr></table></figure><p></br></br></p><p>配置 ssh 密钥</p><p>通过下面这条命令，创建 ssh 的密钥，并且上传到 github，gitee，gitlab 等 git 托管网站中<br><code>ssh-keygen -t rsa -m PEM -b 4096 -C &quot;email&quot;</code></p><p>如果取的名字比较特殊（因为 git 会默认查找一些特殊命名的密钥文件），需要在 <code>~/.ssh/config</code> 当中指明，针对某一个 host，到底用的是哪个配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host github.com<br>  HostName github.com<br>  IdentityFile ~/.ssh/id_rsa_xxx<br></code></pre></td></tr></table></figure><h2 id="3-WSL-管理"><a href="#3-WSL-管理" class="headerlink" title="3. WSL 管理"></a>3. WSL 管理</h2><p>如果是单个 WSL，还算比较容易管理，但如果存在多个 WSL 实例，这时候就要用到 wslconfig 这个命令来管理所有的 Linux subsystems</p><p>详细信息可以参考 <a href="https://docs.microsoft.com/en-us/windows/wsl/wsl-config">docs</a> <a href="https://dowww.spencerwoo.com/4-advanced/4-3-wslconfig.html">小白版 docs</a></p><p>由于我在安装 arch linux 之前，还安装了 ubuntu 20.04，因此后者是默认的 WSL，也就用到了下面的命令修改默认的发行版本（vscode wsl 插件都可以识别）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wslconfig /list <span class="hljs-comment"># 确认名称叫 &#x27;Arch&#x27;</span><br>wslconfig /s Arch <span class="hljs-comment"># 设置默认发行版本</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>arch</category>
      
      <category>configuration</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux vDSO 机制</title>
    <link href="/2022/02/10/linux/syscall/vdso/"/>
    <url>/2022/02/10/linux/syscall/vdso/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是-vDSO"><a href="#1-什么是-vDSO" class="headerlink" title="1. 什么是 vDSO"></a>1. 什么是 vDSO</h2><p>众所周知，操作系统为我们管理硬件资源，并以系统调用的方式对用户进程提供 API，但是 syscall 很慢，涉及陷入内核以及上下文切换。对于少量频繁调用的系统调用（比如获取当期系统时间）来说，是否可以某种安全的方式开放到用户空间，让用户直接访问而不需要经过 syscall 呢？</p><p>vDSO 就是用来解决这个问题的。</p><p>vDSO 全程为 <code>virtual dynamic shared object</code>，<code>dynamic shared object</code> 这个名词大家应该有所耳闻，就是 Linux 下的动态库的全称，而 <strong>virtual</strong> 表明，这个动态库是通过某种手段虚拟出来的，并不真正存在于 Linux 文件系统中。</p><p>要验证这点也很简单，只需要通过 ldd 命令，查看一些可执行文件所依赖的动态库即可，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs text">$ldd /bin/ls   <br>    linux-vdso.so.1 (0x00007ffe4e4ce000)<br>    libcap.so.2 =&gt; /usr/lib/libcap.so.2 (0x00007f7bf818e000)<br>    libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f7bf7fc2000)<br>    /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f7bf81e8000)<br></code></pre></td></tr></table></figure><p>可以明显看出，在ls 这个可执行文件依赖的动态库列表中，除了 <code>linux-vdso.so.1</code> 都有明确的路径</p><p>同时还可以通过 proc 文件系统中进程的内存映射（memory map）情况来映射这一点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">$cat /proc/1/maps<br>....<br>7fd37e90f000-7fd37e911000 rw-p 0002f000 103:02 13244335                  /usr/lib/ld-2.33.so<br>7ffc2f7ce000-7ffc2f7ef000 rw-p 00000000 00:00 0                          [stack]<br>7ffc2f7f7000-7ffc2f7fb000 r--p 00000000 00:00 0                          [vvar]<br>7ffc2f7fb000-7ffc2f7fd000 r-xp 00000000 00:00 0                          [vdso]<br>ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]<br></code></pre></td></tr></table></figure><p>可以看出，vDSO 确实是以共享库的形式存在于每一个进程当中的</p><p>通过 vDSO，进程访问一些系统提供的 API，就可以直接在自己的地址空间访问，而不需要进行<code>用户-内核态</code>的状态切换了</p><h2 id="2-vDSO-实现原理"><a href="#2-vDSO-实现原理" class="headerlink" title="2. vDSO 实现原理"></a>2. vDSO 实现原理</h2><p><code>linux-vdso.so.1</code> 既然不是一个实实在在的文件，那其中的内容就应该直接保存在内存中，Linux 使用 vdso_image 来表示</p><h3 id="2-1-vDSO-image"><a href="#2-1-vDSO-image" class="headerlink" title="2.1 vDSO image"></a>2.1 vDSO image</h3><p>在 <code>arch/x86/entyr/vdso/vdso-image-64.c</code> 文件中，定义了下面的 vdso_image</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> raw_data[<span class="hljs-number">8192</span>] __ro_after_init __aligned(PAGE_SIZE) = &#123;<br>    <span class="hljs-number">0x7F</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <br>    <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x3E</span>, <span class="hljs-number">0x00</span>, <br>    ...<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vdso_image</span> <span class="hljs-title">vdso_image_64</span> =</span> &#123;<br>    .data = raw_data,<br>    .size = <span class="hljs-number">8192</span>,<br>    .alt = <span class="hljs-number">3013</span>,<br>    .alt_len = <span class="hljs-number">91</span>,<br>    .sym_vvar_start = <span class="hljs-number">-16384</span>,<br>    .sym_vvar_page = <span class="hljs-number">-16384</span>,<br>    .sym_pvclock_page = <span class="hljs-number">-12288</span>,<br>    .sym_hvclock_page = <span class="hljs-number">-8192</span>,<br>    .sym_timens_page = <span class="hljs-number">-4096</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>vdso_image.raw_data</code> 对应的就是 vDSO 提供的所有系统调用的二进制指令，一共有 8192 字节，相当于下面的结构: <code>static struct page *pages[2];</code></p><p><code>vdso_iamge_64</code> 自然需要保存到全局变量中才能发挥作用，这就涉及接下来要提到的 vDSO init</p><h3 id="2-2-vDSO-init"><a href="#2-2-vDSO-init" class="headerlink" title="2.2 vDSO init"></a>2.2 vDSO init</h3><p>vDSO 通过 <code>init_vdso</code> 来初始化，通过条件编译对 32/64 bit 的 image 进行选择。同时也需要通过 <code>subsys_initcall(init_vdso);</code> 将 <code>init_vdso</code> 放到 initcall 列表中。</p><p><code>init_vdso_image</code> 这里不过多介绍，主要是用来优化指令，毕竟 vdso_image 中提供的二进制指令是手动放在一个数组中的，还有相当大的优化空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init <span class="hljs-title">init_vdso</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    BUILD_BUG_ON(VDSO_CLOCKMODE_MAX &gt;= <span class="hljs-number">32</span>);<br><br>    init_vdso_image(&amp;vdso_image_64);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_X86_X32_ABI</span><br>    init_vdso_image(&amp;vdso_image_x32);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>subsys_initcall(init_vdso);<br></code></pre></td></tr></table></figure><h3 id="2-3-vDSO-和-可执行程序"><a href="#2-3-vDSO-和-可执行程序" class="headerlink" title="2.3 vDSO 和 可执行程序"></a>2.3 vDSO 和 可执行程序</h3><p>如果你对 Linux 可执行程序的 <code>加载-执行</code>机制有所研究，就知道对于 elf 格式的可执行程序而言，最终调用了 <code>load_elf_binary</code> 这个回调函数，在这个函数中，会根据 elf 文件头中的描述，设置好新进程的各个段，并将 elf 文件中的内容拷贝到相应位置。</p><p>为什么好端端的，要提到可执行程序加载呢？这是因为，在系统初始化完成之后，vdso_image 已经设置完毕，只需要在每次加载二进制可执行程序的时候，分配一块内存空间，将 vdso_image 加载到该位置即可</p><p>这就是 <code>arch_setup_additional_pages</code> 所要完成的任务了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">arch_setup_additional_pages</span><span class="hljs-params">(struct linux_binprm *bprm, <span class="hljs-keyword">int</span> uses_interp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!vdso64_enabled)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> map_vdso_randomized(&amp;vdso_image_64);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>map_vdso_randomized</code> 会通过 stack protect 机制，选择一个随机的加载地址，并调用 <code>map_vdso</code> 完成 mapping 工作，该函数内容较多，这里不赘述</p><p>最终，vDSO 会向用户提供四个 syscall</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">__vdso_clock_gettime<br>__vdso_getcpu<br>__vdso_gettimeofday<br>__vdso_time<br></code></pre></td></tr></table></figure><p>你还别不信，可以自行验证一下：</p><ol><li><p><code>cat /proc/1/maps</code> 找到 <code>[vdso]</code> 对应的内存位置</p></li><li><p>通过 dd dump 内存，<code>dd if=/proc/1/mem of=/tmp/linux-vdso.so skip=140728627781632 ibs=1 count=4096</code>，其中 skip 的值为 vdso 的内存起始地址，count 为这块内存的大小</p></li><li><p>objdump 查看 <code>linux-vdso.so</code> 中所有符号 <code>objdump -T /tmp/linux-vdso.so</code>，最终结果如下</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">linux-vdso.so:     file format elf64-x86-64<br><br>DYNAMIC SYMBOL TABLE:<br>0000000000000740  w   DF .text  000000000000015d  LINUX_2.6   clock_gettime<br>0000000000000600 g    DF .text  0000000000000127  LINUX_2.6   __vdso_gettimeofday<br>00000000000008a0  w   DF .text  0000000000000044  LINUX_2.6   clock_getres<br>00000000000008a0 g    DF .text  0000000000000044  LINUX_2.6   __vdso_clock_getres<br>0000000000000600  w   DF .text  0000000000000127  LINUX_2.6   gettimeofday<br>0000000000000730 g    DF .text  0000000000000010  LINUX_2.6   __vdso_time<br>0000000000000730  w   DF .text  0000000000000010  LINUX_2.6   time<br>0000000000000740 g    DF .text  000000000000015d  LINUX_2.6   __vdso_clock_gettime<br>0000000000000000 g    DO *ABS*  0000000000000000  LINUX_2.6   LINUX_2.6<br>00000000000008f0 g    DF .text  0000000000000025  LINUX_2.6   __vdso_getcpu<br>00000000000008f0  w   DF .text  0000000000000025  LINUX_2.6   getcpu<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>vsyscall</category>
      
      <category>vDSO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GDT &amp;&amp; LDT</title>
    <link href="/2022/01/21/linux/gdt%20&amp;&amp;%20ldt/"/>
    <url>/2022/01/21/linux/gdt%20&amp;&amp;%20ldt/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是-GDT，什么是-LDT"><a href="#1-什么是-GDT，什么是-LDT" class="headerlink" title="1. 什么是 GDT，什么是 LDT"></a>1. 什么是 GDT，什么是 LDT</h2>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>x86 APIC</title>
    <link href="/2022/01/21/linux/apic/"/>
    <url>/2022/01/21/linux/apic/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是-APIC"><a href="#1-什么是-APIC" class="headerlink" title="1. 什么是 APIC"></a>1. 什么是 APIC</h2><p>APIC 的全程是 Advanced Programmable Interrupt Controller，高级可编程中断控制器，我们今天主要讨论 x86 平台上的 APIC。</p><p>主要关注两点：</p><ol><li>怎么高级了</li><li>什么是可编程</li></ol><p>在这之前，首先认识一下 Interrupt 是什么</p><h2 id="2-APIC-details"><a href="#2-APIC-details" class="headerlink" title="2. APIC details"></a>2. APIC details</h2><h3 id="2-1-中断，陷阱，异常"><a href="#2-1-中断，陷阱，异常" class="headerlink" title="2.1 中断，陷阱，异常"></a>2.1 中断，陷阱，异常</h3><p>说起中断，大家经常将其和异常混淆，我觉得这里有必要解释一下。</p><p>常说的操作系统中的中断处理程序，其实应该叫做异常处理程序，而<strong>异常</strong>分为软件异常和硬件异常，前者是同步产生的，主要由 CPU 执行指令的过程中，触发的一些异常状况，比如除零异常，int 3 异常 …，也可以统称为陷阱；后者则是异步产生的，也就是我们所说的 Interrupt，外部硬件给 CPU 发送一个信号，通过一些线路传出，交给 CPU 处理。</p><p>将异常再进行细分，还可以分为三类：</p><ol><li>Fault</li><li>Trap</li><li>Abort</li></ol><p>Fault 是可以在指令执行之前就检测出来的异常，如果检测并纠正成功，就能继续执行，比如 Divide Error，Invalid Opcode</p><p>Trap 必须要执行完指令才能触发，并且会立即上报 Trap，同样，也是可以像 Fault 一样继续执行的，比如 int 3，Breakpoint，Overflow</p><p>Abort 我们平时打交道比较少，只需要明白，这是最严重的一种情况，不会上报，也不允许程序继续执行，比如 Alignment Check，Machine Check</p><h3 id="2-2-从-PIC-到-APIC"><a href="#2-2-从-PIC-到-APIC" class="headerlink" title="2.2 从 PIC 到 APIC"></a>2.2 从 PIC 到 APIC</h3><p>但是，上面所说的中断信号并不是直接传输到 CPU 的，老式机器上，有一个专用的 PIC 芯片，负责接收外围设备的 Interrupt request，然后交给 CPU，而现代负责这一功能的设备则是 APIC，advanced one。</p><p>一个 APIC，主要由两个部分组成：</p><ol><li>Local APCI</li><li>IO APIC</li></ol><p>Local APIC 是 per-cpu 的硬件，负责处理各自 CPU 上的一些本地 IO 中断，最典型的就是 APIC-timer</p><p>IO APIC 则为所有的核心同时提供外围设备的 IO 中断管理</p><p><img src="/images/apic.png" alt="apic"></p><h3 id="2-3-中断处理"><a href="#2-3-中断处理" class="headerlink" title="2.3 中断处理"></a>2.3 中断处理</h3><p>中断发生之后，需要立刻交由操作系统得到处理，那什么才是一个中断的完成处理过程呢？应该分为下面几个步骤</p><ol><li>保存当前 cpu core 正在执行的程序状态</li><li>kernel 找到对应的处理程序，调用该程序</li><li>中断处理程序执行结束，恢复原先程序的状态</li></ol><p>所有中断对应程序的地址，就保存在 Interrupt Descriptor Table（IDT）中，并且，CPU 通过唯一的序号来标识每一种中断，这个序号就称为 vector number，中断向量号，IDT 也可以称为中断向量表</p><p>虽然名字中有 Descriptor 这个词，但是 IDT 的表项一般被称为 gate，包含了以下三种：</p><ol><li>Interrupt Gates</li><li>Task Gates</li><li>Trap Gates</li></ol><p>类似于 Global Descriptor Table，IDT 也对应了一个特殊的寄存器 IDTR，用来保存其地址，同时，也提供了两条指令 lidt/sidt，分别用来设置和读取 IDRT 的值，可以查看 <code>struct paravirt_patch_template pv_ops</code>，其中的 <code>.cpu.load_idt</code> 就设置的下面这个回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span> <span class="hljs-title">native_load_idt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct desc_ptr *dtr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lidt %0&quot;</span>::<span class="hljs-string">&quot;m&quot;</span> (*dtr))</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，系统初始化的时候，也会通过 lidtl 指令来设置 IDTR 寄存器中（同时也表明 LDT 是可以为空的，不必要像 GDT 一样一次性设置好），这里也插一嘴，IDT 可能存在于地址空间的任意位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setup_idt</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gdt_ptr</span> <span class="hljs-title">null_idt</span> =</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lidtl %0&quot;</span> : : <span class="hljs-string">&quot;m&quot;</span> (null_idt))</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>LDTR 是一个 48 bits 的寄存器，对应下面的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gdt_ptr</span> &#123;</span><br>        u16 len;  <span class="hljs-comment">// 长度限制</span><br>        u32 ptr;  <span class="hljs-comment">// base 地址，IDT 地址</span><br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure><p>接下来看一下 IDT entry，也就是 <strong>gate</strong> 的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">idt_bits</span> &#123;</span><br>    u16     ist    : <span class="hljs-number">3</span>,<br>            zero    : <span class="hljs-number">5</span>,<br>            type    : <span class="hljs-number">5</span>,<br>            dpl    : <span class="hljs-number">2</span>,<br>            p    : <span class="hljs-number">1</span>;<br>&#125; __attribute__((packed));<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gate_struct</span> &#123;</span><br>    u16        offset_low;<br>    u16        segment;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">idt_bits</span>    <span class="hljs-title">bits</span>;</span><br>    u16        offset_middle;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_X86_64</span><br>    u32        offset_high;<br>    u32        reserved;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure><p>这里的 ist 值得详细解释一下</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>interrupt</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Locks3-Mutex</title>
    <link href="/2022/01/21/linux/locks-mutex/"/>
    <url>/2022/01/21/linux/locks-mutex/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Locks5-RCU</title>
    <link href="/2022/01/21/linux/locks-rcu/"/>
    <url>/2022/01/21/linux/locks-rcu/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Locks4-SeqLock</title>
    <link href="/2022/01/21/linux/locks-seqlock/"/>
    <url>/2022/01/21/linux/locks-seqlock/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Locks2-Semaphore</title>
    <link href="/2022/01/21/linux/locks-semaphore/"/>
    <url>/2022/01/21/linux/locks-semaphore/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Locks1-Spinlock</title>
    <link href="/2022/01/21/linux/locks-spinlock/"/>
    <url>/2022/01/21/linux/locks-spinlock/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kbuild</title>
    <link href="/2022/01/20/linux/kbuild/"/>
    <url>/2022/01/20/linux/kbuild/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是-kbuild"><a href="#1-什么是-kbuild" class="headerlink" title="1. 什么是 kbuild"></a>1. 什么是 kbuild</h2><p>Linux 是一个单体内核，也就意味着整个内核运行在同一个地址空间中，这当然有很多性能上的好处，也同时带来了一个挑战，必须要在编译期间选择想要的特性。</p><p>同时，Linux 不是一个纯粹的单体内核（monolithic kernel），因为它可以在运行时使用可加载的内核模块（loadable kernel modules）进行扩展。要加载模块，内核必须包含模块中使用的所有内核符号。如果这些符号在编译时未包含在内核中，则由于缺少依赖项，模块将不会被加载。</p><p>因此，能够选择要在 Linux 内核中编译（或不编译）什么代码非常重要。实现这一点的方法是使用<strong>条件编译</strong>。有大量配置选项可用于选择是否包含特定的功能，这被翻译成 C语言中的 define 条件编译参数。</p><p>因此，需要一种简单有效的方法来管理所有这些编译选项。负责这个的基础设施——构建内核映像及各个模块的工具——被称为 Kbuild，也就是内核编译系统</p><h2 id="2-Kbuild-Details"><a href="#2-Kbuild-Details" class="headerlink" title="2. Kbuild Details"></a>2. Kbuild Details</h2><p>关于 Kbuild 的详细信息，可以去 <a href="https://www.kernel.org/doc/Documentation/kbuild/makefiles.txt">Kbuild kernel document</a> <a href="https://blog.51cto.com/weiguozhihui/1591397">kernel document 中文翻译</a> 查阅，这里简要说明一下，然后通过一些示例来看看 Kbuild 是如何具体应用的。</p><h3 id="2-1-Kbuild-main-components"><a href="#2-1-Kbuild-main-components" class="headerlink" title="2.1 Kbuild main components"></a>2.1 Kbuild main components</h3><p>Kbuild system 有下面几个主要的组成部分：</p><ol><li><p>Config symbols: 编译选项，用来决定是否需要编译某些文件，以及如何编译这些文件，以及是否要在最终生成的镜像中包含二进制对象文件 <code>xxx.o</code></p></li><li><p>Kconfig files: 定义了所有 <code>CONFIG_XXX</code> 符号，以及它们的属性，比如类型，描述信息，依赖配置，通过 <code>make menuconfig</code> 可以根据这些信息生成树状的结构，从而可视化编译每一个符号的值</p></li><li><p>.config file: 保存了所有 <code>CONFIG_XXX</code> 符号的值，可以手动修改这些值，从而开启（关闭）某些特性，也可可以通过 <code>make menuconfig</code> <code>make xconfig</code> 来进行可视化编辑，然后保存为最新的 .config 文件，相信大家编译内核的时候，应该已经尝试过这项功能了</p></li><li><p>Makefiles: 普通的 GNU makefile</p></li></ol><h3 id="2-2-Kbuild-项目构成"><a href="#2-2-Kbuild-项目构成" class="headerlink" title="2.2 Kbuild 项目构成"></a>2.2 Kbuild 项目构成</h3><p>一个完整的 Kbuild 项目，以 <a href="https://github.com/gxku/menuconfig.git">github menuconfig demo</a> 为例，主要由 Kbuild ，Makefile，kconfig/xxx，src/xxx 组成</p><p>Kconfig 用来描述项目的依赖关系，而 kconfig 文件夹对于每个项目来说，都是相同的（可以从 Linux 源码的 kernel/scripts/kconfig 复制过来），主要是一些词法分析，解析 Kconfig 以及其它配置相关的工具。</p><p>先来看大家较为熟知的 <code>make menuconfig</code>，它会通过 ncurses 显示一个图形化菜单，供大家勾选一些编译选项，完成之后生成一个 <code>.config</code> 文件。那么，这个菜单是如何生成的呢？换句话说，菜单中的这么多项目，从何而来？</p><p>这就是 Kconfig 文件的作用了，稍微查看一下 Kconfig 的内容就能明白，其中的 <code>mainmenu &quot;xxx&quot;</code> <code>menuconfig TEST1</code> 等内容，就是之前显示的图形化菜单的结构化描述。实际上，如果查看 Makefile 可以发现，menuconfig 是通过执行 <code>kconfig/mconf Kconfig</code> 得到的，这也就是为什么要包含这样一个 <code>kconfig/</code> 文件夹的原因了。</p><p>完成了 <code>make menuconfig</code> 之后，生成了一个 <code>.config</code> 文件，仔细查看这个文件会发现，它包含了我们想要的所有编译选项，以 <code>CONFIG_XXX=?</code> 的格式存放，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs config">CONFIG_TEST1=y<br>CONFIG_LED_ON=y<br></code></pre></td></tr></table></figure><p>并且，如果是 menuconfig 中没有配置的选项，对应的内容则为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs config"># CONFIG_LED_OFF is not set<br></code></pre></td></tr></table></figure><p>接下来就是真正的编译了，在这之前，Kbuild 系统会通过 <code>kconfig/conf Kconfig</code> 递归读取所有的 Kconfig 配置（.config 文件），并且生成一个头文件 <code>include/generated/autoconf.h</code>，这个文件中包含了所有配置的符号，如 <code>CONFIG_FTRACE</code> <code>CONFIG_MODULES</code>，gcc 在编译的时候，都会将这个头文件先导入进来，这就完成了条件编译的目的。</p><p>通过 <code>cat include/generated/autoconf.h</code> 查看自动生成的头文件内容，如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Automatically generated file; DO NOT EDIT.</span><br><span class="hljs-comment"> * Main Menu</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CONFIG_LED_ON 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CONFIG_TEST2 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CONFIG_NUM_PARAM2 10086</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CONFIG_TEST1 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CONFIG_OPTIONAL_PARAM <span class="hljs-meta-string">&quot;this shown if TEST1 is set&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CONFIG_NUM_PARAM 55</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CONFIG_STRING_PARAM <span class="hljs-meta-string">&quot;this is default string.&quot;</span></span><br></code></pre></td></tr></table></figure><p>然后就会真正执行 Makefile 中的命令，递归地进入到子目录中，执行下面的 Makefile 命令，子文件夹构建完成之后，再退回到上一级</p><h3 id="2-3-Useful-Tips"><a href="#2-3-Useful-Tips" class="headerlink" title="2.3 Useful Tips"></a>2.3 Useful Tips</h3><h4 id="2-3-1-obj-amp-amp-hostprogs"><a href="#2-3-1-obj-amp-amp-hostprogs" class="headerlink" title="2.3.1 obj &amp;&amp; hostprogs"></a>2.3.1 obj &amp;&amp; hostprogs</h4><p>在内核模块的编译时候，经常会看到 <code>obj-m</code> <code>hostprogs-y</code> <code>always += xxx</code> 的 Makefile 指令，这些有什么作用呢？</p><p>之前提到过，内核是以 <code>单体+可插拔模块</code> 的方式编译的，一个功能，可以直接包含到最终生成的 vmlinux 中，也可以通过 loadable modules 的形式，按需加载，为了方便这种编译，Kbuild 就提供了两种模式：’y’ 和 ‘m’</p><p>如果 <code>objs-y += demo.o</code>，那么 demo.c 编译得到的 demo.o 就会包含在最终生成的可执行文件中（还需要看上一级目录是否也 <code>objs-y += xxx</code> 了），如果 <code>objs-m += demo.o</code>，那么 demo.o 就会以内核模块的方式编译，自行加载</p><p>但在 Linux 源码中，我们经常可以看到 <code>objs-$(CONFIG_XXX) += xxx.o</code>，这就是根据特定功能的配置，来决定是直接编译到内核中，还是编译为模块，当 <code>CONFIG_XXX=y</code> 的时候，就是前者，<code>CONFIG_XXX=m</code> 的时候，就是后者，当然，如果不想要编译这个文件，就设置 <code>CONFIG_XXX=n</code>，或者什么都不做（对应了 .config 文件中的 <code># CONFIG_LED_OFF is not set</code>）</p><p>至于 <code>hostprogs-y hostprogs-m</code> 也是类似的道理，只不过，hostprogs 是编译过程中需要执行的一些程序，比如 recordmcount 这种，对于编译的中间结果做一些 <strong>black magic</strong></p><p>不论是 <code>obj-y</code> 还是 <code>hostprogs-y</code>，都有办法让它们强制编译，那就是加上一个 <strong>always</strong> 标签，比如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">hostprogs-always-<span class="hljs-variable">$(BUILD_C_XXX)</span>     += recordmcount<br><br>always-y += test1<br></code></pre></td></tr></table></figure><h4 id="2-3-2-flags-amp-amp-options"><a href="#2-3-2-flags-amp-amp-options" class="headerlink" title="2.3.2 flags &amp;&amp; options"></a>2.3.2 flags &amp;&amp; options</h4><p>Kbuild 有一些默认的规则：</p><ol><li><p>ccflags-y,是指定给 $(CC) 的编译选项；</p></li><li><p>asflags-y,是指定给 $(AS) 的编译选项；</p></li><li><p>ldflags-y,是指定给 $(LD) 的编译选项；</p></li></ol><p>结合一些 <code>CONFIG_XXX</code>，就能灵活地设置编译器的参数</p><p><code>cc-option</code> 也是用来判读提供给 $(CC) 的选项是否被支持，<code>cc-ldoption</code> 来判断提供给链接器的选项是否被支持 …，这样就可以最大程度支持不同版本的编译器</p><h2 id="2-参考文档"><a href="#2-参考文档" class="headerlink" title="2. 参考文档"></a>2. 参考文档</h2><p>最好的资料当然还是 kernel 文档了，推荐认真读两遍，会对 Kbuild 系统有更加深入的了解</p><p><a href="https://www.kernel.org/doc/Documentation/kbuild/makefiles.txt">Kbuild kernel document</a></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mount</title>
    <link href="/2022/01/19/linux/mount/"/>
    <url>/2022/01/19/linux/mount/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是-mount"><a href="#1-什么是-mount" class="headerlink" title="1. 什么是 mount"></a>1. 什么是 mount</h2><p>一个文件系统创建之后，并无法直接使用，相当于完成了注册，但是还未登录，对于文件系统来说，登录的这个步骤就是 mount。</p><p>一般来说，如果有一个磁盘设备，比如将一个 ext2 格式的移动硬盘(假设分配的设备名为 <code>/dev/sdb1</code>)插到了 Linux 主机上，若系统没有给我们自动挂载，就需要我们手动输入 <code>mount</code> 命令来挂载，如：</p><p><code>mount -t ext2 /dev/sdb1 /mnt/new_disk</code></p><p>这条命令的意思是：将 <code>/dev/sdb1</code> 上的 ext2 文件系统挂载到 <code>/mnt/new_disk</code> 上，其实不指定 <code>-t ext2</code> 也是可以的，系统可以探测出来具体使用的什么文件系统。</p><h2 id="2-mount-系统调用"><a href="#2-mount-系统调用" class="headerlink" title="2. mount 系统调用"></a>2. mount 系统调用</h2><p>从另一个角度来看上面的 mount 命令，不管怎么样，最终还是得切换到内核态，执行系统调用，mount 对应的系统调用为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs man">NAME<br>       mount - mount filesystem<br><br>SYNOPSIS<br>       #include &lt;sys/mount.h&gt;<br><br>       int mount(const char *source, const char *target,<br>                 const char *filesystemtype, unsigned long mountflags,<br>                 const void *data);<br></code></pre></td></tr></table></figure><p>其精确定义为：mount()  attaches the filesystem specified by source (which is often a pathname referring to a device, but can also be the pathname of a directory or file, or a dummy string) to the location (a directory or file) specified  by  the  pathname  in target.</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Proc Fs</title>
    <link href="/2022/01/19/linux/proc_fs/"/>
    <url>/2022/01/19/linux/proc_fs/</url>
    
    <content type="html"><![CDATA[<h2 id="1-procfs-是什么"><a href="#1-procfs-是什么" class="headerlink" title="1. procfs 是什么"></a>1. procfs 是什么</h2><p>众所周知，文件系统是 Linux 的骨架，proc 文件系统就是其中一个<strong>展示程序运行状态</strong>的<strong>虚拟</strong>文件系统。</p><p>如果你查看 <code>/proc</code> 目录下的内容，会发现，除了一堆数字命名的文件夹，还有很多杂七杂八的文件，比如 <code>kallsyms cpuinfo meminfo</code>，这些文件也都是系统的一些信息，比如 kallsyms 可以展示当前 vmlinux 的所有符号，cpuinfo 展示的是 cpu 的一些参数，meminfo 展示的是内存的一些参数。这些实现都比较简单；稍微复杂一些的是以数字命名的文件夹，也就是所有进程的信息，这也正是 proc 文件系统名字的由来。</p><p>之前的一篇 <a href="/2022/01/19/linux/seq_file/" title="文章">文章</a>中已经介绍了 procfs 下 <code>/proc/kallsyms</code> 以及 seq_file 的实现机制，而本文着重 procfs 的整体框架，并着重分析和 process 有关的 <code>/proc/$&#123;pid&#125;</code> 一系列内容</p><h2 id="2-procfs-的-inode-以及-file-operations"><a href="#2-procfs-的-inode-以及-file-operations" class="headerlink" title="2. procfs 的 inode 以及 file_operations"></a>2. procfs 的 inode 以及 file_operations</h2><p>了解一个文件系统，可以直接从 inode_operations &amp;&amp; file_operations 入手</p><p>在 <code>fs/proc/root.c</code> 可以查到，procfs 的根目录为 <code>/proc</code>，根目录项为 <code>proc_root</code>，对应 inode_operations 为 <code>proc_root_inode_operations</code>，最关键的就是 lookup 回调函数</p><p>其实这种虚拟文件系统的 lookup 已经比 ext 这种磁盘文件系统简化很多了，大部分 dentry 都是非常有规律地保存在内存中的，而不像磁盘那样还要和硬件存取打交道。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fs/proc/root.c</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_operations</span> <span class="hljs-title">proc_root_inode_operations</span> =</span> &#123;<br>    .lookup        = proc_root_lookup,<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_dir_entry</span> <span class="hljs-title">proc_root</span> =</span> &#123;<br>    .proc_iops    = &amp;proc_root_inode_operations, <br>    .proc_dir_ops    = &amp;proc_root_operations,<br>    .name        = <span class="hljs-string">&quot;/proc&quot;</span>,<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>proc_root_lookup</code> 逻辑非常简单：首先尝试 <code>proc_pid_lookup</code>，失败之后尝试 <code>proc_lookup</code>。从名字可以猜想一波，是不是前者和进程 pid 有关，后者比较普通呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> struct dentry *<span class="hljs-title">proc_root_lookup</span><span class="hljs-params">(struct inode * dir, struct dentry * dentry, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!proc_pid_lookup(dentry, flags))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">return</span> proc_lookup(dir, dentry, flags);<br>&#125;<br></code></pre></td></tr></table></figure><p>The anwser is: Yes!</p><p>上面已经提到，procfs 的内容正好可以分为两大类：1.进程信息；2.额外的系统信息，而 <code>/proc/$&#123;pid&#125;</code> 和 <code>/proc/cpuinfo</code> 这两种文件，对应的查找方式就分别为 <code>proc_pid_lookup</code> 和 <code>proc_lookup</code></p><p>后者是比较常见一些的，通过 rb_tree 进行目录项的查找，前者是 procfs 的基础，所以接下来探究一下 proc_pid_lookup 做了什么</p><p>如下所示，<code>proc_pid_lookup</code> 主要做了下面的几件事：</p><ol><li>通过 dentry 获取文件的 fs_info，从而得到 namespace</li><li>通过 pid 查找进程 task_struct 结构体</li><li>判断该进程是否是隐藏起来的，如果是，就无法在 procfs 中显示</li><li>初始化 pid 对应的 dentry</li></ol><p>最后一点非常有意思，什么叫初始化 dentry？这是因为，procfs 是一个虚拟文件系统，所有的文件并没有持久化保存，而是随用随取，自然，这些目录项也没有必要在系统启动的时候就创建好，而是等到 lookup 操作的时候再按需创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">struct dentry *<span class="hljs-title">proc_pid_lookup</span><span class="hljs-params">(struct dentry *dentry, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">task</span>;</span><br>    <span class="hljs-keyword">unsigned</span> tgid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_fs_info</span> *<span class="hljs-title">fs_info</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid_namespace</span> *<span class="hljs-title">ns</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">result</span> =</span> ERR_PTR(-ENOENT);<br><br>    tgid = name_to_int(&amp;dentry-&gt;d_name);<br>    <span class="hljs-keyword">if</span> (tgid == ~<span class="hljs-number">0U</span>)<br>        <span class="hljs-keyword">goto</span> out;<br><br>    <span class="hljs-comment">// 1. 获取 fs_info</span><br>    fs_info = proc_sb_info(dentry-&gt;d_sb);<br>    ns = fs_info-&gt;pid_ns;<br>    rcu_read_lock();<br>    <br>    <span class="hljs-comment">// 2. 获取 pid 对应的 task</span><br>    task = find_task_by_pid_ns(tgid, ns);<br>    <span class="hljs-keyword">if</span> (task)<br>        get_task_struct(task);<br>    rcu_read_unlock();<br>    <span class="hljs-keyword">if</span> (!task)<br>        <span class="hljs-keyword">goto</span> out;<br><br>    <span class="hljs-comment">// 3. 判断该 task 是否被隐藏</span><br>    <span class="hljs-keyword">if</span> (fs_info-&gt;hide_pid == HIDEPID_NOT_PTRACEABLE) &#123;<br>        <span class="hljs-keyword">if</span> (!has_pid_permissions(fs_info, task, HIDEPID_NO_ACCESS))<br>            <span class="hljs-keyword">goto</span> out_put_task;<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 初始化 dentry</span><br>    result = proc_pid_instantiate(dentry, task, <span class="hljs-literal">NULL</span>);<br>out_put_task:<br>    put_task_struct(task);<br>out:<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>proc_pid_instantiate</code> 主要是分配了 inode，并且设置了对应的 <code>inode_operations &amp;&amp; file_operations</code>，这样的话，下一次更深入一层，在 <code>/proc/$&#123;pid&#125;</code> 下查找目录项的时候，就会触发 <code>proc_tgid_base_inode_operations.proc_tgid_base_lookup</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_operations</span> <span class="hljs-title">proc_tgid_base_inode_operations</span> =</span> &#123;<br>    .lookup        = proc_tgid_base_lookup, <span class="hljs-comment">// !important</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> struct dentry *<span class="hljs-title">proc_pid_instantiate</span><span class="hljs-params">(struct dentry * dentry,</span></span><br><span class="hljs-params"><span class="hljs-function">                   struct task_struct *task, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span>;</span><br><br>    <span class="hljs-comment">// 创建 inode</span><br>    inode = proc_pid_make_inode(dentry-&gt;d_sb, task, S_IFDIR | S_IRUGO | S_IXUGO);<br>    <span class="hljs-keyword">if</span> (!inode)<br>        <span class="hljs-keyword">return</span> ERR_PTR(-ENOENT);<br><br>    <span class="hljs-comment">// 设置回调函数</span><br>    inode-&gt;i_op = &amp;proc_tgid_base_inode_operations;<br>    inode-&gt;i_fop = &amp;proc_tgid_base_operations; <span class="hljs-comment">// 不太重要</span><br>    inode-&gt;i_flags|=S_IMMUTABLE;<br><br>    set_nlink(inode, nlink_tgid);<br>    pid_update_inode(task, inode);<br><br>    d_set_d_op(dentry, &amp;pid_dentry_operations);<br>    <span class="hljs-keyword">return</span> d_splice_alias(inode, dentry);<br>&#125;<br></code></pre></td></tr></table></figure><p>重新整理一下，从 <code>/proc</code> 到 <code>/proc/$&#123;pid&#125;</code>，其 inode 对应的操作是不同的，前者需要兼顾进程信息和普通系统信息两种类型的文件，后者则负责查找每一个进程所对应的虚拟文件（进程状态）</p><h2 id="2-procfs-如何显示进程状态"><a href="#2-procfs-如何显示进程状态" class="headerlink" title="2. procfs 如何显示进程状态"></a>2. procfs 如何显示进程状态</h2><p>前面说到，通过一级级的 dentry 查找，触发 inode 的 lookup 函数之后，来到了 <code>proc_tgid_base_lookup</code>。</p><p>比如，如果执行命令 <code>cat /proc/1/maps</code>，就会进入 <code>proc_pident_lookup</code>，参数中 <code>dentry-&gt;d_name.name == &#39;maps&#39;</code> ，所以这个函数中就需要比较 <code>/proc/1</code> 目录下，是否有和 ‘maps’ 名字相同的文件</p><p>暂时不了解 pid_entry 结构没有关系，就算盲猜，也知道这个结构当中保存了目录项的 <code>name,name&#39;s length</code> 两个属性，这个函数的操作也就非常简单了，就是通过一个 <code>proc_pident_lookup</code>，循环比较 <code>pid_entry</code> 数组中的所有元素和当前查找的 dentry，比较名字是否相同。有意思的一点是，时间复杂度并不是 O(N)，因为 <code>/proc/$&#123;pid&#125;</code> 下的所有文件都是固定的，几乎没有改动，所以复杂度还是 O(1) 的，源码中也注明了: ‘Yes, it does not scale. And it should not’</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> struct dentry *<span class="hljs-title">proc_pident_lookup</span><span class="hljs-params">(struct inode *dir, </span></span><br><span class="hljs-params"><span class="hljs-function">                     struct dentry *dentry,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-keyword">const</span> struct pid_entry *p,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-keyword">const</span> struct pid_entry *end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">task</span> =</span> get_proc_task(dir);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">res</span> =</span> ERR_PTR(-ENOENT);<br><br>    <span class="hljs-keyword">if</span> (!task)<br>        <span class="hljs-keyword">goto</span> out_no_task;<br><br>    <span class="hljs-keyword">for</span> (; p &lt; end; p++) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;len != dentry-&gt;d_name.len)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">memcmp</span>(dentry-&gt;d_name.name, p-&gt;name, p-&gt;len)) &#123;<br>            res = proc_pident_instantiate(dentry, task, p);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    put_task_struct(task);<br>out_no_task:<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> struct dentry *<span class="hljs-title">proc_tgid_base_lookup</span><span class="hljs-params">(struct inode *dir, struct dentry *dentry, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> proc_pident_lookup(dir, dentry,<br>                  tgid_base_stuff,<br>                  tgid_base_stuff + ARRAY_SIZE(tgid_base_stuff));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>struct pid_entry</code> 用来描述一个进程下的虚拟文件，其结构如下，核心也是 iop 和 fop 这两个 operations，这样就可以控制 <code>/proc/$&#123;pid&#125;</code> 下面每一个文件的打开读取方式，以及每一个子目录的查找方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid_entry</span> &#123;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name; <span class="hljs-comment">// 目录项名称</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> len; <span class="hljs-comment">// 目录项名称长度</span><br>    <span class="hljs-keyword">umode_t</span> mode; <span class="hljs-comment">// 文件权限</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_operations</span> *<span class="hljs-title">iop</span>;</span> <span class="hljs-comment">// inode 操作</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> *<span class="hljs-title">fop</span>;</span> <span class="hljs-comment">// file 操作</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">proc_op</span> <span class="hljs-title">op</span>;</span> <span class="hljs-comment">//</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>并且，通过 NOD，DIR 等一系列宏，又可以减少很多 boilerplate 样板代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NOD(NAME, MODE, IOP, FOP, OP) &#123;            \</span><br><span class="hljs-meta">    .name = (NAME),                    \</span><br><span class="hljs-meta">    .len  = sizeof(NAME) - 1,            \</span><br><span class="hljs-meta">    .mode = MODE,                    \</span><br><span class="hljs-meta">    .iop  = IOP,                    \</span><br><span class="hljs-meta">    .fop  = FOP,                    \</span><br><span class="hljs-meta">    .op   = OP,                    \</span><br><span class="hljs-meta">&#125;</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DIR(NAME, MODE, iops, fops)    \</span><br><span class="hljs-meta">    NOD(NAME, (S_IFDIR|(MODE)), &amp;iops, &amp;fops, &#123;&#125; )</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LNK(NAME, get_link)                    \</span><br><span class="hljs-meta">    NOD(NAME, (S_IFLNK|S_IRWXUGO),                \</span><br><span class="hljs-meta">        &amp;proc_pid_link_inode_operations, NULL,        \</span><br><span class="hljs-meta">        &#123; .proc_get_link = get_link &#125; )</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REG(NAME, MODE, fops)                \</span><br><span class="hljs-meta">    NOD(NAME, (S_IFREG|(MODE)), NULL, &amp;fops, &#123;&#125;)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ONE(NAME, MODE, show)                \</span><br><span class="hljs-meta">    NOD(NAME, (S_IFREG|(MODE)),            \</span><br><span class="hljs-meta">        NULL, &amp;proc_single_file_operations,    \</span><br><span class="hljs-meta">        &#123; .proc_show = show &#125; )</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ATTR(LSM, NAME, MODE)                \</span><br><span class="hljs-meta">    NOD(NAME, (S_IFREG|(MODE)),            \</span><br><span class="hljs-meta">        NULL, &amp;proc_pid_attr_operations,    \</span><br><span class="hljs-meta">        &#123; .lsm = LSM &#125;)</span><br></code></pre></td></tr></table></figure><p>因此，一个文件的所有属性，或者说状态信息，都被抽象为了一个个子文件，或者子文件夹，也就可以使用 pid_entry 数组来表示这个结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid_entry</span> <span class="hljs-title">tid_base_stuff</span>[] =</span> &#123;<br>    DIR(<span class="hljs-string">&quot;fd&quot;</span>,        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),<br>    DIR(<span class="hljs-string">&quot;fdinfo&quot;</span>,    S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),<br>    DIR(<span class="hljs-string">&quot;ns&quot;</span>,     S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_NET</span><br>    DIR(<span class="hljs-string">&quot;net&quot;</span>,        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    REG(<span class="hljs-string">&quot;environ&quot;</span>,   S_IRUSR, proc_environ_operations),<br>    REG(<span class="hljs-string">&quot;auxv&quot;</span>,      S_IRUSR, proc_auxv_operations),<br>    ONE(<span class="hljs-string">&quot;status&quot;</span>,    S_IRUGO, proc_pid_status),<br>    ONE(<span class="hljs-string">&quot;personality&quot;</span>, S_IRUSR, proc_pid_personality),<br>    ONE(<span class="hljs-string">&quot;limits&quot;</span>,     S_IRUGO, proc_pid_limits),<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_SCHED_DEBUG</span><br>    REG(<span class="hljs-string">&quot;sched&quot;</span>,     S_IRUGO|S_IWUSR, proc_pid_sched_operations),<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    NOD(<span class="hljs-string">&quot;comm&quot;</span>,      S_IFREG|S_IRUGO|S_IWUSR,<br>             &amp;proc_tid_comm_inode_operations,<br>             &amp;proc_pid_set_comm_operations, &#123;&#125;),<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_HAVE_ARCH_TRACEHOOK</span><br>    ONE(<span class="hljs-string">&quot;syscall&quot;</span>,   S_IRUSR, proc_pid_syscall),<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    REG(<span class="hljs-string">&quot;cmdline&quot;</span>,   S_IRUGO, proc_pid_cmdline_ops),<br>    ONE(<span class="hljs-string">&quot;stat&quot;</span>,      S_IRUGO, proc_tid_stat),<br>    ONE(<span class="hljs-string">&quot;statm&quot;</span>,     S_IRUGO, proc_pid_statm),<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>相信聪明的你们已经可以举一反三了，如果是 <code>REG</code> 宏表示的 regular file，设定好 file_operations 之后，就可以通过 seq_file 接口和 <code>open/read</code> 等系统调用交互了，如果是 <code>DIR</code> 宏表示的 directory file，还需要提供新的 inode_operations，如果下一级还有目录，再提供一个 inode_operations 即可 ……</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Trace Fs</title>
    <link href="/2022/01/19/linux/trace_fs/"/>
    <url>/2022/01/19/linux/trace_fs/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Seq File</title>
    <link href="/2022/01/19/linux/seq_file/"/>
    <url>/2022/01/19/linux/seq_file/</url>
    
    <content type="html"><![CDATA[<p>Seq File 在 Linux 中很常见，因此这里稍微整理一下，也分享一下我的理解。</p><p>由于 procfs 的默认操作函数只使用一页的缓存，在处理较大的proc文件时就有点麻烦，并且在输出一系列结构体中的数据时也比较不灵活，因此内核开发者们抽象出了seq_file（Sequence file：序列文件）接口。 提供了一套简单的函数来解决以上 procfs 编程时存在的问题，使得编程更加容易。</p><p>同时也需要注意，虽然 seq_file 最一开始是为了方便 procfs 使用，但大家意识到，这玩意很 nice 啊，于是已经渗透到很多别的虚拟文件系统种，比如 debugfs，sysfs，都有很多的应用。</p><h2 id="1-API"><a href="#1-API" class="headerlink" title="1. API"></a>1. API</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs text">struct seq_file &#123;<br>    char *buf; // 序列文件对应的数据缓冲区，要导出的数据是首先打印到这个缓冲区，然后才被拷贝到指定的用户缓冲区。<br>    size_t size;  // 缓冲区大小，默认为1个页面大小，随着需求会动态以2的级数倍扩张，4k,8k,16k...<br>    size_t from;  // 没有拷贝到用户空间的数据在 buf 中的起始偏移量<br>    size_t count; // buf中没有拷贝到用户空间的数据的字节数，调用 seq_printf() 等函数向buf写数据的同时相应增加m-&gt;count<br>    size_t pad_until; // useless<br>    loff_t index;  // 正在或即将读取的数据项索引，和 seq_operations 中的start、next 操作中的 pos 项一致，一条记录为一个索引<br>    loff_t read_pos;  // 当前读取数据（file）的偏移量，字节为单位<br>    u64 version;  // 文件的版本<br>    struct mutex lock;  // 序列化对这个文件的并行操作<br>    const struct seq_operations *op;  // 指向seq_operations<br>    int poll_event; <br>    const struct file *file; // seq_file 相关的 proc 或其他文件<br>    void *private;  //指向文件的私有数据<br>&#125;;<br><br>seq_open：通常会在打开文件的时候调用，以第二个参数为 seq_operations 表创建 seq_file 结构体。<br>seq_read, seq_lseek，seq_release：直接对应着文件操作表中的 read, llseek 和 release。<br>seq_escape：将一个字符串中的需要转义的字符（字节长）以8进制的方式打印到 seq_file。<br>seq_putc, seq_puts, seq_printf：分别和C语言中的 putc，puts 和 printf 相对应。<br>seq_path：输出文件名<br>single_open, single_release: 打开和释放只有一条记录的文件。<br>seq_open_private, __seq_open_private, seq_release_private：和 seq_open 类似，不过打开 seq_file 的时候创建一小块文件私有数据，这个 private 数据会保存在 file-&gt;private 字段中，之后读取或者写入的时候，会有其特定的作用<br><br></code></pre></td></tr></table></figure><h2 id="2-procfs-和-seq-file-结合"><a href="#2-procfs-和-seq-file-结合" class="headerlink" title="2. procfs 和 seq_file 结合"></a>2. procfs 和 seq_file 结合</h2><p>以 <code>/proc/kallsyms</code> 这个文件为例，演示一下 procfs 和 seq_file 是如何结合在一起的。</p><p>先了解一下 <code>/proc/kallsyms</code> 的作用，使用 <code>sudo cat /proc/kallsyms</code> 命令，就可以查看这个<strong>虚拟文件</strong>的内容，发现是很多符号，以及符号对应的地址，其实就是目前正在运行的 kernel 的符号信息。这些信息显然不会保存在磁盘当中，是随着系统运行变化的，自然需要通过虚拟文件暴露给用户。其读取正是用到了 seq_file 以及 seq_read 一系列接口</p><h3 id="2-1-kallsyms-初始化"><a href="#2-1-kallsyms-初始化" class="headerlink" title="2.1 kallsyms 初始化"></a>2.1 kallsyms 初始化</h3><p><code>/proc/kallsyms</code> 这个文件，使用的也是 procfs 提供的 proc_create 接口进行创建的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel/kallsyms.c</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_ops</span> <span class="hljs-title">kallsyms_proc_ops</span> =</span> &#123;<br>    .proc_open  = kallsyms_open,<br>    .proc_read  = seq_read,<br>    .proc_lseek = seq_lseek,<br>    .proc_release   = seq_release_private,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init <span class="hljs-title">kallsyms_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    proc_create(<span class="hljs-string">&quot;kallsyms&quot;</span>, <span class="hljs-number">0444</span>, <span class="hljs-literal">NULL</span>, &amp;kallsyms_proc_ops);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接看这里的 <code>kallsyms_proc_ops</code> 结构，<code>proc_read</code> <code>proc_lseek</code> <code>proc_release</code> 的回调函数都很普通，关键自然在于 <code>proc_open</code> 对应的 <code>kallsyms_open</code>，通过这个名字也不难得知，通过 open 系统调用打开 <code>/proc/kallsyms</code> 文件的时候，内部则会调用该回调函数进行处理。</p><p>那么，关注一下这里的 <code>kallsyms_open</code>，内部是调用了 <code>__seq_open_private</code> 创建了一个 iter，联系上面 API 说明可知，在打开这个文件的时候，设置了一个 private 字段，用来辅助后面的 read write 操作，而这里对应的就应该是 kallsym_iter 结构了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kallsyms_open</span><span class="hljs-params">(struct inode *inode, struct file *file)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kallsym_iter</span> *<span class="hljs-title">iter</span>;</span><br>    iter = __seq_open_private(file, &amp;kallsyms_op, <span class="hljs-keyword">sizeof</span>(*iter));<br>    <span class="hljs-keyword">if</span> (!iter)<br>        <span class="hljs-keyword">return</span> -ENOMEM;<br>    reset_iter(iter, <span class="hljs-number">0</span>);<br><br>    iter-&gt;show_value = kallsyms_show_value(file-&gt;f_cred);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，<code>__seq_open_private</code> 没什么神奇的，就是分配了 private 所需要的空间，并且将 file-&gt;private 指向该 private 字段，然后返回给外层的调用者。</p><p>有了这个保存在 file-&gt;private 中的 iter，我们就赋予了 seq_read 一个<strong>状态</strong>。</p><p>这点我觉得非常重要，因为在遍历 kernel symbols 的过程中，必须要清楚当前读取到了哪一步，或者说当前的状态是什么样的。对于有一些静态信息来说，则无关紧要，不需要保存<strong>状态</strong>，也就不用通过 <code>__seq_open_private</code> 来打开文件了。</p><p>与之对应，在 release 文件的时候，需要销毁这个额外分配出来的 private 字段，因此，proc_release 对应的是 <code>seq_release_private</code>，而非普通的 <code>seq_release</code>。</p><p>并且 <code>__seq_open_private</code> 传入了一个很重要的参数：<code>kallsyms_op</code>，这就是遍历并读取 seq_file 的几个核心 API，看上去非常简单，事实上也正是如此，通过 <code>start, next, stop, show</code> 的配合，决定该 seq_file 的读取如何开始，何时结束，如何展示，这就是典型的内核提供的机制，<strong>用户</strong>提供策略（当然不是普通的用户），填充好回调函数，就能按照机制走流程，在特定的位置上调用这些回调函数即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seq_operations</span> <span class="hljs-title">kallsyms_op</span> =</span> &#123;<br>    .start = s_start,<br>    .next = s_next,<br>    .stop = s_stop,<br>    .show = s_show<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span> *__seq_open_private(struct file *f, <span class="hljs-keyword">const</span> struct seq_operations *ops,<br>        <span class="hljs-keyword">int</span> psize)<br>&#123;<br>    <span class="hljs-keyword">int</span> rc;<br>    <span class="hljs-keyword">void</span> *<span class="hljs-keyword">private</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seq_file</span> *<span class="hljs-title">seq</span>;</span><br><br>    <span class="hljs-keyword">private</span> = kzalloc(psize, GFP_KERNEL_ACCOUNT);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">private</span> == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">goto</span> out;<br><br>    rc = seq_open(f, ops);<br>    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> out_free;<br><br>    seq = f-&gt;private_data;<br>    seq-&gt;<span class="hljs-keyword">private</span> = <span class="hljs-keyword">private</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">private</span>;<br><br>out_free:<br>    kfree(<span class="hljs-keyword">private</span>);<br>out:<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>EXPORT_SYMBOL(__seq_open_private);<br></code></pre></td></tr></table></figure><h3 id="2-2-seq-read-API"><a href="#2-2-seq-read-API" class="headerlink" title="2.2. seq_read API"></a>2.2. seq_read API</h3><p><code>seq_operations</code> 中的 <code>start, next, stop, show</code> 最终都是要在读取文件的时候起作用的，seq_file 的读取文件的函数为 <code>seq_read</code>，在作用了一些简单的初始化操作之后，比如分配 buf，设置好 size，紧接着就调用了 <code>seq_read_iter</code>，这才是读取文件的核心 API</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">seq_read</span><span class="hljs-params">(struct file *file, <span class="hljs-keyword">char</span> __user *buf, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">loff_t</span> *ppos)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">iov</span> =</span> &#123; .iov_base = buf, .iov_len = size&#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kiocb</span> <span class="hljs-title">kiocb</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iov_iter</span> <span class="hljs-title">iter</span>;</span><br>    <span class="hljs-keyword">ssize_t</span> ret;<br><br>    init_sync_kiocb(&amp;kiocb, file);<br>    iov_iter_init(&amp;iter, READ, &amp;iov, <span class="hljs-number">1</span>, size);<br><br>    kiocb.ki_pos = *ppos;<br>    ret = seq_read_iter(&amp;kiocb, &amp;iter);<br>    *ppos = kiocb.ki_pos;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br>EXPORT_SYMBOL(seq_read);<br></code></pre></td></tr></table></figure><p><code>seq_read_iter</code> 中，省去一些细枝末节的部分，就是下面这样的结构，先调用 <code>op-&gt;start(...)</code>，然后在一个 while 循环中，通过 <code>op-&gt;show()</code> 进行展示，通过 <code>op-&gt;next()</code> 进行迭代，直到 <strong>EOF</strong> 或者发生了错误，这才跳出循环，调用 <code>op-&gt;stop()</code>，同时，循环中还需要注意 m-&gt;buf 是否超出了原先分配的大小，如果超出了，需要重新分配缓冲，并且调用 <code>op-&gt;start()</code> <strong>重启</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">seq_read_iter</span><span class="hljs-params">(struct kiocb *iocb, struct iov_iter *iter)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ....</span><br>    m-&gt;from = <span class="hljs-number">0</span>;<br>    p = m-&gt;op-&gt;start(m, &amp;m-&gt;index);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        err = PTR_ERR(p);<br>        <span class="hljs-keyword">if</span> (!p || IS_ERR(p))    <span class="hljs-comment">// EOF or an error</span><br>            <span class="hljs-keyword">break</span>;<br>        err = m-&gt;op-&gt;show(m, p);<br>        <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)        <span class="hljs-comment">// hard error</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (unlikely(err))    <span class="hljs-comment">// -&gt;show() says &quot;skip it&quot;</span><br>            m-&gt;count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (unlikely(!m-&gt;count)) &#123; <span class="hljs-comment">// empty record</span><br>            p = m-&gt;op-&gt;next(m, p, &amp;m-&gt;index);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!seq_has_overflowed(m)) <span class="hljs-comment">// got it</span><br>            <span class="hljs-keyword">goto</span> Fill;<br>        <span class="hljs-comment">// need a bigger buffer</span><br>        m-&gt;op-&gt;stop(m, p);<br>        kvfree(m-&gt;buf);<br>        m-&gt;count = <span class="hljs-number">0</span>;<br>        m-&gt;buf = seq_buf_alloc(m-&gt;size &lt;&lt;= <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (!m-&gt;buf)<br>            <span class="hljs-keyword">goto</span> Enomem;<br>        p = m-&gt;op-&gt;start(m, &amp;m-&gt;index);<br>    &#125;<br>    <span class="hljs-comment">// EOF or an error</span><br>    m-&gt;op-&gt;stop(m, p);<br>    m-&gt;count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">goto</span> Done;<br>    <span class="hljs-comment">// ...</span><br>    copied = m-&gt;count ? -EFAULT : err;<br>    <span class="hljs-keyword">return</span> copied;<br>&#125;<br>EXPORT_SYMBOL(seq_read_iter);<br></code></pre></td></tr></table></figure><p>而所有输出的内容，其实都会保存在 m-&gt;buf 当中，最后一次性从内核空间返回给读取该文件的用户</p><h3 id="2-3-kallsyms-如何迭代"><a href="#2-3-kallsyms-如何迭代" class="headerlink" title="2.3 kallsyms 如何迭代"></a>2.3 kallsyms 如何迭代</h3><p>现在我们已经基本了解了 seq_file 是如何运转的了，接下俩接着解决 kallsyms 的问题，我们还剩下一个问题没有讨论：<code>seq_operations</code> 中回调函数的实现细节</p><p>可以看出，<code>s_next s_start</code> 都是调用了 <code>update_iter</code> 进行调用，如果返回为 0，表明遇到了 EOF 或者发生了错误，直接返回 NULL 就好了，这样在 <code>seq_read_iter</code> 当中，就能及时跳出循环。</p><p>而这里的 <code>s_stop</code> 什么都没做，其实也没有什么好做的，并没有什么资源啊的等待释放。</p><p><code>s_show</code> 给人一种亲切感，因为这个函数中的 <code>seq_printf</code> 输出的格式，不就是执行 <code>sudo cat /proc/kallsyms</code> 得到的单行的文件内容吗！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">s_next</span><span class="hljs-params">(struct seq_file *m, <span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">loff_t</span> *pos)</span></span><br><span class="hljs-function"></span>&#123;<br>    (*pos)++;<br><br>    <span class="hljs-keyword">if</span> (!update_iter(m-&gt;<span class="hljs-keyword">private</span>, *pos))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">s_start</span><span class="hljs-params">(struct seq_file *m, <span class="hljs-keyword">loff_t</span> *pos)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!update_iter(m-&gt;<span class="hljs-keyword">private</span>, *pos))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> m-&gt;<span class="hljs-keyword">private</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">s_stop</span><span class="hljs-params">(struct seq_file *m, <span class="hljs-keyword">void</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">s_show</span><span class="hljs-params">(struct seq_file *m, <span class="hljs-keyword">void</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">void</span> *value;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kallsym_iter</span> *<span class="hljs-title">iter</span> =</span> m-&gt;<span class="hljs-keyword">private</span>;<br><br>    <span class="hljs-comment">/* Some debugging symbols have no name.  Ignore them. */</span><br>    <span class="hljs-keyword">if</span> (!iter-&gt;name[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    value = iter-&gt;show_value ? (<span class="hljs-keyword">void</span> *)iter-&gt;value : <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">if</span> (iter-&gt;module_name[<span class="hljs-number">0</span>]) &#123;<br>        <span class="hljs-keyword">char</span> type;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Label it &quot;global&quot; if it is exported,</span><br><span class="hljs-comment">         * &quot;local&quot; if not exported.</span><br><span class="hljs-comment">         */</span><br>        type = iter-&gt;exported ? <span class="hljs-built_in">toupper</span>(iter-&gt;type) :<br>                    <span class="hljs-built_in">tolower</span>(iter-&gt;type);<br>        seq_printf(m, <span class="hljs-string">&quot;%px %c %s\t[%s]\n&quot;</span>, value,<br>               type, iter-&gt;name, iter-&gt;module_name);<br>    &#125; <span class="hljs-keyword">else</span><br>        seq_printf(m, <span class="hljs-string">&quot;%px %c %s\n&quot;</span>, value,<br>               iter-&gt;type, iter-&gt;name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，<code>update_iter</code> 做了什么呢？就留给读者自己去研究吧！</p><h2 id="3-自己写一个-proc-seeq-file"><a href="#3-自己写一个-proc-seeq-file" class="headerlink" title="3. 自己写一个 proc seeq_file"></a>3. 自己写一个 proc seeq_file</h2><p>了解 seq_file 的使用方式之后，自己来写一个类似 kallsyms 的模块也是轻而易举的事情了。</p><p>如下所示，是输出当前的所有进程，同时更新 offset 这个变量（其实就是 line number），除了 seq_file 和 procfs 的处理以外，还用到了 <code>init_task</code> 这个全局变量，是系统初始化时候创建的进程，同时，这些进程都以链表的方式存放，可以调用 <code>next_task</code> 获取下一个进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/proc_fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/seq_file.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/percpu.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/sched.h&gt;</span></span><br><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;Girish Joshi&quot;</span>);<br>MODULE_DESCRIPTION(<span class="hljs-string">&quot;HelloWorld Linux Kernel Module.&quot;</span>);<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_dir_entry</span> *<span class="hljs-title">entry</span>;</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">loff_t</span> offset = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">l_start</span><span class="hljs-params">(struct seq_file *m, <span class="hljs-keyword">loff_t</span> * pos)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">loff_t</span> index = *pos;<br>    <span class="hljs-keyword">loff_t</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> * <span class="hljs-title">task</span> ;</span><br><br>    <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>        seq_printf(m, <span class="hljs-string">&quot;Current all the processes in system:\n&quot;</span><br>                <span class="hljs-string">&quot;%-24s%-5s%-5s\n&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;pid&quot;</span>,<span class="hljs-string">&quot;index&quot;</span>);<br>        printk(KERN_EMERG <span class="hljs-string">&quot;++++++++++=========&gt;%5d\n&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> &amp;init_task;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>, task=&amp;init_task; i &lt; index; i++)&#123;<br>            task = next_task(task);    <br>        &#125;<br>        BUG_ON(i != *pos);<br>        <span class="hljs-keyword">if</span>(task == &amp;init_task)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>        printk(KERN_EMERG <span class="hljs-string">&quot;++++++++++&gt;%5d\n&quot;</span>, task-&gt;pid);<br>        <span class="hljs-keyword">return</span> task;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">l_next</span><span class="hljs-params">(struct seq_file *m, <span class="hljs-keyword">void</span> *p, <span class="hljs-keyword">loff_t</span> * pos)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> * <span class="hljs-title">task</span> =</span> (struct task_struct *)p;<br><br>    task = next_task(task);<br>    <span class="hljs-keyword">if</span> ((*pos != <span class="hljs-number">0</span>) &amp;&amp; (task == &amp;init_task)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    printk(KERN_EMERG <span class="hljs-string">&quot;=====&gt;%5d\n&quot;</span>, task-&gt;pid);<br>    offset = ++(*pos);<br><br>    <span class="hljs-keyword">return</span> task;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">l_stop</span><span class="hljs-params">(struct seq_file *m, <span class="hljs-keyword">void</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br>    printk(KERN_EMERG <span class="hljs-string">&quot;------&gt;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">l_show</span><span class="hljs-params">(struct seq_file *m, <span class="hljs-keyword">void</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> * <span class="hljs-title">task</span> =</span> (struct task_struct *)p;<br><br>    seq_printf(m, <span class="hljs-string">&quot;%-24s%-5d\t%-5lld\n&quot;</span>, task-&gt;comm, task-&gt;pid, offset);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// for se_file traverse</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seq_operations</span> <span class="hljs-title">kallprocesses_seq_fops</span> =</span> &#123;<br>    .start = l_start,<br>    .next  = l_next,<br>    .stop  = l_stop,<br>    .show  = l_show<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kallprocesses_open</span><span class="hljs-params">(struct inode *inode, struct file *file)</span></span><br><span class="hljs-function"></span>&#123;<br>        seq_open(file, &amp;kallprocesses_seq_fops);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// for proc fs&#x27;s file operations</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_ops</span> <span class="hljs-title">kallprocesses_proc_ops</span> =</span> &#123;<br>        .proc_open      = kallprocesses_open,<br>        .proc_read      = seq_read,<br>        .proc_lseek     = seq_lseek,<br>        .proc_release   = seq_release,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init <span class="hljs-title">hello_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    entry = proc_create(<span class="hljs-string">&quot;kallprocesses&quot;</span>, <span class="hljs-number">0444</span>, <span class="hljs-literal">NULL</span>, &amp;kallprocesses_proc_ops);<br>    printk(KERN_INFO <span class="hljs-string">&quot;Hello world!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// Non-zero return means that the module couldn&#x27;t be loaded.</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __exit <span class="hljs-title">hello_cleanup</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    printk(KERN_INFO <span class="hljs-string">&quot;Cleaning up module.\n&quot;</span>);<br>&#125;<br><br>module_init(hello_init);<br>module_exit(hello_cleanup);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LCD vs OLED</title>
    <link href="/2022/01/19/hardware/LCD%20vs%20OLED/"/>
    <url>/2022/01/19/hardware/LCD%20vs%20OLED/</url>
    
    <content type="html"><![CDATA[<h2 id="1-LCD-原理"><a href="#1-LCD-原理" class="headerlink" title="1. LCD 原理"></a>1. LCD 原理</h2><p>LCD 的发光，简要概括为：所有像素点对应一个背光层，负责发光，每个像素点最外层对应一个彩色滤光片，由中间层的正负极电路来控制液晶层的偏角，从而控制 RGB 三种颜色的混合比例。</p><h2 id="2-OLED-原理"><a href="#2-OLED-原理" class="headerlink" title="2. OLED 原理"></a>2. OLED 原理</h2><p>OLED 全程为 Organic Light-Emitting Diode，即有机发光二极管</p><p>OLED 是一种特殊设计的自发光二极管，通过正负极电路，控制夹在中间的发光二极管发光。通电就亮，通电越多，亮度越高，通过控制每一个二极管的通电，控制 RGB 三种颜色的配比。</p><h2 id="3-对比"><a href="#3-对比" class="headerlink" title="3. 对比"></a>3. 对比</h2><h3 id="3-1-OLED-优点"><a href="#3-1-OLED-优点" class="headerlink" title="3.1 OLED 优点"></a>3.1 OLED 优点</h3><ol><li>耗电</li></ol><p>相比于 LCD 屏幕，OLED 每一个像素点都是独立控制的，不需要一整块背光层发光，这样最大的好处是：<strong>省电</strong>。对于 LCD 来说，一打开屏幕，整个背光层都得发光，耗电量可想而知</p><ol start="2"><li>对比度</li></ol><p>同时，OLED 的对比度也是一个很大的优势。因为 LCD 的液晶层无法完全闭合，以过滤所有背光层的光线，因此，最暗的情况下，也仅仅是显示深黑色，而 OLED 由于没有使用背光层，每一个像素点都是独立控制的，直接断开像素点的供电，就可以显示黑色。</p><ol start="3"><li>漏光</li></ol><p>由于 LCD 采用的这块背光层，在屏幕和边框的衔接处，光纤就容易漏出去，表现为光晕问题，OLED 则没有这个问题</p><ol start="4"><li>屏幕响应时间</li></ol><p>LCD 屏幕的控制是通过控制液晶分子的偏转来完成的，液晶层的偏转速度就成为了决定因素，而液晶的偏转速度，是和温度直接挂钩的，温度越低，偏转越慢，因此，低温下，LCD 屏幕会出现非常明显的拖影现象。OLED 则没有这些问题，对于显示游戏画面这种来回切换的动态画面，具有天生的优势</p><ol start="5"><li>厚度</li></ol><p>LCD 叠加的层数比 OLED 多很多，因此，厚度也要高出不少，对于手机设计来说，屏幕厚度的减少，就意味着可以有更多的容量装下大容量的电池，或者干脆把手机做薄</p><ol start="6"><li>柔性</li></ol><p>LCD 的背光层是硬质基材，这就导致其无法实现大幅度的弯曲，OLED 则没有这个问题，这也就不奇怪，目前市面上的所有曲面屏手机，都采用的 OLED 材质的屏幕了</p><h3 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h3><ol><li>寿命</li></ol><p>对于 OLED 来说，其电压直接施压在自发光二极管上，导致电子频繁在 OLED 的发光层迁移，加上发光层是有机物，相比于 LCD 就更容易老化</p><ol start="2"><li>调光方式</li></ol><p>目前 OLED 屏幕大多采用 PWM，通过占空比来调整亮度，也就是通过一开一关，一开一关，调整 开/关 两种状态的比值，就可以控制发光的强度，比如，一个周期内，80% 的时间开，20% 的时间关，发光强度就接近最高值的 80%。但是这样调光，就会产生频闪，如果 PWM 频率比较低，频闪间隔低，就会被人眼捕获，会让人眼更加疲劳，加上 OLED 为了防止过快老化，无法使用高频 PWM 调光，这就不可避免的产生用眼疲劳的问题。另一种调光方式 DC 调光虽然不会造成这些问题，但由于其显示特性，不太适合 OLED 屏幕。</p><p>Tips：<br>    这里提一句，大家都听说过蓝光眼镜，屏幕的蓝光对于眼睛损伤比较大，这是因为蓝光的波长比较短，能量比较高，而很多产商都在积极优化自家屏幕的蓝光频率，努力将其提高，这样就能减少对于人眼的损害</p><h2 id="3-future"><a href="#3-future" class="headerlink" title="3. future"></a>3. future</h2><p>可以看到，LCD 和 OLED 都有不尽如人意的地方，不管怎么改进，似乎都无法挽回这些先天的劣势，那么，目前屏幕的发展趋势是什么呢？有没有一种革新的技术，可以替代这二者呢？答案是有：micro-LED</p><p>micro—LED 相比于 LCD，最大的改进之处在于，将中间的液晶层去掉，也去掉了背光板，每一个像素下面安放独立的 LED 灯珠，用电来直接控制这个灯珠的亮度，来混合像素点的亮度，同时，也不需要滤光层来过滤，直接发射对应颜色的光线。</p><p>micro-LED 可以说是集成了 LCD 和 OLED 的全部优点，只不过目前还无法实现量产，目前有一种“过渡”的技术，也就是现在大火的 mini-LED，将原先的 LCD 背光层进行了切割，虽然比不上 micro-LED 的像素级别的精细度，但相较于原先的一整块背光屏，还是提高了不少。</p><h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><p><a href="https://www.bilibili.com/video/BV1Wz411B7Tf">硬件茶谈 科普 LDC和OLED</a></p>]]></content>
    
    
    <categories>
      
      <category>hardware</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PCIE</title>
    <link href="/2022/01/19/hardware/pcie/"/>
    <url>/2022/01/19/hardware/pcie/</url>
    
    <content type="html"><![CDATA[<h2 id="1-South-bridge"><a href="#1-South-bridge" class="headerlink" title="1. South bridge"></a>1. South bridge</h2><p>在解释 PCIE 之前，有必要先来解释一下 South bridge，cpu，主板之间的一些概念。</p><p>大家都知道，计算机中所有的数据都需要交给 CPU 处理才能发挥作用（不完全对），但那么多的设备，难道都需要和 CPU 交互吗？</p><p>当然不行，那样不仅极大地加重了 CPU 的负担（无论是制造还是运行），对于主板的布线也是一大考验，那有什么解决方案呢？</p><p>其实，这里可以<strong>分级</strong>的思想：对于内存，显卡这些需要高速交互的设备，让 CPU 和它们之间使用高速线路直接连通，对于 USB 接口，外接硬盘，键盘，声卡，网卡这些设备来说，要求就没有那么高了，可以统一交给一个<strong>下属</strong>去管理，然后统一上报给 CPU 就好了，这个下属就是 Sourth Bridge 南桥芯片组。</p><p>简要来说，南桥芯片组的任务就是，作为一个中间人，和外围低速设备以及 CPU 之间通信</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><br>-------------<br>-------------   -------- memory --<br>---  cpu  ---<br>-------------   -------- memory --<br>-------------<br>    |   |    \<br>    |   |     \ <br>    |   |      \<br>    |   |       \<br>    |   |        \<br>    /   /         \ <br>---- 显卡 ----     \ <br>    /   /           --------------- ----- sound card<br>    |   |           --------------- ----- usb<br>---- other ----     -South bridege- ----- net card<br>                    --------------- ----- hard disk<br>                    --------------- ----- ...<br><br></code></pre></td></tr></table></figure><h2 id="2-PCIE"><a href="#2-PCIE" class="headerlink" title="2. PCIE"></a>2. PCIE</h2><p>现在你对于南桥芯片，以及设备有一个基本的概念了，外围设备，CPU，芯片之间都需要传输数据，这就引入了总线，大家自然希望总线传输速度快，传输的数据多，可以将其类比成道路，我们自然是希望道路越宽越好，道路上的车辆速度越快越好（当然在遵守规则前提下）。</p><p>“速度”和“传输的数据”有两个更加专业的表达，分别是 <strong>延迟</strong> 和 <strong>带宽</strong></p><p>目前的总线普遍采用 PCIE 这种高速总线，其实，它的发展过程也非常有意思。</p><h3 id="2-1-PCIE-如何登上历史舞台的"><a href="#2-1-PCIE-如何登上历史舞台的" class="headerlink" title="2.1 PCIE 如何登上历史舞台的"></a>2.1 PCIE 如何登上历史舞台的</h3><p>上世纪 PC 刚进入大众视野的时候，那时候的设备使用的接口是千奇百怪啊，声卡，网卡，显卡 接口都不一样，而这些设备都要接在主板上，就导致，你选购的主板上的接口，直接决定了你能使用什么设备</p><p>为了解决这个问题，IBM 和 Intel 推出了 ISA 接口这个标准，不过已经非常久远了，在上世纪 80 年代，大规模推广开来。ISA 接口规范虽然做到了统一，但是其内部采用了并行传输，加上当时的抗干扰技术还不强，传输速率自然就很低。并且，插上一个设备之后，无法自动配置，需要手动配置资源，其支持的外围设备仅有 6 个。</p><p>不过技术总是在进步，ISA 总线逐步被更先进的总线技术替换，最终统一天下的是 PCI 总线了。PCI 总线不仅将带宽从原先的 8 MB/s 提高到了 256 MB/s，还做到了即插即用，大大省去了人们的烦恼。但是 PCI 总线仍然采用并行传输的方式，高负载下，多个设备会同时抢占总线带宽，也会对彼此传输的数据产生干扰，仍然不是最完美的方案。</p><p>再往后发展，就由今天的主角 <strong>PCIE</strong> 接管历史舞台了。</p><h3 id="2-2-PCIE-的一些概念"><a href="#2-2-PCIE-的一些概念" class="headerlink" title="2.2 PCIE 的一些概念"></a>2.2 PCIE 的一些概念</h3><h4 id="2-2-1-PCIE-形态"><a href="#2-2-1-PCIE-形态" class="headerlink" title="2.2.1 PCIE 形态"></a>2.2.1 PCIE 形态</h4><p>PCIE 总线用来连接设备和芯片，并且会提供一些插槽，比如显卡就是插在 PCIE  插槽上的。除了以这种<strong>接口</strong>的形态存在，还会以<strong>通道</strong>的形态存在，这怎么理解呢？</p><p>以硬盘使用的 M.2 接口为例，其内部传输其实还是用的 PCIE，只不过，对外暴露的是 M.2 这种专用的接口而已，PCIE 就相当于一个连接 M.2 接口和芯片之间的通道，第二种存在形态：<strong>通道</strong> 也就因此得名。</p><p>再比如说雷电3接口，内部也是用 PCIE 进行的传输，PCIE 也仅仅是桥接了一下而已。</p><h4 id="2-2-2-PCIE-带宽"><a href="#2-2-2-PCIE-带宽" class="headerlink" title="2.2.2 PCIE 带宽"></a>2.2.2 PCIE 带宽</h4><p>PCIE 的带宽按照针脚的数量进行计算，最少的是 <code>X1</code>，再之后依次为 <code>X2</code> <code>X4</code> <code>X8</code> <code>X16</code>，带宽依次翻倍。显卡就是插在 <code>X16</code> 这个带宽最大的插槽上的，当然，插在 <code>X8</code> <code>X4</code> 这些插槽上也没有问题，只不过带宽会相应降低。</p><p>其实随着 PCIE 不断完善，不断推出了更高带宽的 PCIE 标准，从最一开始的 PCIE 1.0，<code>X1</code> 的带宽只有 250 MB/s，每升级一次，带宽都要翻倍，到目前的 PCIE 6.0，<code>X1</code> 的带宽已经有 8 GB/s，<code>X16</code> 的带宽更是有 8*16 GB/s，相当恐怖了。</p><h4 id="2-2-3-PCIE-在主板上分布"><a href="#2-2-3-PCIE-在主板上分布" class="headerlink" title="2.2.3 PCIE 在主板上分布"></a>2.2.3 PCIE 在主板上分布</h4><p>由于主板上的空间是有限的，加上 CPU 对于 PCIE 的支持也是有限的，因此那些直连 CPU 的有限数量的 PCIE 就显得非常宝贵了，一般都用作显卡插槽了。</p><p>虽然南桥芯片组上也一般会接一些非直连 PCIE 总线，但是，由于带宽的限制，肯定是无法达到该 PCIE 带宽的理论值上限的。常见的情况有，将固态硬盘插在了第二块 M.2 插槽上，由于该插槽不是直连 CPU 的，速率比理论值直接腰斩都是有可能的。</p>]]></content>
    
    
    <categories>
      
      <category>hardware</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux initcall 机制</title>
    <link href="/2022/01/18/linux/initcall/"/>
    <url>/2022/01/18/linux/initcall/</url>
    
    <content type="html"><![CDATA[<h2 id="1-initcall-设计思想"><a href="#1-initcall-设计思想" class="headerlink" title="1. initcall 设计思想"></a>1. initcall 设计思想</h2><p>linux 对驱动程序提供静态编译进内核和动态加载两种方式，当我们试图将一个驱动程序编译进内核时，开发者通常提供一个xxx_init() 函数接口，以启动这个驱动程序同时提供某些服务。</p><p>那么，根据常识来说，这个 xxx_init() 函数肯定是要在系统启动的某个时候被调用，才能启动这个驱动程序。</p><p>最简单直观地做法就是：开发者试图添加一个驱动程序时，在内核启动 init 程序的某个地方直接添加调用自己驱动程序的 xxx_init()函数，在内核启动时自然会调用到这个程序。</p><p>但是在 linux 这么庞大的系统中，如果驱动程序是这么个玩法，那简直是一场灾难。</p><p>不难想到另一种方式，就是集中提供一个地方，如果你要添加你的驱动程序，你就将你的初始化函数在这个地方进行添加，在内核启动的时候统一扫描这个地方，再执行这一部分的所有被添加的驱动程序。</p><p>那到底怎么添加呢？直接在C文件中作一个列表，在里面添加初始化函数？我想随着驱动程序数量的增加，这个列表会让人头昏眼花。</p><p>当然，对于 linux 社区的大神来说，这些都不是事，他们选择的做法是：</p><p>底层实现上，在内核编译得到的 elf 文件中，自定义一个段，这个段里面专门用来存放这些初始化函数的地址（也会被拷贝到镜像中），内核启动时，只需要在这个段地址处取出函数指针，一个个执行即可。</p><p>对上层而言，linux内核提供 xxx_init(init_func)宏定义接口,驱动开发者只需要将驱动程序的 init_func 使用 <code>__init</code> 来修饰，这个函数就被自动添加到了上述的段中，开发者完全不需要关心实现细节。</p><p>同时，如果是运行过程当中添加的模块，也需要执行 init 函数 和 exit 函数，其原理也和 initcall 有关</p><p>对于各种各样的驱动而言，可能存在一定的依赖关系，需要遵循先后顺序来进行初始化，考虑到这个，linux也对这一部分做了分级处理。</p><h2 id="2-深入-initcall"><a href="#2-深入-initcall" class="headerlink" title="2. 深入 initcall"></a>2. 深入 initcall</h2><p>下面先举一个例子，然后一步步探究 Linux 中对于 initcall 的处理方式</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fs/io_uring.c</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init <span class="hljs-title">io_uring_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>    ...<br>&#125;;<br>__initcall(io_uring_init);<br></code></pre></td></tr></table></figure><p>io_uring 是一个比较新的异步 IO 机制，<code>fs/io_uring.c</code> 中定义了 io_uring_init 这个函数，字如其名，一看就是用作初始化的，该函数头上也加上了 <code>__init</code> 这个宏，并且，使用 <code>__initcall</code>，虽然我们还不知道具体的作用，但再次印证了 “初始化函数” 这个方向没有问题</p><p>或者如果编写一个内核模块，也需要通过 <code>module_init</code> 和 <code>module_exit</code>，如果缺少了这两个宏，内核模块的编译就无法通过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init <span class="hljs-title">hello_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    printk(KERN_INFO <span class="hljs-string">&quot;Hello world!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __exit <span class="hljs-title">hello_cleanup</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    printk(KERN_INFO <span class="hljs-string">&quot;Cleaning up module.\n&quot;</span>);<br>&#125;<br><br>module_init(hello_init);<br>module_exit(hello_cleanup);<br></code></pre></td></tr></table></figure><p>那么问题来了，<code>__init</code> <code>__initcall</code> <code>module_init</code> 是些什么鬼，背后有什么不为人知的魔法吗？</p><h3 id="2-1-init-是什么鬼"><a href="#2-1-init-是什么鬼" class="headerlink" title="2.1 __init 是什么鬼"></a>2.1 __init 是什么鬼</h3><p>其实，<code>__init</code> 的作用非常简单，主要就是将符号定义在 <code>.init.text</code> 这个 section 当中，而不是放在函数默认的 ‘.text’ section 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/init.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __init  __section(<span class="hljs-meta-string">&quot;.init.text&quot;</span>) __cold  __latent_entropy __noinitretpoline</span><br></code></pre></td></tr></table></figure><p><code>__initcall</code> 定义在 <code>include/linux/init.h</code> 文件中，从下往上查找，最终发现，也是定义了符号所处的 section</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/linux/init.h</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ___define_initcall(fn, id, __sec) \</span><br><span class="hljs-meta"> static initcall_t __initcall_##fn##id __used \</span><br><span class="hljs-meta">  __attribute__((__section__(#__sec <span class="hljs-meta-string">&quot;.init&quot;</span>))) = fn;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __define_initcall(fn, id) ___define_initcall(fn, id, .initcall##id)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> device_initcall(fn)  __define_initcall(fn, 6)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __initcall(fn) device_initcall(fn)</span><br></code></pre></td></tr></table></figure><p>如果将上面的宏代入 <code>__initcall(io_uring_init)</code> 并展开之后，其实相当于<br><code>static initcall_t __initcall_io_uring_init6 __attribute__((__used__)) __attribute__((__section__(&quot;.initcall6.init&quot;))) = io_uring_init;</code></p><p>这行代码的意思是：声明一个类型为<code>initcall_t</code> 的函数指针 <code>__initcall_io_uring_init6</code>，并且将其放在 ‘.initcall6.init’ 段中，并且函数指针指向 io_uring_init 这个初始化函数。同时，<code>__used__</code> 这个声明，会告诉编译器：保留这个符号，不要因为当前没有使用这个符号，而直接优化</p><p>其实，<code>init.h</code> 文件中还定义了很多别的类似的宏，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pure_initcall(fn)  __define_initcall(fn, 0)</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> core_initcall(fn)  __define_initcall(fn, 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> core_initcall_sync(fn)  __define_initcall(fn, 1s)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> postcore_initcall(fn)  __define_initcall(fn, 2)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> postcore_initcall_sync(fn) __define_initcall(fn, 2s)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> arch_initcall(fn)  __define_initcall(fn, 3)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> arch_initcall_sync(fn)  __define_initcall(fn, 3s)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> subsys_initcall(fn)  __define_initcall(fn, 4)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> subsys_initcall_sync(fn) __define_initcall(fn, 4s)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fs_initcall(fn)   __define_initcall(fn, 5)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fs_initcall_sync(fn)  __define_initcall(fn, 5s)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rootfs_initcall(fn)  __define_initcall(fn, rootfs)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> device_initcall(fn)  __define_initcall(fn, 6)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> device_initcall_sync(fn) __define_initcall(fn, 6s)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> late_initcall(fn)  __define_initcall(fn, 7)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> late_initcall_sync(fn)  __define_initcall(fn, 7s)</span><br></code></pre></td></tr></table></figure><p>这里 <code>__define_initcall(fn, 0)</code> 中的数字作用，先按下不表，后续会揭露</p><p>而内核模块必不可少的 <code>module_init</code> 就相当于 <code>__initcall</code>，同样是定义了一个位于 ‘.initcall6.init’ section 的函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> module_init(x) __initcall(x);</span><br></code></pre></td></tr></table></figure><p>Soga，原来所谓的 <code>__initcall</code> <code>module_init</code>，只不过是将创建一个位于 ‘.initcallx.init’ section 的函数指针，指向特定的 init 函数。</p><p>那么问题来了，这些函数指针是如何起作用的呢？init 函数需要我们手动调用吗？还是有更加神奇的魔法，可以自动完成一系列 init 函数的调用呢？</p><h3 id="2-3-initcall-调用时机"><a href="#2-3-initcall-调用时机" class="headerlink" title="2.3 initcall 调用时机"></a>2.3 initcall 调用时机</h3><p>从内核 C 函数起始部分，也就是 <code>start_kernel</code> 开始往下挖，在 <code>do_initcalls</code> 可以找到对于散布在各个模块中的 initcall 的调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">start_kernel  <br> -&gt; rest_init();<br>  -&gt; kernel_thread(kernel_init, NULL, CLONE_FS);<br>   -&gt; kernel_init()<br>    -&gt; kernel_init_freeable();<br>     -&gt; do_basic_setup();<br>      -&gt; do_initcalls();  <br></code></pre></td></tr></table></figure><p><code>do_initcalls</code> 大致的作用是，遍历 0-initcall_levels，并且依次调用对应 level 的 do_initcall_level 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">initcall_t</span> *initcall_levels[] __initdata = &#123;<br> __initcall0_start,<br> __initcall1_start,<br> __initcall2_start,<br> __initcall3_start,<br> __initcall4_start,<br> __initcall5_start,<br> __initcall6_start,<br> __initcall7_start,<br> __initcall_end,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __init <span class="hljs-title">do_initcalls</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// ...</span><br> <span class="hljs-keyword">for</span> (level = <span class="hljs-number">0</span>; level &lt; ARRAY_SIZE(initcall_levels) - <span class="hljs-number">1</span>; level++) &#123;<br>  <span class="hljs-built_in">strcpy</span>(command_line, saved_command_line);<br>  do_initcall_level(level, command_line);<br> &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里就可以揭秘之前卖下的一个关子了，<code>__define_initcall(fn, 6)</code> 中的数字，就对应了 do_initcall_level 中的 level，level 越小，优先级越高，越早调用模块中的 initcall 函数。</p><p>这一点也可以从 <code>pure_initcall</code> <code>core_initcall</code> 这些宏定义的名字看出，core 也就是<strong>核心</strong>的意思，自然优先级很高才对，印证了 <code>__define_initcall</code> 中 level 的含义。</p><p>接下来的 <code>do_initcall_level</code> 所做的事情是：依次调用 <code>[initcall_levels[level],initcall_levels[level+1])</code> 范围内的每一个函数指针，按照我们的理解，自然是应该调用我们之前通过 <code>__initcall</code> <code>module_init</code> 定义的函数指针才对。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __init <span class="hljs-title">do_initcall_level</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level, <span class="hljs-keyword">char</span> *command_line)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ...</span><br> <span class="hljs-keyword">for</span> (fn = initcall_levels[level]; fn &lt; initcall_levels[level+<span class="hljs-number">1</span>]; fn++)<br>  do_one_initcall(initcall_from_entry(fn));<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果你搜索一下 Linux 源码，会发现根本没有 <code>__initcall0_start</code> <code>__initcall1_start</code> … 这些符号，难道是凭空冒出来的？不可能！既然不是直接定义的符号，那就是通过宏间接拼接出来的符号名！果然，通过 <code>__initcall + level + _start</code> 这个规律，搜索到了 <code>INIT_CALLS_LEVEL</code> 这个宏，正是用来声明 <code>initcall_levels</code> 中的一系列符号的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/asm-generic/vmlinux.lds.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INIT_CALLS_LEVEL(level)      \</span><br><span class="hljs-meta">  __initcall##level##_start = .;    \</span><br><span class="hljs-meta">  KEEP(*(.initcall##level##.init))   \</span><br><span class="hljs-meta">  KEEP(*(.initcall##level##s.init))   \</span><br></code></pre></td></tr></table></figure><p>不过需要注意的文件名，<code>vmlinux.lds.h</code>，发现只有在 <code>vmlinux.lds.S</code> 中才被 include 进来，这是因为，<code>INIT_CALLS_LEVEL</code>，并不是作用于 C语言编译过程中，而是在 linker 链接的过程中发挥其<strong>魔法</strong>。</p><p>比如对于 <code>.initcall0.init</code>，有很多同样位于这个 section 的函数指针，散步在各个object 文件中，只需要在链接的时候，通过 linker 脚本的这个语法，将其聚合在一起，也就是顺序存放在 <code>__initcall0_start</code> 开始的地方即可</p><p>针对 INIT_CALLS_LEVEL，Linux 中还做了别的封装，比如 <code>INIT_CALLS</code> <code>INIT_DATA_SECTION</code>，最重要的一步是则是在 <code>vmlinux.lds.S</code> 中调用这个宏，将该指针数组链接起来，并且提供<code>__initcall1_start</code> 等一系列符号，给 <code>do_initcalls</code> 使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// include/asm-generic/vmlinux.lds.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INIT_CALLS       \</span><br><span class="hljs-meta">  __initcall_start = .;     \</span><br><span class="hljs-meta">  KEEP(*(.initcallearly.init))    \</span><br><span class="hljs-meta">  INIT_CALLS_LEVEL(0)     \</span><br><span class="hljs-meta">  INIT_CALLS_LEVEL(1)     \</span><br><span class="hljs-meta">  INIT_CALLS_LEVEL(2)     \</span><br><span class="hljs-meta">  INIT_CALLS_LEVEL(3)     \</span><br><span class="hljs-meta">  INIT_CALLS_LEVEL(4)     \</span><br><span class="hljs-meta">  INIT_CALLS_LEVEL(5)     \</span><br><span class="hljs-meta">  INIT_CALLS_LEVEL(rootfs)    \</span><br><span class="hljs-meta">  INIT_CALLS_LEVEL(6)     \</span><br><span class="hljs-meta">  INIT_CALLS_LEVEL(7)     \</span><br><span class="hljs-meta">  __initcall_end = .;</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INIT_DATA_SECTION(initsetup_align)    \</span><br><span class="hljs-meta"> .init.data : AT(ADDR(.init.data) - LOAD_OFFSET) &#123;  \</span><br><span class="hljs-meta">  INIT_DATA      \</span><br><span class="hljs-meta">  INIT_SETUP(initsetup_align)    \</span><br><span class="hljs-meta">  INIT_CALLS      \</span><br><span class="hljs-meta">  CON_INITCALL      \</span><br><span class="hljs-meta">  INIT_RAM_FS      \</span><br><span class="hljs-meta"> &#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">// ...<br>INIT_DATA_SECTION(16)<br>// ...<br></code></pre></td></tr></table></figure><p>由于 <code>INIT_CALLS_LEVEL(x)</code> 和 <code>INIT_CALLS_LEVEL(x+1)</code> 是按顺序调用的，所以，在 <code>__initcall0_start</code> <code>__initcall1_start</code> 之间的所有函数指针，就都是 level=0 的init 函数了，再回头看 <code>for (fn = initcall_levels[level]; fn &lt; initcall_levels[level+1]; fn++)</code>，是不是就清楚了很多呢？</p><h2 id="3-内核模块"><a href="#3-内核模块" class="headerlink" title="3. 内核模块"></a>3. 内核模块</h2><p>前面说到，内核模块的源码中，也必须要通过 <code>module_init(__initcall)</code> 这样的方式来定义初始化函数指针，那我们就来看看，该函数指针是何时被调用的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">sys_init_module<br> -&gt; load_module<br>  -&gt; ...<br>  -&gt; do_init_module<br>   -&gt; do_mod_ctors<br>   -&gt; do_one_initcall(mod-&gt;init)<br></code></pre></td></tr></table></figure><p>加载一个模块的时候，需要调用 init_module 这个系统调用，提供模块的信息(umod)，以及一些参数(uargs)，在完成了一系列检查，重定位等操作之后，直接调用 <code>mod-&gt;init</code> 这个初始化函数</p><p>这里并不和我们想象中一样，也去获取 <code>__initcall0_start</code> <code>__initcall1_start</code> 之间的所有初始化函数，而是用户在调用 <code>init_module</code> 这个 syscall 之前，就需要将 init 函数从指定的 <code>.initcall6.init</code> 中取出来，放在 umod-&gt;init 中。这一切都是由 modprobe 或者 insmod 帮我们做的，如果通过 <code>readelf -a xxx.o</code> 会发现，并不存在 <code>.initcall6.init&#39;</code> 这样的 section，而是 <code>.init.text</code>，我猜测，这是以为编译内核模块的时候，已经针对 <code>.initcall6.init</code> 进行了额外处理，转换成了 <code>.init.text</code>，毕竟单独加载一个内核模块，也不需要这个信息了，如果哪位yy对这里熟悉，欢迎交流讨论。</p><h2 id="4-附录-vmlinux-initcall-有关符号表"><a href="#4-附录-vmlinux-initcall-有关符号表" class="headerlink" title="4. 附录 vmlinux initcall 有关符号表"></a>4. 附录 vmlinux initcall 有关符号表</h2><p>编译得到 vmlinux 之后，通过 <code>readelf -a ./vmlinux | rg initcall</code>，查看有关 initcall 的符号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ readelf -a ./vmlinux | rg initcall<br>ffffffff811007d2  1b1360000000b R_X86_64_32S      ffffffff8397f000 initcall_debug + 0<br>ffffffff811007f1  1b13600000002 R_X86_64_PC32     ffffffff8397f000 initcall_debug - 5<br>ffffffff8110081d  1b1360000000b R_X86_64_32S      ffffffff8397f000 initcall_debug + 0<br>ffffffff81100828  1b13600000002 R_X86_64_PC32     ffffffff8397f000 initcall_debug - 5<br>ffffffff81100a89  1b1360000000b R_X86_64_32S      ffffffff8397f000 initcall_debug + 0<br>ffffffff81100a98  1b13600000002 R_X86_64_PC32     ffffffff8397f000 initcall_debug - 5<br>ffffffff81100adb  1b1360000000b R_X86_64_32S      ffffffff8397f000 initcall_debug + 0<br>ffffffff81100ae6  1b13600000002 R_X86_64_PC32     ffffffff8397f000 initcall_debug - 5<br>ffffffff811b2806  1d7ab00000004 R_X86_64_PLT32    ffffffff81003be0 do_one_initcall - 4<br>ffffffff81826af2  1b1360000000b R_X86_64_32S      ffffffff8397f000 initcall_debug + 0<br>ffffffff81826b05  1b13600000002 R_X86_64_PC32     ffffffff8397f000 initcall_debug - 5<br>ffffffff81826b2c  1b1360000000b R_X86_64_32S      ffffffff8397f000 initcall_debug + 0<br>ffffffff81826b41  1b13600000002 R_X86_64_PC32     ffffffff8397f000 initcall_debug - 5<br>ffffffff81a851e7  1b1360000000b R_X86_64_32S      ffffffff8397f000 initcall_debug + 0<br>ffffffff81a851f2  1b13600000002 R_X86_64_PC32     ffffffff8397f000 initcall_debug - 5<br>ffffffff81a8522f  1b1360000000b R_X86_64_32S      ffffffff8397f000 initcall_debug + 0<br>ffffffff81a8523a  1b13600000002 R_X86_64_PC32     ffffffff8397f000 initcall_debug - 5<br>ffffffff81a8529e  1b1360000000b R_X86_64_32S      ffffffff8397f000 initcall_debug + 0<br>ffffffff81a852a9  1b13600000002 R_X86_64_PC32     ffffffff8397f000 initcall_debug - 5<br>ffffffff81a89b5d  1b1360000000b R_X86_64_32S      ffffffff8397f000 initcall_debug + 0<br>ffffffff81a89b68  1b13600000002 R_X86_64_PC32     ffffffff8397f000 initcall_debug - 5<br>ffffffff81a8abc9  1b1360000000b R_X86_64_32S      ffffffff8397f000 initcall_debug + 0<br>ffffffff81a8abd4  1b13600000002 R_X86_64_PC32     ffffffff8397f000 initcall_debug - 5<br>ffffffff82adf860  1b13600000001 R_X86_64_64       ffffffff8397f000 initcall_debug + 0<br>ffffffff837be7fe  1b1360000000b R_X86_64_32S      ffffffff8397f000 initcall_debug + 0<br>ffffffff837be809  1b13600000002 R_X86_64_PC32     ffffffff8397f000 initcall_debug - 5<br>ffffffff837becdb  1c0d20000000b R_X86_64_32S      ffffffff83944090 __initcall_start + 0<br>ffffffff837bed1a  19bb40000000b R_X86_64_32S      ffffffff839440f8 __initcall0_start + 0<br>ffffffff837bed33  1d7ab00000004 R_X86_64_PLT32    ffffffff81003be0 do_one_initcall - 4<br>ffffffff837bee66  1d7ab00000004 R_X86_64_PLT32    ffffffff81003be0 do_one_initcall - 4<br>ffffffff837f374e  1b1360000000b R_X86_64_32S      ffffffff8397f000 initcall_debug + 0<br>ffffffff837f3759  1b13600000002 R_X86_64_PC32     ffffffff8397f000 initcall_debug - 4<br>ffffffff837f4988  1da510000000b R_X86_64_32S      ffffffff83944bc8 __con_initcall_start + 0<br>ffffffff837f49a7  1a6d80000000b R_X86_64_32S      ffffffff83944bdc __con_initcall_end + 0<br>ffffffff8389a060  19bb400000001 R_X86_64_64       ffffffff839440f8 __initcall0_start + 0<br>ffffffff8389a068  1d31400000001 R_X86_64_64       ffffffff83944110 __initcall1_start + 0<br>ffffffff8389a070  1db8100000001 R_X86_64_64       ffffffff83944228 __initcall2_start + 0<br>ffffffff8389a078  1a43600000001 R_X86_64_64       ffffffff839442bc __initcall3_start + 0<br>ffffffff8389a080  1a53b00000001 R_X86_64_64       ffffffff83944318 __initcall4_start + 0<br>ffffffff8389a088  1b67a00000001 R_X86_64_64       ffffffff839445b0 __initcall5_start + 0<br>ffffffff8389a090  1b27d00000001 R_X86_64_64       ffffffff839446c8 __initcall6_start + 0<br>ffffffff8389a098  1c6b700000001 R_X86_64_64       ffffffff83944a90 __initcall7_start + 0<br>ffffffff8389a0a0  19cac00000001 R_X86_64_64       ffffffff83944bc8 __initcall_end + 0<br>0000000256fc  1b13600000001 R_X86_64_64       ffffffff8397f000 initcall_debug + 0<br>00000002df77  1b13600000001 R_X86_64_64       ffffffff8397f000 initcall_debug + 0<br>   183: ffffffff810031e0    72 FUNC    LOCAL  DEFAULT    1 trace_initcall_f[...]<br>   184: ffffffff8201d8e3    84 FUNC    LOCAL  DEFAULT    1 trace_initcall_s[...]<br>   201: ffffffff810037a0   253 FUNC    LOCAL  DEFAULT    1 initcall_blacklisted<br>   202: ffffffff8301a0e0    16 OBJECT  LOCAL  DEFAULT   26 blacklisted_initcalls<br>   205: ffffffff8201da4a   108 FUNC    LOCAL  DEFAULT    1 trace_initcall_level<br>   208: ffffffff837bde65   308 FUNC    LOCAL  DEFAULT   37 initcall_blacklist<br>   226: ffffffff8397f010     8 OBJECT  LOCAL  DEFAULT   60 initcall_calltime<br>   229: ffffffff8389a020    64 OBJECT  LOCAL  DEFAULT   41 initcall_level_names<br>   230: ffffffff8389a060    72 OBJECT  LOCAL  DEFAULT   41 initcall_levels<br>   235: ffffffff839420c8    24 OBJECT  LOCAL  DEFAULT   41 __setup_initcall[...]<br>   237: ffffffff82adf840    40 OBJECT  LOCAL  DEFAULT   16 __param_initcall[...]<br>   254: ffffffff839397a0     8 OBJECT  LOCAL  DEFAULT   41 __event_initcall[...]<br>   255: ffffffff8301a500   144 OBJECT  LOCAL  DEFAULT   26 event_initcall_finish<br>   257: ffffffff839397a8     8 OBJECT  LOCAL  DEFAULT   41 __event_initcall[...]<br>   258: ffffffff8301a5a0   144 OBJECT  LOCAL  DEFAULT   26 event_initcall_start<br>   260: ffffffff839397b0     8 OBJECT  LOCAL  DEFAULT   41 __event_initcall[...]<br>   261: ffffffff8301a640   144 OBJECT  LOCAL  DEFAULT   26 event_initcall_level<br>   270: ffffffff82600148     9 OBJECT  LOCAL  DEFAULT    3 str__initcall__t[...]<br>   339: ffffffff839446bc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_popul[...]<br>   463: ffffffff83944318     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_vdso4<br>   479: ffffffff8394431c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sysen[...]<br>   480: ffffffff839446c8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ia32_[...]<br>   538: ffffffff83944090     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br>   674: ffffffff839446cc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_amd_u[...]<br>   740: ffffffff839446d0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_amd_i[...]<br>   783: ffffffff839446d4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_amd_i[...]<br>   820: ffffffff839446d8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_msr_init6<br>   873: ffffffff83944320     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_fixup[...]<br>  1139: ffffffff839442bc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_bts_init3<br>  1290: ffffffff839442c0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pt_init3<br>  1485: ffffffff83944110     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_xen_p[...]<br>  2390: ffffffff83944094     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br>  2461: ffffffff83944098     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_trace[...]<br>  2750: ffffffff839445b0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_nmi_w[...]<br>  2840: ffffffff839446dc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_regis[...]<br>  2874: ffffffff839446e0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_i8259[...]<br>  3056: ffffffff839442c4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_boot_[...]<br>  3073: ffffffff839442c8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sbf_init3<br>  3085: ffffffff83944114     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_e820_[...]<br>  3116: ffffffff839446c0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pci_i[...]<br>  3161: ffffffff83944324     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_topol[...]<br>  3172: ffffffff839442cc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_arch_[...]<br>  3245: ffffffff83944118     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cpufr[...]<br>  3256: ffffffff839446e4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br>  3334: ffffffff839446e8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_add_r[...]<br>  3580: ffffffff839446ec     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_i8237[...]<br>  3809: ffffffff839446f0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_umwai[...]<br>  3884: ffffffff839442d0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_intel[...]<br>  3894: ffffffff83944328     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_intel[...]<br>  4008: ffffffff83944a8c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_mchec[...]<br>  4010: ffffffff83944a90     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_mchec[...]<br>  4148: ffffffff83944a94     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sever[...]<br>  4261: ffffffff839446f4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_therm[...]<br>  4320: ffffffff8394432c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_mtrr_[...]<br>  4345: ffffffff839442d4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_mtrr_[...]<br>  4468: ffffffff839445b4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_save_[...]<br>  4470: ffffffff83944a98     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_micro[...]<br>  4610: ffffffff83944a9c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_resct[...]<br>  4806: ffffffff839442d8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_activ[...]<br>  4935: ffffffff83944aa0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_hpet_[...]<br>  5027: ffffffff839442dc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ffh_c[...]<br>  5040: ffffffff8394411c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_reboo[...]<br>  5063: ffffffff839446f8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_msr_init6<br>  5087: ffffffff839446fc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cpuid[...]<br>  5302: ffffffff83944aa4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_updat[...]<br>  5348: ffffffff83944120     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br>  5350: ffffffff83944aa8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_lapic[...]<br>  5487: ffffffff83944aac     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_print[...]<br>  5502: ffffffff83944ab0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_print_ICs7<br>  5571: ffffffff8394409c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_regis[...]<br>  5582: ffffffff83944700     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ioapi[...]<br>  5913: ffffffff839445b8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_hpet_[...]<br>  6019: ffffffff839445bc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br>  6056: ffffffff839442e0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_activ[...]<br>  6058: ffffffff839442e4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_kvm_a[...]<br>  6124: ffffffff839440a0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_kvm_s[...]<br>  6227: ffffffff83944704     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_regis[...]<br>  6250: ffffffff83944708     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_add_p[...]<br>  6253: ffffffff8394470c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_start[...]<br>  6297: ffffffff83944710     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sysfb[...]<br>  6392: ffffffff83944714     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_audit[...]<br>  6709: ffffffff83944ab4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_creat[...]<br>  6737: ffffffff83944ab8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cpa_s[...]<br>  6846: ffffffff83944abc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pat_m[...]<br>  6900: ffffffff839442e8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_gigan[...]<br>  6907: ffffffff83944718     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pt_du[...]<br>  7039: ffffffff83944ac0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_creat[...]<br>  7206: ffffffff8394471c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_iosf_[...]<br>  7416: ffffffff83944720     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br>  7452: ffffffff83944ac4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br>  7457: ffffffff83944724     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_regis[...]<br>  7525: ffffffff83944124     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_alloc[...]<br>  7527: ffffffff83944128     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cpu_h[...]<br>  7547: ffffffff83944728     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cpuhp[...]<br>  7794: ffffffff839440a4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_spawn[...]<br>  7881: ffffffff8394472c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_iores[...]<br>  8183: ffffffff83944330     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_uid_c[...]<br>  9086: ffffffff8394412c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_wq_sy[...]<br>  9470: ffffffff83944334     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_param[...]<br>  9695: ffffffff83944130     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ksysf[...]<br>  9898: ffffffff83944338     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_user_[...]<br> 10184: ffffffff839440a8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_migra[...]<br> 10663: ffffffff83944ac8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sched[...]<br> 11222: ffffffff8394433c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 11230: ffffffff83944acc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sched[...]<br> 11232: ffffffff83944730     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 11295: ffffffff83944134     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sched[...]<br> 11377: ffffffff83944734     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_psi_p[...]<br> 11695: ffffffff839445c0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 11715: ffffffff83944ad0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cpu_l[...]<br> 11769: ffffffff83944ad4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pm_de[...]<br> 11774: ffffffff83944138     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pm_init1<br> 11936: ffffffff83944bac     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_softw[...]<br> 11938: ffffffff8394413c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pm_di[...]<br> 12049: ffffffff83944140     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_swsus[...]<br> 12099: ffffffff83944738     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_snaps[...]<br> 12112: ffffffff83944340     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pm_sy[...]<br> 12120: ffffffff83944144     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_em_de[...]<br> 12201: ffffffff83944ad8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_print[...]<br> 12412: ffffffff83944228     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_irq_s[...]<br> 12784: ffffffff8394473c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_irq_g[...]<br> 13019: ffffffff83944740     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_irq_p[...]<br> 13151: ffffffff83944148     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_rcu_s[...]<br> 13177: ffffffff8394414c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_rcu_s[...]<br> 13191: ffffffff83944150     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_rcu_s[...]<br> 13305: ffffffff839440ac     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_srcu_[...]<br> 13307: ffffffff83944adc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 13375: ffffffff839440b0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_rcu_s[...]<br> 13395: ffffffff839440b4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_rcu_s[...]<br> 13400: ffffffff839440b8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_check[...]<br> 13408: ffffffff839440bc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_rcu_s[...]<br> 13801: ffffffff83944ae0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_swiot[...]<br> 13843: ffffffff8394422c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dma_a[...]<br> 13862: ffffffff839440c0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_trace[...]<br> 13864: ffffffff839440c4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_trace[...]<br> 13907: ffffffff839442ec     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_kcmp_[...]<br> 13960: ffffffff83944344     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_creat[...]<br> 14578: ffffffff83944744     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_timek[...]<br> 14647: ffffffff839445c4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_clock[...]<br> 14661: ffffffff83944748     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 14719: ffffffff83944154     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 14726: ffffffff8394474c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 14787: ffffffff83944750     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_alarm[...]<br> 14870: ffffffff83944754     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 15201: ffffffff83944758     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_clock[...]<br> 15305: ffffffff83944ae4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_tk_de[...]<br> 15313: ffffffff83944348     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_time_[...]<br> 15323: ffffffff83944158     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_futex[...]<br> 15405: ffffffff8394475c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 15727: ffffffff83944760     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 15949: ffffffff83944764     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_kalls[...]<br> 15991: ffffffff8394434c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_crash[...]<br> 16005: ffffffff83944350     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_crash[...]<br> 16161: ffffffff8394415c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cgrou[...]<br> 16169: ffffffff83944354     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cgrou[...]<br> 16418: ffffffff83944358     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cgrou[...]<br> 16430: ffffffff83944160     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cgrou[...]<br> 16646: ffffffff8394435c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_user_[...]<br> 16677: ffffffff83944768     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pid_n[...]<br> 16694: ffffffff8394476c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ikcon[...]<br> 16701: ffffffff839440c8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cpu_s[...]<br> 16727: ffffffff83944230     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_audit[...]<br> 16862: ffffffff83944770     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_audit[...]<br> 16873: ffffffff83944774     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_audit[...]<br> 16882: ffffffff83944778     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_audit[...]<br> 16940: ffffffff839440cc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 16942: ffffffff83944ae8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_debug[...]<br> 17151: ffffffff83944360     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_hung_[...]<br> 17232: ffffffff8394477c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_secco[...]<br> 17340: ffffffff83944780     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_utsna[...]<br> 17357: ffffffff83944aec     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_tasks[...]<br> 17382: ffffffff83944234     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_relea[...]<br> 17399: ffffffff83944784     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 17420: ffffffff83944788     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 17445: ffffffff83944164     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ftrac[...]<br> 17866: ffffffff83944bb0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_laten[...]<br> 17907: ffffffff839445c8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_trace[...]<br> 17909: ffffffff83944bb4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_clear[...]<br> 17911: ffffffff83944bb8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_traci[...]<br> 18219: ffffffff839440d0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 18340: ffffffff839445cc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 18342: ffffffff839440d4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 18429: ffffffff83944168     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 18472: ffffffff83944af0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 18508: ffffffff8394478c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_stack[...]<br> 18538: ffffffff83944790     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 18561: ffffffff839445d0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 18563: ffffffff8394416c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 18616: ffffffff83944794     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 18748: ffffffff839440d8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_event[...]<br> 19145: ffffffff83944170     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_trace[...]<br> 19147: ffffffff839445d4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_trace[...]<br> 19342: ffffffff83944364     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_send_[...]<br> 19344: ffffffff839445d8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_bpf_e[...]<br> 19434: ffffffff83944174     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 19436: ffffffff839445dc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 19839: ffffffff839445e0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 19866: ffffffff839445e4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 19913: ffffffff83944220     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_trace[...]<br> 19943: ffffffff839440f8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_bpf_j[...]<br> 20392: ffffffff839445e8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_bpf_init5<br> 20470: ffffffff83944af4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_bpf_m[...]<br> 20487: ffffffff83944af8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_task_[...]<br> 20511: ffffffff83944afc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_bpf_p[...]<br> 20741: ffffffff83944b00     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 20865: ffffffff83944368     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dev_m[...]<br> 20894: ffffffff8394436c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cpu_m[...]<br> 20959: ffffffff83944370     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_netns[...]<br> 20976: ffffffff83944374     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_stack[...]<br> 21054: ffffffff83944378     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_btf_v[...]<br> 21718: ffffffff83944238     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_kcsan[...]<br> 21726: ffffffff839440dc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_stati[...]<br> 21796: ffffffff83944798     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_perf_[...]<br> 22291: ffffffff839440e0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_jump_[...]<br> 22399: ffffffff8394479c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_syste[...]<br> 22401: ffffffff83944b04     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_load_[...]<br> 22420: ffffffff839447a0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_black[...]<br> 22690: ffffffff8394437c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_oom_init4<br> 23153: ffffffff839447a4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_kswap[...]<br> 23668: ffffffff839447a8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_extfr[...]<br> 23714: ffffffff8394423c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_bdi_c[...]<br> 23716: ffffffff83944380     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_defau[...]<br> 23718: ffffffff83944384     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cgwb_init4<br> 23792: ffffffff839447ac     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_mm_co[...]<br> 23794: ffffffff83944240     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_mm_sy[...]<br> 23815: ffffffff83944388     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_percp[...]<br> 23960: ffffffff839447b0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_slab_[...]<br> 24254: ffffffff8394438c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_kcomp[...]<br> 24506: ffffffff839447b4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_worki[...]<br> 24613: ffffffff83944178     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 24660: ffffffff83944b08     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_fault[...]<br> 24836: ffffffff83944390     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 24838: ffffffff83944394     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 24840: ffffffff83944398     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 25129: ffffffff839447b8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 25292: ffffffff83944244     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 25526: ffffffff8394439c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_swap_[...]<br> 25550: ffffffff839447bc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_procs[...]<br> 25552: ffffffff83944b0c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_max_s[...]<br> 25560: ffffffff839443a0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_swapf[...]<br> 25686: ffffffff839447c0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 25699: ffffffff83944b10     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 25831: ffffffff839443a4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_huget[...]<br> 26145: ffffffff839443a8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ksm_init4<br> 26291: ffffffff839447c4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_slab_[...]<br> 26625: ffffffff839443ac     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_hugep[...]<br> 26639: ffffffff83944b14     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_split[...]<br> 26879: ffffffff839440fc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_memor[...]<br> 26890: ffffffff839443b0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_mem_c[...]<br> 26892: ffffffff8394417c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_mem_c[...]<br> 27118: ffffffff83944180     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_memor[...]<br> 27202: ffffffff839447c8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 27255: ffffffff839447cc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_zbud6<br> 27301: ffffffff839447d0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_zs_init6<br> 27346: ffffffff839447d4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 27383: ffffffff83944b18     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_check[...]<br> 27398: ffffffff83944184     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cma_i[...]<br> 27465: ffffffff83944b1c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cma_d[...]<br> 27495: ffffffff839443b4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_page_[...]<br> 27534: ffffffff83944b20     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_set_h[...]<br> 28652: ffffffff839445ec     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 29017: ffffffff839447d8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_fcntl[...]<br> 29700: ffffffff839447dc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 30460: ffffffff839445f0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cgrou[...]<br> 30465: ffffffff839447e0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_start[...]<br> 31646: ffffffff839447e4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_blkde[...]<br> 31766: ffffffff839447e8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dio_init6<br> 31827: ffffffff83944188     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_fsnot[...]<br> 31899: ffffffff839447ec     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dnoti[...]<br> 31925: ffffffff839445f4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_inoti[...]<br> 32023: ffffffff839447f0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_fanot[...]<br> 32086: ffffffff839445f8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_event[...]<br> 32185: ffffffff839445fc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_anon_[...]<br> 32343: ffffffff839447f4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_userf[...]<br> 32378: ffffffff839447f8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_aio_setup6<br> 32546: ffffffff839447fc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_io_ur[...]<br> 32897: ffffffff839443b8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_io_wq[...]<br> 32920: ffffffff83944600     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 33097: ffffffff83944b24     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_fscry[...]<br> 33356: ffffffff83944b28     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_fsver[...]<br> 33501: ffffffff83944604     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 33503: ffffffff8394418c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_filel[...]<br> 33664: ffffffff83944190     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 33715: ffffffff83944194     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 33722: ffffffff83944198     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 33739: ffffffff8394419c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 34019: ffffffff83944608     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_iomap[...]<br> 34244: ffffffff8394460c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dquot[...]<br> 34342: ffffffff83944610     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_quota[...]<br> 34719: ffffffff83944614     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 34724: ffffffff83944618     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 34734: ffffffff8394461c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 34740: ffffffff83944620     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 34749: ffffffff83944624     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 34757: ffffffff83944628     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 34762: ffffffff8394462c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 34767: ffffffff83944630     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 34777: ffffffff83944634     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 34784: ffffffff83944638     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 34789: ffffffff8394463c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 34918: ffffffff83944640     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 34952: ffffffff83944644     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_vmcor[...]<br> 34987: ffffffff83944648     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 34996: ffffffff8394464c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 35006: ffffffff83944650     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 35380: ffffffff839441a0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_confi[...]<br> 35430: ffffffff83944800     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 35484: ffffffff83944654     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 35506: ffffffff83944658     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 35619: ffffffff83944804     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 35638: ffffffff83944808     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 35727: ffffffff8394480c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 35897: ffffffff839441a4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_debug[...]<br> 36119: ffffffff839441a8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_trace[...]<br> 36191: ffffffff83944b2c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pstor[...]<br> 36242: ffffffff83944810     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_efiva[...]<br> 36262: ffffffff83944814     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ipc_init6<br> 36430: ffffffff83944100     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ipc_n[...]<br> 36514: ffffffff83944818     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ipc_s[...]<br> 36530: ffffffff8394481c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 36842: ffffffff83944b30     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 36918: ffffffff83944820     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_key_p[...]<br> 36960: ffffffff83944104     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 37229: ffffffff839441ac     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_secur[...]<br> 37290: ffffffff83944824     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_selin[...]<br> 37579: ffffffff83944828     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 37677: ffffffff8394482c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_selnl[...]<br> 37690: ffffffff83944830     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sel_n[...]<br> 37702: ffffffff83944834     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sel_n[...]<br> 37712: ffffffff83944838     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sel_n[...]<br> 37839: ffffffff8394483c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_aurul[...]<br> 37920: ffffffff839443bc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sel_i[...]<br> 38125: ffffffff83944840     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 38264: ffffffff83944844     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_smack[...]<br> 38451: ffffffff8394465c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_tomoy[...]<br> 38510: ffffffff83944660     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_aa_cr[...]<br> 38775: ffffffff83944848     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_appar[...]<br> 38991: ffffffff83944b34     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 39065: ffffffff83944664     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_safes[...]<br> 39082: ffffffff839441b0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_lockd[...]<br> 39371: ffffffff8394484c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_crypt[...]<br> 39726: ffffffff839443c0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dh_init4<br> 39756: ffffffff839443c4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_rsa_init4<br> 39865: ffffffff839442f0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_crypt[...]<br> 39887: ffffffff839443c8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_hmac_[...]<br> 39909: ffffffff839443cc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_crypt[...]<br> 39933: ffffffff839443d0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_md5_m[...]<br> 39954: ffffffff839443d4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sha1_[...]<br> 39974: ffffffff839443d8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sha25[...]<br> 39995: ffffffff839443dc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sha51[...]<br> 40006: ffffffff839443e0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_crypt[...]<br> 40029: ffffffff839443e4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_aes_init4<br> 40045: ffffffff839443e8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_crct1[...]<br> 40056: ffffffff839443ec     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_lz4_m[...]<br> 40109: ffffffff839443f0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_drbg_init4<br> 40170: ffffffff83944850     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_jent_[...]<br> 40183: ffffffff839443f4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_zstd_[...]<br> 40223: ffffffff83944854     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_asymm[...]<br> 40348: ffffffff83944858     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_x509_[...]<br> 40551: ffffffff839443f8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_bio4<br> 41236: ffffffff839443fc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_blk_s[...]<br> 41252: ffffffff83944400     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_blk_i[...]<br> 41324: ffffffff83944b38     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_blk_t[...]<br> 41478: ffffffff83944404     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_blk_m[...]<br> 41657: ffffffff83944408     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_genhd[...]<br> 41659: ffffffff8394485c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proc_[...]<br> 41991: ffffffff83944668     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_blk_s[...]<br> 42009: ffffffff83944860     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_bsg_init6<br> 42119: ffffffff8394440c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_blkcg[...]<br> 42173: ffffffff83944864     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_throt[...]<br> 42226: ffffffff83944868     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_iolat[...]<br> 42255: ffffffff8394486c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ioc_init6<br> 42374: ffffffff83944870     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_deadl[...]<br> 42424: ffffffff83944874     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_kyber[...]<br> 42524: ffffffff83944878     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_bfq_init6<br> 43198: ffffffff83944410     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_bio_c[...]<br> 43353: ffffffff839441b4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_prand[...]<br> 43355: ffffffff83944b3c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_prand[...]<br> 44494: ffffffff8394487c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_btree[...]<br> 44598: ffffffff83944880     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_crc_t[...]<br> 45267: ffffffff83944884     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_percp[...]<br> 45276: ffffffff83944b40     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 45312: ffffffff839440e4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dynam[...]<br> 45314: ffffffff8394466c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dynam[...]<br> 45680: ffffffff83944248     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_mpi_init2<br> 45772: ffffffff83944888     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sg_po[...]<br> 45805: ffffffff83944414     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_irq_p[...]<br> 46477: ffffffff8394424c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_kobje[...]<br> 46843: ffffffff839440e8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_initi[...]<br> 47453: ffffffff8394488c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_phy_c[...]<br> 47594: ffffffff839441b8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pinct[...]<br> 47731: ffffffff83944418     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sx150[...]<br> 47777: ffffffff8394441c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_byt_g[...]<br> 47910: ffffffff83944420     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_chv_p[...]<br> 48037: ffffffff83944424     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_lp_gp[...]<br> 48160: ffffffff83944428     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_bxt_p[...]<br> 48314: ffffffff83944890     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cnl_p[...]<br> 48386: ffffffff8394442c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cdf_p[...]<br> 48399: ffffffff83944430     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dnv_p[...]<br> 48424: ffffffff83944894     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ebg_p[...]<br> 48440: ffffffff83944434     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_glk_p[...]<br> 48514: ffffffff83944898     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_icl_p[...]<br> 48556: ffffffff8394489c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_jsl_p[...]<br> 48571: ffffffff839448a0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_lbg_p[...]<br> 48582: ffffffff83944438     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_spt_p[...]<br> 48648: ffffffff839448a4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_tgl_p[...]<br> 48911: ffffffff839441bc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_gpiol[...]<br> 48913: ffffffff8394443c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_gpiol[...]<br> 49252: ffffffff83944bbc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_acpi_[...]<br> 49254: ffffffff83944250     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_acpi_[...]<br> 49302: ffffffff83944440     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_palma[...]<br> 49321: ffffffff83944444     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_rc5t5[...]<br> 49333: ffffffff83944448     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_tps65[...]<br> 49344: ffffffff8394444c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_tps65[...]<br> 49412: ffffffff83944450     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pwm_d[...]<br> 49458: ffffffff83944454     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pwm_s[...]<br> 49501: ffffffff839448a8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cryst[...]<br> 49663: ffffffff83944254     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pcibu[...]<br> 50103: ffffffff83944b44     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pci_r[...]<br> 50108: ffffffff83944108     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pci_r[...]<br> 50253: ffffffff83944258     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pci_d[...]<br> 50349: ffffffff83944b48     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pci_s[...]<br> 50638: ffffffff839448ac     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pcie_[...]<br> 50854: ffffffff839448b0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pci_p[...]<br> 50888: ffffffff83944458     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pci_s[...]<br> 50913: ffffffff839442f4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_acpi_[...]<br> 50955: ffffffff839446b4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pci_a[...]<br> 51229: ffffffff839448b4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pci_h[...]<br> 51442: ffffffff839448b8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_shpcd[...]<br> 51792: ffffffff839448bc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pci_s[...]<br> 51952: ffffffff839448c0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dw_pl[...]<br> 51961: ffffffff839448c4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_meson[...]<br> 52210: ffffffff8394425c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_backl[...]<br> 52334: ffffffff8394445c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_fbmem[...]<br> 52782: ffffffff839448c8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_vesaf[...]<br> 52806: ffffffff839448cc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_efifb[...]<br> 52854: ffffffff839448d0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_intel[...]<br> 52949: ffffffff83944460     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_scan_[...]<br> 53019: ffffffff839446b8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_acpi_[...]<br> 53527: ffffffff83944464     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_acpi_init4<br> 54272: ffffffff83944670     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_acpi_[...]<br> 54283: ffffffff839448d4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ged_d[...]<br> 54499: ffffffff83944468     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_adxl_init4<br> 55949: ffffffff839448d8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_acpi_[...]<br> 55976: ffffffff839448dc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_acpi_[...]<br> 56015: ffffffff839448e0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_acpi_[...]<br> 56057: ffffffff839448e4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_acpi_[...]<br> 56223: ffffffff839448e8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_acpi_[...]<br> 56315: ffffffff839448ec     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_hmat_init6<br> 56372: ffffffff839448f0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_acpi_[...]<br> 56442: ffffffff839448f4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_acpi_[...]<br> 56454: ffffffff839448f8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_bgrt_init6<br> 56699: ffffffff839448fc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_erst_init6<br> 56747: ffffffff83944b4c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_bert_init7<br> 56762: ffffffff83944900     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ghes_init6<br> 56846: ffffffff83944904     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_intel[...]<br> 56861: ffffffff83944908     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_intel[...]<br> 56868: ffffffff8394490c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_intel[...]<br> 56881: ffffffff83944910     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_intel[...]<br> 56898: ffffffff83944914     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_intel[...]<br> 56912: ffffffff83944918     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_chtdc[...]<br> 56933: ffffffff8394446c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pnp_init4<br> 57098: ffffffff83944674     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pnp_s[...]<br> 57110: ffffffff83944678     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pnpac[...]<br> 57343: ffffffff83944bc0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_clk_d[...]<br> 57405: ffffffff83944b50     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_clk_d[...]<br> 57852: ffffffff8394491c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_gpio_[...]<br> 57871: ffffffff83944920     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_plt_c[...]<br> 57884: ffffffff83944924     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_fch_c[...]<br> 57897: ffffffff839442f8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dma_c[...]<br> 57974: ffffffff839442fc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dma_b[...]<br> 58190: ffffffff83944928     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dw_pc[...]<br> 58274: ffffffff839441c0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_virti[...]<br> 58426: ffffffff83944b54     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_setup[...]<br> 58551: ffffffff83944224     0 NOTYPE  LOCAL  DEFAULT   41 __initcall___gnt[...]<br> 58639: ffffffff83944470     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ballo[...]<br> 58674: ffffffff83944474     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_xen_s[...]<br> 59138: ffffffff8394492c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_xenbu[...]<br> 59139: ffffffff83828068   105 FUNC    LOCAL  DEFAULT   37 xenbus_probe_initcall<br> 59140: ffffffff83944260     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_xenbu[...]<br> 59194: ffffffff83944478     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_xenbu[...]<br> 59224: ffffffff83944930     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_xenbu[...]<br> 59243: ffffffff83944934     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_xenbu[...]<br> 59255: ffffffff8394447c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_xenbu[...]<br> 59257: ffffffff83944b58     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_boot_[...]<br> 59302: ffffffff83944300     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_regis[...]<br> 59317: ffffffff83944480     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_xen_a[...]<br> 59336: ffffffff83944304     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_xen_p[...]<br> 59396: ffffffff83944938     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_hyper[...]<br> 59398: ffffffff8394493c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_hyper[...]<br> 59451: ffffffff83944940     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_platf[...]<br> 59488: ffffffff83944944     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_xen_l[...]<br> 59558: ffffffff83944948     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pvcal[...]<br> 59595: ffffffff83944484     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init4<br> 59769: ffffffff839441c4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_regul[...]<br> 59771: ffffffff83944bc4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_regul[...]<br> 60333: ffffffff83944264     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_tty_c[...]<br> 60726: ffffffff8394494c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_n_nul[...]<br> 60738: ffffffff83944950     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pty_init6<br> 60790: ffffffff83944954     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sysrq[...]<br> 61068: ffffffff83944bc8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_con_init<br> 61091: ffffffff83944268     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_vtcon[...]<br> 61294: ffffffff83944bcc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_hvc_c[...]<br> 61361: ffffffff83944958     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_xen_h[...]<br> 61363: ffffffff83944bd0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_xen_c[...]<br> 61576: ffffffff83944bd4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_univ8[...]<br> 61590: ffffffff8394495c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_seria[...]<br> 61862: ffffffff83944960     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_seria[...]<br> 62001: ffffffff83944964     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_lpss8[...]<br> 62022: ffffffff83944968     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_mid82[...]<br> 62075: ffffffff83944bd8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_kgdbo[...]<br> 62077: ffffffff8394496c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 62189: ffffffff8394426c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_serde[...]<br> 62249: ffffffff8394467c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_chr_d[...]<br> 62605: ffffffff83944488     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_misc_init4<br> 62623: ffffffff83944970     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_hpet_init6<br> 62662: ffffffff83944974     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_nvram[...]<br> 62725: ffffffff83944978     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_agp_init6<br> 63162: ffffffff8394497c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_amd_i[...]<br> 63186: ffffffff83944b5c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dmar_[...]<br> 63563: ffffffff839446c4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ir_de[...]<br> 63604: ffffffff8394448c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_iommu[...]<br> 63753: ffffffff839441c8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_iommu[...]<br> 64031: ffffffff83944270     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_iommu[...]<br> 64065: ffffffff83944308     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_iommu[...]<br> 64811: ffffffff83944980     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_drm_k[...]<br> 65578: ffffffff83944984     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_drm_c[...]<br> 67514: ffffffff83944274     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_mipi_[...]<br> 67572: ffffffff83944490     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_vga_a[...]<br> 67718: ffffffff83944494     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cn_init4<br> 67727: ffffffff83944988     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cn_pr[...]<br> 67735: ffffffff839441cc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_compo[...]<br> 67794: ffffffff83944278     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_devli[...]<br> 67805: ffffffff83944b60     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sync_[...]<br> 68231: ffffffff83944b64     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_defer[...]<br> 68276: ffffffff83a2c740     1 OBJECT  LOCAL  DEFAULT   60 initcalls_done<br> 68806: ffffffff8394498c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_topol[...]<br> 69005: ffffffff83944990     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cache[...]<br> 69090: ffffffff8394427c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_softw[...]<br> 69483: ffffffff8205ebb5   131 FUNC    LOCAL  DEFAULT    1 initcall_debug_s[...]<br> 69622: ffffffff83944280     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_wakeu[...]<br> 69660: ffffffff83944284     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_wakeu[...]<br> 69700: ffffffff839441d0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_early[...]<br> 69702: ffffffff83944b68     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_late_[...]<br> 69715: ffffffff83944b6c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_genpd[...]<br> 69747: ffffffff83944b70     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_genpd[...]<br> 69941: ffffffff83944288     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_isa_b[...]<br> 69981: ffffffff83944680     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_firmw[...]<br> 70049: ffffffff8394428c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_regis[...]<br> 70312: ffffffff83944290     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_regma[...]<br> 70313: ffffffff8383520e    13 FUNC    LOCAL  DEFAULT   37 regmap_initcall<br> 70736: ffffffff83944994     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_devco[...]<br> 70780: ffffffff83944998     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pvpan[...]<br> 70803: ffffffff83944498     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pm860[...]<br> 70912: ffffffff8394499c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_htcpl[...]<br> 71130: ffffffff8394449c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_wm840[...]<br> 71255: ffffffff839444a0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_wm831[...]<br> 71266: ffffffff839444a4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_wm831[...]<br> 71346: ffffffff839444a8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_wm835[...]<br> 71354: ffffffff839444ac     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_tps65[...]<br> 71376: ffffffff839444b0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_tps80[...]<br> 71420: ffffffff839449a0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_twl_d[...]<br> 71507: ffffffff839449a4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_twl40[...]<br> 71549: ffffffff839449a8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_twl60[...]<br> 71632: ffffffff839444b4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ezx_p[...]<br> 71684: ffffffff839444b8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_da903[...]<br> 71780: ffffffff839444bc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_da905[...]<br> 71790: ffffffff839444c0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_da905[...]<br> 71813: ffffffff839444c4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_lp878[...]<br> 71855: ffffffff839444c8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_da905[...]<br> 71865: ffffffff839444cc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_max77[...]<br> 71950: ffffffff839444d0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_max89[...]<br> 71982: ffffffff839444d4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_max89[...]<br> 72030: ffffffff839444d8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_max89[...]<br> 72080: ffffffff839449ac     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_adp55[...]<br> 72129: ffffffff839444dc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_tps65[...]<br> 72163: ffffffff839444e0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_tps65[...]<br> 72177: ffffffff839444e4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_aat28[...]<br> 72209: ffffffff839444e8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_palma[...]<br> 72234: ffffffff839444ec     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_rc5t5[...]<br> 72281: ffffffff83944294     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sysco[...]<br> 72293: ffffffff839444f0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_as371[...]<br> 72308: ffffffff839449b0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_intel[...]<br> 72336: ffffffff839449b4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cht_w[...]<br> 72386: ffffffff839444f4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_libnv[...]<br> 73288: ffffffff839444f8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dax_c[...]<br> 73447: ffffffff83944b74     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_hmem_init7<br> 73507: ffffffff839444fc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dma_b[...]<br> 73748: ffffffff83944500     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dma_h[...]<br> 73782: ffffffff839449b8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_syste[...]<br> 73789: ffffffff839449bc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_add_d[...]<br> 73818: ffffffff839449c0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_udmab[...]<br> 73883: ffffffff83944504     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_scsi4<br> 74741: ffffffff839449c4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_sd6<br> 75012: ffffffff839449c8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_nvme_[...]<br> 75344: ffffffff839449cc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_nvme_init6<br> 75612: ffffffff83944508     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ata_init4<br> 76412: ffffffff839449d0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ahci_[...]<br> 76752: ffffffff83944298     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_spi_init2<br> 77086: ffffffff839449d4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_net_o[...]<br> 77099: ffffffff839449d8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_black[...]<br> 77252: ffffffff8394450c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_usb_c[...]<br> 77331: ffffffff83944510     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_usb_init4<br> 78721: ffffffff839449dc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ehci_[...]<br> 78941: ffffffff839449e0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ehci_[...]<br> 78983: ffffffff839449e4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ohci_[...]<br> 79123: ffffffff839449e8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ohci_[...]<br> 79161: ffffffff839449ec     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_uhci_[...]<br> 79286: ffffffff839449f0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_xhci_[...]<br> 80121: ffffffff839449f4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_usb_s[...]<br> 80377: ffffffff839449f8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_kgdbd[...]<br> 80412: ffffffff83944514     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_xdbc_init4<br> 80529: ffffffff83944518     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_input[...]<br> 80752: ffffffff839449fc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_input[...]<br> 80766: ffffffff83944a00     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_evdev[...]<br> 80851: ffffffff8394451c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_rtc_init4<br> 81095: ffffffff83944a04     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cmos_init6<br> 81237: ffffffff8394429c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_i2c_init2<br> 81714: ffffffff83944520     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dw_i2[...]<br> 81736: ffffffff83944a08     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dw_i2[...]<br> 81800: ffffffff83944524     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_rc_co[...]<br> 81995: ffffffff83944528     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cec_d[...]<br> 82144: ffffffff8394452c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pps_init4<br> 82247: ffffffff83944530     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ptp_init4<br> 82301: ffffffff83944a0c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_mt632[...]<br> 82314: ffffffff83944a10     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_resta[...]<br> 82409: ffffffff83944534     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_power[...]<br> 82500: ffffffff83944b78     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_charg[...]<br> 82581: ffffffff83944538     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_hwmon[...]<br> 82687: ffffffff839442a0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_therm[...]<br> 83056: ffffffff839445ac     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_watch[...]<br> 83153: ffffffff83944a14     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_watch[...]<br> 83394: ffffffff8394453c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_edac_init4<br> 83777: ffffffff839441d4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_opp_d[...]<br> 83899: ffffffff839441d8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cpufr[...]<br> 84145: ffffffff839441dc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cpufr[...]<br> 84154: ffffffff839441e0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cpufr[...]<br> 84163: ffffffff839441e4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cpufr[...]<br> 84193: ffffffff839441e8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_CPU_F[...]<br> 84228: ffffffff839441ec     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_CPU_F[...]<br> 84310: ffffffff83944a18     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_intel[...]<br> 84504: ffffffff839441f0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cpuid[...]<br> 84595: ffffffff839442a4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 84604: ffffffff839442a8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_menu2<br> 84613: ffffffff839442ac     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_teo_g[...]<br> 84622: ffffffff839442b0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 84740: ffffffff83944540     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_leds_init4<br> 84826: ffffffff83944a1c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ledtr[...]<br> 84837: ffffffff83944a20     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ledtr[...]<br> 84846: ffffffff83944a24     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ledtr[...]<br> 84859: ffffffff83944a28     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ledtr[...]<br> 84870: ffffffff83944544     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dmi_init4<br> 84950: ffffffff83944a2c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dmi_s[...]<br> 85021: ffffffff8394430c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dmi_i[...]<br> 85064: ffffffff83944b7c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_firmw[...]<br> 85095: ffffffff83944548     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_efisu[...]<br> 85097: ffffffff839440ec     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_efi_m[...]<br> 85099: ffffffff83944b80     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_regis[...]<br> 85222: ffffffff83944b84     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_efi_s[...]<br> 85244: ffffffff839441f4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_capsu[...]<br> 85260: ffffffff83944a30     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_esrt_[...]<br> 85305: ffffffff83944a34     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_efiva[...]<br> 85433: ffffffff83944684     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_map_p[...]<br> 85442: ffffffff83944b88     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_efi_r[...]<br> 85473: ffffffff839440f0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_efi_e[...]<br> 85475: ffffffff83944b8c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_efi_e[...]<br> 85507: ffffffff83944688     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 85673: ffffffff83944a38     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_hid_init6<br> 85906: ffffffff83944a3c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_hid_g[...]<br> 85916: ffffffff83944310     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ts_dm[...]<br> 86018: ffffffff83944b90     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_itmt_[...]<br> 86034: ffffffff83944a40     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pmc_c[...]<br> 86128: ffffffff83944a44     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pmc_c[...]<br> 86175: ffffffff8394454c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_intel[...]<br> 86195: ffffffff83944a48     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_intel[...]<br> 86209: ffffffff83944a4c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pmc_a[...]<br> 86392: ffffffff839442b4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pcc_init2<br> 86561: ffffffff83944550     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_remot[...]<br> 86829: ffffffff83944554     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_devfr[...]<br> 86987: ffffffff83944558     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_devfr[...]<br> 87069: ffffffff83944a50     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_extco[...]<br> 87142: ffffffff8394468c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_power[...]<br> 87181: ffffffff839440f4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_idle_[...]<br> 87197: ffffffff8394455c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ras_init4<br> 87395: ffffffff83944b94     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cec_init7<br> 87508: ffffffff83944560     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_nvmem[...]<br> 87628: ffffffff83944a54     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_icc_init6<br> 87798: ffffffff839441f8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sock_init1<br> 88374: ffffffff839441fc     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_net_i[...]<br> 88385: ffffffff83944564     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_proto[...]<br> 88997: ffffffff83944200     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_net_d[...]<br> 89014: ffffffff8394410c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_net_n[...]<br> 89161: ffffffff83944204     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 89181: ffffffff83944690     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sysct[...]<br> 89786: ffffffff83944568     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_net_d[...]<br> 90305: ffffffff8394456c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_neigh[...]<br> 90965: ffffffff83944a58     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sock_[...]<br> 91051: ffffffff83944570     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_fib_n[...]<br> 91598: ffffffff83944208     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_netpo[...]<br> 91659: ffffffff83944574     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_fib_r[...]<br> 92444: ffffffff83944a5c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 92525: ffffffff83944578     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_init_[...]<br> 92604: ffffffff8394457c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_bpf_l[...]<br> 92630: ffffffff83944b98     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_bpf_s[...]<br> 93055: ffffffff83944580     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_devli[...]<br> 93359: ffffffff83944b9c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_bpf_s[...]<br> 93448: ffffffff83944694     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_eth_o[...]<br> 93573: ffffffff83944ba0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sch_d[...]<br> 93632: ffffffff83944584     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pktsc[...]<br> 93723: ffffffff83944a60     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_black[...]<br> 93829: ffffffff83944588     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_tc_fi[...]<br> 93995: ffffffff8394458c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_tc_ac[...]<br> 94072: ffffffff83944a64     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_fq_co[...]<br> 94199: ffffffff8394420c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_netli[...]<br> 94284: ffffffff83944210     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_genl_init1<br> 94453: ffffffff83944590     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ethnl[...]<br> 95911: ffffffff83944ba4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_tcp_c[...]<br> 96559: ffffffff83944698     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ipv4_[...]<br> 96561: ffffffff8394469c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_inet_init5<br> 97093: ffffffff83944a68     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_gre_o[...]<br> 97138: ffffffff83944594     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_nexth[...]<br> 97225: ffffffff83944a6c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_sysct[...]<br> 97486: ffffffff83944a70     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cubic[...]<br> 97539: ffffffff83944214     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_tcp_b[...]<br> 97554: ffffffff83944218     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_udp_b[...]<br> 97561: ffffffff83944598     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_cipso[...]<br> 98177: ffffffff83944a74     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_xfrm_[...]<br> 98289: ffffffff839446a0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_af_un[...]<br> 98435: ffffffff83944a78     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_inet6[...]<br>100102: ffffffff839446a4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ipv6_[...]<br>100171: ffffffff83944a7c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_packe[...]<br>100278: ffffffff83944a80     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_strp_[...]<br>100329: ffffffff839446a8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_vlan_[...]<br>100351: ffffffff8394459c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_wirel[...]<br>100440: ffffffff839445a0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_netlb[...]<br>100562: ffffffff83944a84     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_dcbnl[...]<br>100887: ffffffff839445a4     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_ncsi_[...]<br>100941: ffffffff839446ac     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_xsk_init5<br>101378: ffffffff839446b0     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pcibi[...]<br>101393: ffffffff83944314     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pci_a[...]<br>101413: ffffffff83944ba8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pci_m[...]<br>101552: ffffffff839445a8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pci_s[...]<br>101653: ffffffff839442b8     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_amd_p[...]<br>101663: ffffffff8394421c     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_bsp_p[...]<br>101665: ffffffff83944a88     0 NOTYPE  LOCAL  DEFAULT   41 __initcall_pm_ch[...]<br>105396: ffffffff839440f8     0 NOTYPE  GLOBAL DEFAULT   41 __initcall0_start<br>105644: ffffffff83944bc8     0 NOTYPE  GLOBAL DEFAULT   41 __initcall_end<br>106221: ffffffff839446bc     0 NOTYPE  GLOBAL DEFAULT   41 __initcallrootfs[...]<br>107574: ffffffff839442bc     0 NOTYPE  GLOBAL DEFAULT   41 __initcall3_start<br>107835: ffffffff83944318     0 NOTYPE  GLOBAL DEFAULT   41 __initcall4_start<br>108248: ffffffff83944bdc     0 NOTYPE  GLOBAL DEFAULT   41 __con_initcall_end<br>110902: ffffffff8397f000     1 OBJECT  GLOBAL DEFAULT   60 initcall_debug<br>111229: ffffffff839446c8     0 NOTYPE  GLOBAL DEFAULT   41 __initcall6_start<br>112250: ffffffff839445b0     0 NOTYPE  GLOBAL DEFAULT   41 __initcall5_start<br>114898: ffffffff83944090     0 NOTYPE  GLOBAL DEFAULT   41 __initcall_start<br>116407: ffffffff83944a90     0 NOTYPE  GLOBAL DEFAULT   41 __initcall7_start<br>119572: ffffffff83944110     0 NOTYPE  GLOBAL DEFAULT   41 __initcall1_start<br>120747: ffffffff81003be0   540 FUNC    GLOBAL DEFAULT    1 do_one_initcall<br>121425: ffffffff83944bc8     0 NOTYPE  GLOBAL DEFAULT   41 __con_initcall_start<br>121729: ffffffff83944228     0 NOTYPE  GLOBAL DEFAULT   41 __initcall2_start<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>basic</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.5 middleware-buffer</title>
    <link href="/2022/01/10/rust/tower_internal/middleware-buffer/"/>
    <url>/2022/01/10/rust/tower_internal/middleware-buffer/</url>
    
    <content type="html"><![CDATA[<p>不知道大家有没有发现，Tower Service trait 中，要求 <code>ready + call</code> 都接收一个 <code>&amp;mut self</code>，这也就意味着，我们无法将其很好地扩展到多线程上！</p><p>你可能会觉得，针对每一个 service，调用一下 <code>service.clone()</code>，再传入不就好了吗？但假如一个 Service 包装了很多中间件，clone 的开销也是不可小觑的。</p><p>Tower 提供了这样一个中间件：将一个 <code>multiproducer, single consumer channel</code> 和某个服务绑定，客户端可以通过任意 Clone 得到的 Buffer Service 句柄发送请求，由 <code>single consumer</code>，也就是 Worker 依次处理请求，为我们探测内层 Service 的状态，等到，同时将 Response 通过某种方式发送回请求者。</p><h2 id="1-channel-semaphore-模型"><a href="#1-channel-semaphore-模型" class="headerlink" title="1. channel + semaphore 模型"></a>1. channel + semaphore 模型</h2><p>进一步分析 Buffer 的定义：需要一个 mspc channel 来存放所有的请求，有多个 service 句柄可以发送请求，单个 worker 处理请求，但同时我们又希望对于该 channel 容量加以控制，更专业的术语叫做 <code>backpressure</code>，即需要根据<strong>有限的服务处理能力</strong>限制请求数量。<br>不难想到很多异步 runtime 都提供的 bounded mspc channel 非常适合描述这种模型，并且 tokio 等 runtime 都已经提供了完善的实现，可不幸的是，<code>Tokio bounded mspc channel</code> 并没有提供 polling-based 的接口，因此，我们不得不自己造一个 bounded mspc channel 的轮子。</p><p>幸运的是，我们也不是从零起步，完全可以借助已有的一些设施：<code>unbounded channel + semaphore</code><br>Semaphore 这个之前已经在 <a href="./middleware-concurrency.md">ConcurrencyLimit</a> 中使用过的数据结构，没错，又是将服务处理能力抽象为 Semaphore 的计数，每次需要向 Semaphore 获取许可 permit，才能接着往下进行，并且当请求处理结束之后，需要将许可返还给 Semaphore，这样才能循环利用。<br>有了 Semaphore，就可以对 unbounded channel 容量做出限制，正好符合我们的需求。</p><p>因此 Buffer 定义了下面的结构：</p><ol><li>tx 是 mpsc channel 的发送端</li><li>semaphore 是所有 service 句柄共享的信号量</li><li>permit 是当前 service 获取的服务调用许可</li><li>handle 是对于服务内部错误的处理</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Buffer</span></span>&lt;T, Request&gt;<br><span class="hljs-keyword">where</span><br>    T: Service&lt;Request&gt;,<br>&#123;<br>    tx: mpsc::UnboundedSender&lt;Message&lt;Request, T::Future&gt;&gt;,<br>    semaphore: PollSemaphore,<br>    permit: <span class="hljs-built_in">Option</span>&lt;OwnedSemaphorePermit&gt;,<br>    handle: Handle,<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Handle</span></span> &#123;<br>    inner: Arc&lt;Mutex&lt;<span class="hljs-built_in">Option</span>&lt;ServiceError&gt;&gt;&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><p>Buffer 保存了 channel 的发送端，每一个 clone 出来的 buffer，都可以发送请求，与此同时还需要有一个对应的接收端，从 channel 中不断取出请求，这样才能驱动 <code>producer-consumer</code> 模型运转，不难想象我们其实在 Buffer::new 中处理了这件事</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T, Request&gt; Buffer&lt;T, Request&gt;<br><span class="hljs-keyword">where</span><br>    T: Service&lt;Request&gt;,<br>    T::Error: <span class="hljs-built_in">Into</span>&lt;crate::BoxError&gt;,<br>&#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(service: T, bound: <span class="hljs-built_in">usize</span>) -&gt; <span class="hljs-keyword">Self</span><br>    <span class="hljs-keyword">where</span><br>        T: <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>,<br>        T::Future: <span class="hljs-built_in">Send</span>,<br>        T::Error: <span class="hljs-built_in">Send</span> + <span class="hljs-built_in">Sync</span>,<br>        Request: <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>,<br>    &#123;<br>        <span class="hljs-keyword">let</span> (service, worker) = Self::pair(service, bound);<br>        tokio::spawn(worker);<br>        service<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">pair</span></span>(service: T, bound: <span class="hljs-built_in">usize</span>) -&gt; (Buffer&lt;T, Request&gt;, Worker&lt;T, Request&gt;)<br>    <span class="hljs-keyword">where</span><br>        T: <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>,<br>        T::Error: <span class="hljs-built_in">Send</span> + <span class="hljs-built_in">Sync</span>,<br>        Request: <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>,<br>    &#123;<br>        <span class="hljs-keyword">let</span> (tx, rx) = mpsc::unbounded_channel();<br>        <span class="hljs-keyword">let</span> semaphore = Arc::new(Semaphore::new(bound));<br>        <span class="hljs-keyword">let</span> (handle, worker) = Worker::new(service, rx, &amp;semaphore);<br>        <span class="hljs-keyword">let</span> buffer = Buffer &#123;<br>            tx,<br>            handle,<br>            semaphore: PollSemaphore::new(semaphore),<br>            permit: <span class="hljs-literal">None</span>,<br>        &#125;;<br>        (buffer, worker)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_worker_error</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; crate::BoxError &#123;<br>        <span class="hljs-keyword">self</span>.handle.get_error_on_closed()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h2><p>在 Buffer 这个中间件中，我们不仅学习到 mspc 的请求处理模式还需要注意一个坑</p><p>如果我们定义了下面的中间件，简单地将内部的服务包装一层，返回一个 Box::pin 类型的 Future，看上去一切 Ok，但是，当内层服务包含了 Buffer 的时候，会出现一个巨大的问题！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;S&gt; Service&lt;hyper::Request&lt;Body&gt;&gt; <span class="hljs-keyword">for</span> MyMiddleware&lt;S&gt;<br><span class="hljs-keyword">where</span><br>    S: Service&lt;hyper::Request&lt;Body&gt;, Response = hyper::Response&lt;BoxBody&gt;&gt; + <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>,<br>    S::Future: <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>,<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Response</span></span> = S::Response;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = S::Error;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Future</span></span> = futures::future::BoxFuture&lt;<span class="hljs-symbol">&#x27;static</span>, <span class="hljs-built_in">Result</span>&lt;Self::Response, Self::Error&gt;&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll_ready</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;<span class="hljs-built_in">Result</span>&lt;(), Self::Error&gt;&gt; &#123;<br>        <span class="hljs-keyword">self</span>.inner.poll_ready(cx)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, req: hyper::Request&lt;Body&gt;) -&gt; Self::Future &#123;<br>        <span class="hljs-keyword">let</span> inner = <span class="hljs-keyword">self</span>.inner.clone();<br>        <span class="hljs-built_in">Box</span>::pin(<span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123;<br>            <span class="hljs-keyword">let</span> response = inner.call(req).<span class="hljs-keyword">await</span>?;<br>            <span class="hljs-literal">Ok</span>(response)<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体什么问题呢？经过试验，出现了这个错误信息：<br><code>panicked at &#39;buffer full; poll_ready must be called first&#39;</code></p><p>what？我们的调用方式明明是 <code>svc.ready().await.unwrap().call(req).await;</code>，按道理已经调用过 <code>poll_ready()</code> 了<br>进一步查看 Buffer 的代码中，是这样确保 poll_ready 和 call 之间的调用次序的：在 poll_ready 中获取 permit，在 call 中取出 permit，如果 call 中取出的 permit 为 None，说明错误调用了 poll_ready 和call，问题的关键在于 <strong>permit</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// poll_ready:</span><br><span class="hljs-keyword">let</span> permit =<br>    ready!(<span class="hljs-keyword">self</span>.semaphore.poll_acquire(cx)).ok_or_else(|| <span class="hljs-keyword">self</span>.get_worker_error())?;<br><br><span class="hljs-comment">// call:</span><br><span class="hljs-keyword">let</span> _permit = <span class="hljs-keyword">self</span><br>    .permit<br>    .take()<br>    .expect(<span class="hljs-string">&quot;buffer full; poll_ready must be called first&quot;</span>);<br></code></pre></td></tr></table></figure><p>定位到这一点，接下来的问题就很好找了，在 MyMiddleware::call 中，实际上 Clone 得到的服务，里面已经没有 permit 了，或者说，每当一个 Buffer Clone 出去，该 clone 的服务都无 permit，这一点通过源码也很容易定位，其注释也强调了这一点：Clone 得到的 service，必须要 poll_ready 返回 Ready 才能调用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T, Request&gt; <span class="hljs-built_in">Clone</span> <span class="hljs-keyword">for</span> Buffer&lt;T, Request&gt;<br><span class="hljs-keyword">where</span><br>    T: Service&lt;Request&gt;,<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clone</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            tx: <span class="hljs-keyword">self</span>.tx.clone(),<br>            handle: <span class="hljs-keyword">self</span>.handle.clone(),<br>            semaphore: <span class="hljs-keyword">self</span>.semaphore.clone(),<br>            <span class="hljs-comment">// The new clone hasn&#x27;t acquired a permit yet. It will when it&#x27;s</span><br>            <span class="hljs-comment">// next polled ready.</span><br>            permit: <span class="hljs-literal">None</span>,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们解决的办法很简单，因为只有已经 ready 的服务才能调用，所以，我们 Clone 得到一个未 ready 的服务，然后将其和当前服务置换，这样闭包捕获的 inner 就是已经获取了 Semaphore permit 的服务了，再调用就不会有问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, req: hyper::Request&lt;Body&gt;) -&gt; Self::Future &#123;<br>    <span class="hljs-keyword">let</span> clone = <span class="hljs-keyword">self</span>.inner.clone();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> inner = std::mem::replace(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.inner, clone);<br><br>    <span class="hljs-built_in">Box</span>::pin(<span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123;<br>        <span class="hljs-comment">// Do extra async work here...</span><br>        <span class="hljs-keyword">let</span> response = inner.call(req).<span class="hljs-keyword">await</span>?;<br><br>        <span class="hljs-literal">Ok</span>(response)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
      <category>tower</category>
      
      <category>middlewares</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.4 tower-concurrency limit</title>
    <link href="/2022/01/10/rust/tower_internal/middleware-concurrency/"/>
    <url>/2022/01/10/rust/tower_internal/middleware-concurrency/</url>
    
    <content type="html"><![CDATA[<p><code>Concurrency</code> 翻译过来是 <code>并发</code>，<code>Concurrency Limit</code> 也就是 <code>并发控制</code>，其核心限制条件是：<strong>同一时刻最多接收 n 个请求</strong>，和 RateLimit 有一定的相似之处，内层似乎都要使用一个计数器计数，但是具体如何实现，又有很大的不同。</p><h2 id="1-并发控制模型"><a href="#1-并发控制模型" class="headerlink" title="1. 并发控制模型"></a>1. 并发控制模型</h2><p>可以将对于请求的响应能力看成是一种<strong>资源</strong>，资源的数量是有限的，先到先得，那得不到的请求就应该置之不理吗？当然不是，得不到的可以排队等待，当先来的请归还了借给它的资源，资源得到循环利用，后面排队的请求就能得到处理了。</p><p>细细一想，这种场景十分常见，不说和 Semaphore 完全相同，简直就是一模一样！并且tokio 早就为我们提供了完善的 Semaphore 轮子，省去了我们自己造的痛苦。</p><p>Semaphore 本质上是一个 Mutex + Atomic 计数器，如果需要抢占资源，首先尝试通过原子指令更新计数器，如果计数器的值大于 0，说明资源还有剩余，可以获取，如果计数器的值小于 0，说明资源无剩余，只能将自身封装为 Waiter 结构，添加到 WaitList 中去，自身陷入休眠，WaitList 是一个先进先出的队列，当原先占据的资源被释放，计数器的值就可以增加，当计数器的值大于 0 时，资源又有富余了，将队首的结点取出，唤醒该任务。<br>对于 Rust 来说，Semaphore 模型稍有不同，因为假如按照最朴素的思想，得不到 Semaphore 就去休眠，对线程就造成了阻塞，调度器岂不是很没面子？而 Rust 的 polling-based 模型可以很好解决这一点，核心思想是：如果可以获取 Permit，返回 Poll::Ready，否则在底层注册 Waker，通过 yield 返回到最上层的 runtime，runtime 便可以调度别的任务，等待事件通知，也就是相应的资源准备好了之后，再来重新 poll semaphore，这样就实现了高效的调度。</p><figure class="highlight rust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 最上层 Semaphore， 通过 Arc 跨线程共享</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PollSemaphore</span></span> &#123;<br>    semaphore: Arc&lt;Semaphore&gt;,<br>    permit_fut: <span class="hljs-built_in">Option</span>&lt;ReusableBoxFuture&lt;<span class="hljs-built_in">Result</span>&lt;OwnedSemaphorePermit, AcquireError&gt;&gt;&gt;,<br>&#125;<br><br><span class="hljs-comment">// 获取到了 `permits` 个许可，同时保存 Semaphore。便于到时候归还 permit</span><br><span class="hljs-meta">#[must_use]</span><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OwnedSemaphorePermit</span></span> &#123;<br>    sem: Arc&lt;Semaphore&gt;,<br>    permits: <span class="hljs-built_in">u32</span>,<br>&#125;<br><br><span class="hljs-comment">// tokio::sync::Semaphore</span><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Semaphore</span></span> &#123;<br>    <span class="hljs-comment">/// The low level semaphore</span><br>    ll_sem: ll::Semaphore,<br>&#125;<br><br><span class="hljs-comment">// ll::Semaphore</span><br><span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Semaphore</span></span> &#123;<br>    waiters: Mutex&lt;Waitlist&gt;,<br>    <span class="hljs-comment">/// The current number of available permits in the semaphore.</span><br>    permits: AtomicUsize,<br>&#125;<br></code></pre></td></tr></table></figure><p>向 Semaphore 申请资源的时候，不必 one-by-one 操作，而是可以一次申请多个，Semaphore 完全看请求者申请的数量和 Semaphore 现有的资源能否匹配，如果能满足，就将这些资源返回给请求者，否则对不起，只能返回一个 Pending 状态。<br>如果申请资源成功，返回一个 <code>OwnedSemaphorePermit</code> 结构，表示申请到了 <code>permits</code> 个资源，同时持有 <code>Arc&lt;Semaphore&gt;</code>，是需要在其 drop 时，将申请的所有 permitd 悉数返还给 Semaphore</p><p>但对于我们这里用到的结构来说，每接收一个请求，意味系统再能够处理的请求就少了一份，只需要分配出去一个默认的 <code>OwnedSemaphorePermit&#123; sem, permits:1 &#125;</code> 的结构即可<br>眼见为实：acquire_owned 函数中，通过 <code>ll_sem.acquire(1)</code> 获取了单个资源，等待该操作完成，就能返回一个许可</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">acquire_owned</span></span>(<span class="hljs-keyword">self</span>: Arc&lt;<span class="hljs-keyword">Self</span>&gt;) -&gt; <span class="hljs-built_in">Result</span>&lt;OwnedSemaphorePermit, AcquireError&gt; &#123;<br>    <span class="hljs-keyword">self</span>.ll_sem.acquire(<span class="hljs-number">1</span>).<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-literal">Ok</span>(OwnedSemaphorePermit &#123;<br>        sem: <span class="hljs-keyword">self</span>,<br>        permits: <span class="hljs-number">1</span>,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-如何利用-Semaphore-实现-ConcurrencyLimit-这个-Service"><a href="#2-如何利用-Semaphore-实现-ConcurrencyLimit-这个-Service" class="headerlink" title="2. 如何利用 Semaphore 实现 ConcurrencyLimit 这个 Service"></a>2. 如何利用 Semaphore 实现 ConcurrencyLimit 这个 Service</h2><p>熟悉了 Semaphore 的作用和大致原理，接下来要思考的是，如何用好这个结构。<br>Semaphore 很容易创建， <code>semaphore: PollSemaphore::new(semaphore)</code> 一行代码即可搞定，关键是如何通过 Semaphore 控制并发？或者说，如果描述 <code>并发量</code> 这种资源？</p><p>我们先来看一个结构 TODO!</p><p>类似 RateLimit，必须要明确几个时间点：</p><ol><li>在 poll_ready 函数中，如果当前已经超出并发量，需要等待 <code>semaphore.poll_acquire()</code> 返回 Poll::Ready 之后，才表明我们做好了接收请求的准备</li><li>一个请求的声明周期，在这里应该是从 <code>ConcurrencyLimit::call</code> 开始，直到内层服务 call 结果返回的 Future 得到最终结果为止，我们需要将 OwnedSemaphorePermit 和这个声明周期绑定，也就是确保开始时获取到一个 Permit，结束时返还该Permit，如何实现？</li></ol><p>ConcurrencyLimit 给出了一个非常优雅的设计</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ConcurrencyLimit</span></span>&lt;T&gt; &#123;<br>    inner: T,<br>    semaphore: PollSemaphore,<br>    permit: <span class="hljs-built_in">Option</span>&lt;OwnedSemaphorePermit&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;S, Request&gt; Service&lt;Request&gt; <span class="hljs-keyword">for</span> ConcurrencyLimit&lt;S&gt;<br><span class="hljs-keyword">where</span><br>    S: Service&lt;Request&gt;,<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Response</span></span> = S::Response;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = S::Error;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Future</span></span> = ResponseFuture&lt;S::Future&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll_ready</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;<span class="hljs-built_in">Result</span>&lt;(), Self::Error&gt;&gt; &#123;<br>        <span class="hljs-comment">// 如果 permit 是 None，意味着之前交出的许可已经被消耗了</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.permit.is_none() &#123;<br>            <span class="hljs-keyword">self</span>.permit = ready!(<span class="hljs-keyword">self</span>.semaphore.poll_acquire(cx));<br>            <span class="hljs-built_in">debug_assert!</span>(<br>                <span class="hljs-keyword">self</span>.permit.is_some(),<br>                <span class="hljs-string">&quot;ConcurrencyLimit semaphore is never closed, so `poll_acquire` \</span><br><span class="hljs-string">                 should never fail&quot;</span>,<br>            );<br>        &#125;<br><br>        <span class="hljs-comment">// 一旦获得了许可，就可以询问内部 Service 是否 ready</span><br>        <span class="hljs-keyword">self</span>.inner.poll_ready(cx)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, request: Request) -&gt; Self::Future &#123;<br>        <span class="hljs-comment">// 这个 permit 不一定是自己申请的</span><br>        <span class="hljs-keyword">let</span> permit = <span class="hljs-keyword">self</span><br>            .permit<br>            .take()<br>            .expect(<span class="hljs-string">&quot;max requests in-flight; poll_ready must be called first&quot;</span>);<br><br>        <span class="hljs-comment">// Call the inner service</span><br>        <span class="hljs-keyword">let</span> future = <span class="hljs-keyword">self</span>.inner.call(request);<br><br>        ResponseFuture::new(future, permit)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这种结构似乎有一点问题？因为当我们连续两次调用一个 ConcurrencyLimit::call 函数的时候，第二次一定会在 <code>self.permit.take()</code> 处 panic，<br>这样说，难道我们轻易就能写出下面这段不安全的代码？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> service = ServiceBuilder::new()<br>    .concurrency_limit(<span class="hljs-number">3</span>)<br>    .layer(LogLayer)<br>    .service(EchoService);<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s1 = service.clone();<br><span class="hljs-keyword">let</span> s1 = s1.ready().<span class="hljs-keyword">await</span>.unwrap();<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s2 = service.clone();<br><span class="hljs-keyword">let</span> s2 = s2.ready().<span class="hljs-keyword">await</span>.unwrap();<br><br><span class="hljs-keyword">let</span> r1 = s1.call(<span class="hljs-string">&quot;123&quot;</span>.into()).<span class="hljs-keyword">await</span>.unwrap();<br><span class="hljs-keyword">let</span> r2 = s2.call(<span class="hljs-string">&quot;123&quot;</span>.into()).<span class="hljs-keyword">await</span>.unwrap();<br><span class="hljs-built_in">assert_eq!</span>(r1, <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;123&quot;</span>));<br><span class="hljs-built_in">assert_eq!</span>(r2, <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;123&quot;</span>));<br></code></pre></td></tr></table></figure><p>其实不然，你会发现上面这段代码编译不会通过，因为 ServiceExt::ready 函数中，返回的 Ready 结构包含了对于 self 的引用，是有生命周期约束的，上面这段代码显然就因为 <code>mutable more than once at a time</code> 而无法编译。</p><p>为了解决这个问题，必须这样使用 Service：在调用 ServiceExt 提供的 ready 函数之前，一定需要先 clone 出一个相同的 service<br>正如下面代码所示，我们创建了 service 之后，分别 clone 得到 s1,s2，然后分别提供服务</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s1 = service.clone();<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s2 = service.clone();<br><br><span class="hljs-keyword">let</span> s1 = s1.ready().<span class="hljs-keyword">await</span>.unwrap();<br><span class="hljs-keyword">let</span> s2 = s2.ready().<span class="hljs-keyword">await</span>.unwrap();<br><br><span class="hljs-keyword">let</span> r1 = s1.call(<span class="hljs-string">&quot;123&quot;</span>.into()).<span class="hljs-keyword">await</span>.unwrap();<br><span class="hljs-built_in">assert_eq!</span>(r1, <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;123&quot;</span>));<br><br><span class="hljs-keyword">let</span> r2 = s2.call(<span class="hljs-string">&quot;123&quot;</span>.into()).<span class="hljs-keyword">await</span>.unwrap();<br><span class="hljs-built_in">assert_eq!</span>(r2, <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;123&quot;</span>));<br></code></pre></td></tr></table></figure><p>实际上，这正是我们在多线程多任务场景下希望使用 service 的方式：我们希望对于每一个到来的连接，都通过 clone 创建相同的服务，并且利用 tokio::spawn 提交任务，交给 runtime 调度执行</p><h3 id="ConcurrencyLimit-真正做了什么"><a href="#ConcurrencyLimit-真正做了什么" class="headerlink" title="ConcurrencyLimit 真正做了什么"></a>ConcurrencyLimit 真正做了什么</h3><p>可能稍微有一点绕，但是我在试图证明当前的 ConcurrencyLimit 正确性：</p><ol><li><p>无法同时有两个 service.call(req)，rust 的所有权机制防止了这一点，因此 <code>self.permit.take()</code> 不会 panic</p></li><li><p>真正引用中使用 service 对 req 做出响应的时候，会将 service clone 一份，移动到 async Future 中，这就要求 ConcurrencyLimit 实现了 Clone</p><ul><li><p>在 ConcurrencyLimit 的 Clone 实现中，实际上每一个 clone 出去的结构，都共享了同一个底层的 Semaphore，并且会将 <code>Option&lt;OwnedSemaphorePermit&gt;</code> 结构设置为 None</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Clone</span>&gt; <span class="hljs-built_in">Clone</span> <span class="hljs-keyword">for</span> ConcurrencyLimit&lt;T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clone</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            inner: <span class="hljs-keyword">self</span>.inner.clone(),<br>            semaphore: <span class="hljs-keyword">self</span>.semaphore.clone(),<br>            permit: <span class="hljs-literal">None</span>,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Clone 得到的 <code>ConcurrencyLimit.permit = None</code>，并且，每一个 Clone 得到的 Service 在真正被 call 前，而已必须要经过 poll_ready 来确认是否准备就绪，并发控制因此而来：这些共享底层信号量的任务，将一起受到 Semaphore的限制。相当于通过 tokio::spawn 提交了 x 个任务，最多只能有 n 个被执行，n 是并发限制量</p></li></ul></li></ol><h3 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h3><p>确定了 ConcurrencyLimit 的数据结构之后，在相应的 Layer 中要完成的事情就很简单了：确定 ConcurrencyLimit::new 中所需的参数，并在 Layer::layer 函数中完成相应创建</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug, Clone)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ConcurrencyLimitLayer</span></span> &#123;<br>    max: <span class="hljs-built_in">usize</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> ConcurrencyLimitLayer &#123;<br>    <span class="hljs-comment">/// Create a new concurrency limit layer.</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(max: <span class="hljs-built_in">usize</span>) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        ConcurrencyLimitLayer &#123; max &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;S&gt; Layer&lt;S&gt; <span class="hljs-keyword">for</span> ConcurrencyLimitLayer &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Service</span></span> = ConcurrencyLimit&lt;S&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">layer</span></span>(&amp;<span class="hljs-keyword">self</span>, service: S) -&gt; Self::Service &#123;<br>        ConcurrencyLimit::new(service, <span class="hljs-keyword">self</span>.max)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>上一小节提到了 RateLimit，是针对单个任务而言，限制一段时间内接收的最多请求，本节的 ConcurrencyLimit，是针对多任务而言，限制每一个时刻整个系统中最多接收的请求数。</p><p>要注意的一点就是 Service 的 Clone 问题。针对 Concurrency 而言，要通过 clone 出多任务，扩展系统的并发量，而 RateLimit 完全没有必要实现 Clone trait，即使实现了 Clone trait，其含义也是模糊不清的，这一点使用的时候一定要想好</p>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
      <category>tower</category>
      
      <category>middlewares</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.3 tower 中间件模型</title>
    <link href="/2022/01/10/rust/tower_internal/middleware-core/"/>
    <url>/2022/01/10/rust/tower_internal/middleware-core/</url>
    
    <content type="html"><![CDATA[<h2 id="1-洋葱圈模型"><a href="#1-洋葱圈模型" class="headerlink" title="1. 洋葱圈模型"></a>1. 洋葱圈模型</h2><p>主流的中间件，大多提供了下面这种洋葱圈模型，方便用户在一个调用中插入自定义逻辑预处理（pre-handle）及后处理（post-handle），配合handler实现一个完整的请求处理生命周期。</p><p>比较形象的图示：<br><img src="/images/middleware1.png" alt="middleware"></p><p>上面这种表示比较抽象，进一步结合实际中间件中的 pre_handler 和 post_handler，可以表示为下面的结构：</p><p><img src="/images/middleware.png" alt="middleware handler"></p><h2 id="2-深入中间件"><a href="#2-深入中间件" class="headerlink" title="2. 深入中间件"></a>2. 深入中间件</h2><p>如果深入中间件，就会发现，实现起来并不是一件多么困难的事情，我们所要做的就是将 Service 层层封装，最终转换成一个最外层的 Service 暴露出去，但是 Service 需要进行区分：</p><ol><li>中间件。对于中间层的 Service，本质是对内层的装饰，在 pre_handler 之后，调用内层的 Service，并且在调用完成之后，处理 post_handler 逻辑。  </li><li>核心处理函数。最核心的 Service 需要处理业务处理逻辑，无内层 Service，处理结束之后，从这里开始逐层返回 Response。</li></ol><p>实践起来，需要解决两个问题：如何包装？如何保存所有的中间件？</p><p>其实第一个问题，我们已经在 tower-core 一章中详细描述了，这里不再赘述，这里来详细分析一下如何保存中间件：</p><ol><li>数组。</li><li>链表。</li></ol><p>在 Rust 当中，将中间件保存在数组中，其实不是一件很直观的事情，因为数组要求所有中间件有相同的类型。但也不是没有办法：<code>Box&lt;dyn Layer&gt;</code>  动态派发，也就是将中间件保存为 <code>Vec&lt;Box&lt;dyn Layer&gt;&gt;</code>。但是这样做显然是有代价的，Box 的开销能避免就避免。</p><p>如果用链表来存储中间件，也存在这样的问题，仍然需要借助 Box 来完成动态派发，而且链表的局部性更差，性能也更拉胯。但优点是中间件的添加和删除迅速，灵活。</p><p>上面似乎是两瓶毒药，难道我们不得不选择一瓶喝下去吗？其实不然，Tower 选择了一个最 Rusty 的解决方案，虽然也有种种弊端，但算是符合 zero-cost 的哲学。</p><h3 id="2-1-Tower-中间件如何组织"><a href="#2-1-Tower-中间件如何组织" class="headerlink" title="2.1 Tower 中间件如何组织"></a>2.1 Tower 中间件如何组织</h3><p>Tower 选择解决 Rust 的类型推导，来高效地解决这个问题。此话怎讲？</p><p>Rust 中泛型算是比较完善的了，其核心在于类型推导。大致可以认为，对于一个带泛型参数的类型而言，其泛型是根其构造时候的参数决定的。这一点很关键。</p><p>考虑下面的 Stack 结构，其有两个泛型参数：Inner 和 Outer，会在 <code>Stack::new</code> 方法中，根据外界传入的参数推导而来</p><figure class="highlight rust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Clone)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span></span>&lt;Inner, Outer&gt; &#123;<br>    inner: Inner,<br>    outer: Outer,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;Inner, Outer&gt; Stack&lt;Inner, Outer&gt; &#123;<br>    <span class="hljs-comment">/// Create a new `Stack`.</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(inner: Inner, outer: Outer) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        Stack &#123; inner, outer &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，我们可以构造出各种 Stack 类型出来:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> a:Stack&lt;<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">u32</span>&gt; = Stack::new(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">A</span></span> = Stack&lt;<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">u32</span>&gt;;<br><br><span class="hljs-keyword">let</span> b:Stack&lt;A, <span class="hljs-built_in">i8</span>&gt; = Stack::new(a.clone(), <span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">let</span> c:Stack&lt;A, A&gt; = Stack::new(a.clone(), a.clone();<br></code></pre></td></tr></table></figure><p>理论上这个 Stack 的泛型可以无限发散，但我们也只需要其中的一小部分就可以了，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> a:Stack&lt;L1, ()&gt; = Stack::new(layer1, ());   <span class="hljs-comment">// typeof 是我自创的语法，大致意思可以参照C语言的 typeof 关键字</span><br><span class="hljs-keyword">let</span> b:Stack&lt;L2, <span class="hljs-keyword">typeof</span>(a)&gt; = Stack::new(layer2, a);<br><span class="hljs-keyword">let</span> c:Stack&lt;L3, <span class="hljs-keyword">typeof</span>(b)&gt; = Stack::new(layer3, b);<br><span class="hljs-keyword">let</span> d:Stack&lt;L4, <span class="hljs-keyword">typeof</span>(c)&gt; = Stack::new(layer4, c);<br></code></pre></td></tr></table></figure><p>我们可以无限给 Stack 叠加 Layer，而这里的 <code>:Stack&lt;L1, ()&gt;</code> 这种类型，完全不需要我们手写，<strong>编译器能帮我们搞定！</strong></p><p>但同时我们也看到，每次在原有的 Stack 上叠加一层，都会创建一个全新的 Stack 类型，这就足以满足我们的需求了。</p><p>但身为框架的开发者，也不希望用户每次都要像上面一样，手动构造出最终的 Stack 类型，这时，Rust Builder 模式就发挥用武之地了。</p><p>Tower 提供了一个 ServiceBuilder，可以很轻松地在上面叠加中间件层，我们来看一下内部是如何实现的。</p><p>在 <code>ServiceBuilder::layer</code> 这个核心方法中，所做的就是不断修改 Stack 的结构。ServiceBuilder 同时提供了一些内置的中间件 Layer，也仅仅是针对 layer 函数的封装。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Clone)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ServiceBuilder</span></span>&lt;L&gt; &#123;<br>    layer: L,<br>&#125;<br><br><br><span class="hljs-keyword">impl</span>&lt;L&gt; ServiceBuilder&lt;L&gt; &#123;<br><br>   <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">layer</span></span>&lt;T&gt;(<span class="hljs-keyword">self</span>, layer: T) -&gt; ServiceBuilder&lt;Stack&lt;T, L&gt;&gt; &#123;<br>      ServiceBuilder &#123;<br>         layer: Stack::new(layer, <span class="hljs-keyword">self</span>.layer),<br>      &#125;<br>   &#125;<br>   ... <br>&#125;<br></code></pre></td></tr></table></figure><p>注意一点，layer 函数每次都会接收一个 <code>self</code>，而不是 <code>&amp;mut self</code>。这也正应了上面所说的：Stack 类型前后不兼容，<code>self</code> 的类型已经在其创建的时候推导（并固定）下来了，<strong>唯一</strong>的方式就是每次创建一个新的 <code>Self</code> ，并借助<strong>类型系统推导</strong>出来。这一点虽然自己一个人很难想出来，但看到 ServiceBuilder 里面这样用，的确也是那么回事。</p><h3 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2  小结"></a>2.2  小结</h3><p>基本原理已经介绍清楚了，也是时候来做一个小结。</p><p>为了防止动态派发带来的开销，以及提供更多的灵活性，Rust 选择了类型推导这条别的语言<strong>从未设想的道路</strong>。很精妙，很高效，那么代价是什么？</p><p>计算机世界中没有银弹，Tower 的 Stack Layer 组织模式，虽然实现了高性能，但同时也带来了 <strong>类型上的开销</strong>。是的，没错，类型也是有开销的，更多的是在程序员的心智负担上！如果你使用过 Tower，一定（或曾经）对这过程中繁杂的类型参数不胜其扰。一个很细微的错误，可能就会给你报很长的错误，大多是类型不匹配导致的，如果不太熟悉这套类型系统，甚至不知如何下手……</p><p>我有时候甚至在想，是否真的有必要追求那么极致的性能，如果就是用 <code>Box&lt;dyn Layer&gt;</code> 和 <code>Box&lt;dyn Service&gt;</code>，这个世界是不是会清净许多？</p><p>Anyway，既然用上了这一套，就先把它吃透，毕竟已经是 Rust 的中间件既定标准了，生态上也不用担心，有 Tokio，tonic 撑腰，前景还是很明朗的，况且，掌握了这些，再去写一个 golang 的中间件框架，应该是小意思吧 🐶</p><p>后续教程会详细说明，应该如何编写一个中间件，以及从 Tower 内置中间件中，我们可以学到的编码规范和技巧。</p><p>Tower 内置的中间件如下（打✔️的是会详细介绍的中间件）：</p><ol><li>buffer(cache)  ✔️</li><li>rate limit    ✔️</li><li>concurrency limit ✔️</li><li>timeout ✔️</li><li>filter</li><li>retry</li><li>reconnect</li><li>route</li><li>discover</li></ol>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
      <category>tower</category>
      
      <category>basic</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.1 middleware custom</title>
    <link href="/2022/01/10/rust/tower_internal/middleware-custom/"/>
    <url>/2022/01/10/rust/tower_internal/middleware-custom/</url>
    
    <content type="html"><![CDATA[<p>先来回顾一下 Tower 当中的中间件模型：</p><p>通过 Service Trait 定义服务功能，通过 Layer Trait 搭建骨架，并通过 Stack 将所有的中间件粘合起来。并且， Service 和 Layer 通常是一一对应的关系。</p><p>本节就来带着大家动手实现实现一个日志中间件。</p><h2 id="1-日志中间件实现"><a href="#1-日志中间件实现" class="headerlink" title="1. 日志中间件实现"></a>1. 日志中间件实现</h2><p>以一个最简单的 Echo 业务 + 最简单的中间件 Log 为例，大致分为几个模块：</p><ol><li>核心业务 EchoService</li><li>LogService</li><li>LogLayer</li></ol><h3 id="1-1-核心业务-EchoService"><a href="#1-1-核心业务-EchoService" class="headerlink" title="1.1 核心业务 EchoService"></a>1.1 核心业务 EchoService</h3><p>首先定义 Echo  服务的业务逻辑，Echo 所做的就是原样返回，再简单不过了，为了简化泛型的处理，Request，Response，Error 类型都定义为 String</p><figure class="highlight rust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 这里导入的其实是后续所有代码所需的模块</span><br><span class="hljs-keyword">use</span> std::future::Future;<br><span class="hljs-keyword">use</span> std::pin::Pin;<br><span class="hljs-keyword">use</span> std::task::*;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EchoService</span></span>;<br><br><span class="hljs-keyword">impl</span> Service&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">for</span> EchoService &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Response</span></span> = <span class="hljs-built_in">String</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = <span class="hljs-built_in">String</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Future</span></span> = Pin&lt;<span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Future&lt;Output=<span class="hljs-built_in">Result</span>&lt;Self::Response, Self::Error&gt;&gt;&gt;&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll_ready</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, _: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;<span class="hljs-built_in">Result</span>&lt;(), Self::Error&gt;&gt; &#123;<br>        Poll::Ready(<span class="hljs-literal">Ok</span>(()))<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, req: <span class="hljs-built_in">String</span>) -&gt; Self::Future &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;request:&#123;&#125;&quot;</span>, &amp;req);<br>        <span class="hljs-built_in">Box</span>::pin(<span class="hljs-keyword">async</span> &#123; <span class="hljs-literal">Ok</span>(req) &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-LogService-结构"><a href="#1-2-LogService-结构" class="headerlink" title="1.2 LogService 结构"></a>1.2 LogService 结构</h3><p>接下来需要定义 Log 中间件功能，首先明确目标：分别记录 request 和 response 内容（为了避免 <code>Debug, Clone</code> 这样的约束，这里将其修改为输出一段文字）：</p><ol><li>在内层 Service 调用之前，输出 “pre-call”</li><li>在内层 Service 返回结果之后，输出 “post-call”</li></ol><p>之前一直强调，Layer 是<strong>骨架</strong>，Service 是<strong>血肉</strong>，这两者是紧密结合，相辅相成的关系。在这里，不妨将 Log 中间件的 Service 和 Layer 分为称为 LogService 和 LogLayer。</p><p>首先考虑 LogService 的功能，中间件是内层服务的包装（Decorator），自然需要将内层服务保存下来，否则就直接”失联”，很自然的，在 LogService 中定义一个 <code>inner</code> 的字段，保存内层服务的句柄。对于 LogService 而言，由于其功能比较单一，也就不需要添加更多的字段了。LogService 的结构可以确定下来：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LogService</span></span>&lt;S&gt; &#123;<br>    inner: S,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;S&gt; LogService&lt;S&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(inner: S) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123; inner &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-Pin-lt-Box-lt-dyn-Future-gt-gt-VS-自定义-Future-？"><a href="#1-3-Pin-lt-Box-lt-dyn-Future-gt-gt-VS-自定义-Future-？" class="headerlink" title="1.3 Pin&lt;Box&lt;dyn Future&gt;&gt;  VS 自定义 Future ？"></a>1.3 Pin&lt;Box&lt;dyn Future&gt;&gt;  VS 自定义 Future ？</h3><p>已经确定了 LogService 的结构，接下来要做的就是为 LogService 实现 <code>Service Trait</code></p><p>对于 poll_ready 而言，本身 LogService 是无状态的，按理来说可以返回 <code>Poll::Ready</code>，但是，我们无法确定 <code>inner</code> 是否为有状态的服务，所以直接转发（forward）内层 Service 的 poll_ready，即 <code>self.inner.poll_ready(cx)</code>。</p><p>接下来的关键点在于：<strong>LogService::call 函数中，应该返回什么样的 Future，才能实现输出日志的功能？</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;S, Req&gt; Service&lt;Req&gt; <span class="hljs-keyword">for</span> LogService&lt;S&gt;<br>    <span class="hljs-keyword">where</span><br>        S: Service&lt;Req&gt;,<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Response</span></span> = S::Response;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = S::Error;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Future</span></span> = LogFuture&lt;S::Future&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll_ready</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;<span class="hljs-built_in">Result</span>&lt;(), Self::Error&gt;&gt; &#123;<br>        <span class="hljs-keyword">self</span>.inner.poll_ready(cx)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, req: Req) -&gt; Self::Future &#123;<br>        todo!()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>大致的解决思路是：首先获取到 <code>inner.call(req)</code> 的结果，这是一个 Future，然后在该 Future 返回的前后，分别输出日志。如下所示</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> f = <span class="hljs-keyword">self</span>.inner.call(req);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;pre-handler&quot;</span>);<br><span class="hljs-keyword">let</span> r = f.<span class="hljs-keyword">await</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;post-handler&quot;</span>);<br><span class="hljs-keyword">return</span> r;<br><br></code></pre></td></tr></table></figure><p>但是上面这段代码还是一厢情愿了。<code>.await</code> 虽然是最直观的将异步转换成同步执行的模式，但其必须要在 <code>async</code> 代码块中使用，但是，目前如果不开启 GAT(generic assosiate type) 这个 feature，无法在 Trait 中定义 <code>async fn</code>。如何处理这种困境呢？</p><p>目前有两种可行的方案，各有利弊：</p><ol><li><p>返回 <code>Box::pin(async move &#123; ... &#125;)</code></p><p> 这样就可以在 async 代码块中利用 await 直接 await inner Service 调用返回的 Future，将异步调用转换成同步的方式，是一种比较 high-level 的实现方式，利用 async/await 这组高级抽象减少了心智负担，但实际上我们也付出了代价。</p><p> 如果仔细阅读之前小节对于 <a href="./why_pin_withoutboats.md">Pin</a> 的描述，会认识到：一个 Future 其实是一颗树状结构，只需要一次内存分配，就能保证内部所有子 Future 也都能在状态机状态变迁之后获取到相应的堆内存，而通过 enum 保存状态，这种结构的内存利用非常高效。但是在 Service trait 中，由于 GAT(generic assosiate type) 能力的不足，只能通过 Box::pin 的方式，返回一个 <code>Pin&lt;Box&lt;dyn Future&lt;Output=Result&lt;Self::Response, Self::Error&gt;&gt;&gt;&gt;</code>，而无法将 Service::Future 和 async 代码块结构的 <code>impl Future&lt;Output=...&gt;</code> 类型关联起来，因此需要通过<code>动态分发</code>解决这个问题，但这也造成了额外且不太必要（有GAT时）的堆内存开销，在高性能场景下，可能不是一个很好的选择。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123; <br>    ...<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Future</span></span> = Pin&lt;<span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Future&lt;Output=<span class="hljs-built_in">Result</span>&lt;Self::Response, Self::Error&gt;&gt;&gt;&gt;;<br><br></code></pre></td></tr></table></figure></li><li><p>手动实现 Future</p><p> 如果说 <code>Box::pin(async move &#123; ... &#125;)</code> 是一种比较 <strong>high-level</strong>  的解决方案，这里的第二个方案就是 <strong>low-level</strong> 的模式：</p><p> 缺少了 async/await 这组高级抽象带来的便捷之后，只能将 <code>inner.call(req)</code> 保存到一个 LogFuture 中，并手动实现 poll，虽然比较麻烦，但也有其好处：不需要对 Futuere 的一次额外堆内存分配，性能会有所提升</p><p> 事情进行到这里，逻辑上说得通：为了性能，麻烦就麻烦一点吧！只不过，又遇到了一点小问题：Pin-project。</p><p> 将  <code>inner.call(req)</code> 保存到 LogFuture 中以后，这个 LogService 到底有没有实现 <code>Unpin trait</code>？之所以关心这一点，是因为在 <code>Future::poll</code> 中，我们得到的是一个 <code>Pin&lt;&amp;mut Self&gt;</code>，但只有获取到 <code>inner: Pin&lt;&amp;mut I&gt;</code> 才能进行真正的 poll，如何确保正确性？unsafe ？pin-project，Yes！</p><p> 在 <a href="./why_pin_withoutboats.md">why_pin</a> 一文中提到，<code>pin-project</code> 这个宏确保了 从 <code>Pin&lt;&amp;mut Self&gt;</code> 投影到 <code>Pin&lt;&amp;mut I&gt;</code> 是100%安全的，投影之后便可以对其进行 poll，也就可以在 <code>inner.poll(cx)</code>前后插入 LogService 的 hook 逻辑</p></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> pin_project_lite::pin_project;<br>pin_project! &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LogFuture</span></span>&lt;I&gt; &#123;<br>        <span class="hljs-meta">#[pin]</span><br>        <span class="hljs-keyword">pub</span> inner: I,<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;I, T, E&gt; Future <span class="hljs-keyword">for</span> LogFuture&lt;I&gt;<br>    <span class="hljs-keyword">where</span><br>        Resp: Future&lt;Output=<span class="hljs-built_in">Result</span>&lt;T, E&gt;&gt;,<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = <span class="hljs-built_in">Result</span>&lt;T, E&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll</span></span>(<span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;<br>        <span class="hljs-keyword">let</span> this = <span class="hljs-keyword">self</span>.project();<br>        <span class="hljs-keyword">let</span> inner = this.inner;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;pre handler, called every poll&quot;</span>);<br>        <span class="hljs-keyword">let</span> r = <span class="hljs-keyword">match</span> inner.poll(cx) &#123;<br>            core::task::Poll::Ready(v) =&gt; &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;post handler after get the resp&quot;</span>); <span class="hljs-comment">// hook 逻辑</span><br>                Poll::Ready(v)<br>            &#125;<br>            core::task::Poll::Pending =&gt; Poll::Pending,<br>        &#125;;<br>        r<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于到 <code>LogService::call</code> 中，我们只需要将 <code>self.inner.call(req)</code> 的结果保存到 LogFuture 中，返回该 Future 即可，并且，在返回之前，插入 <code>pre-handler</code> 逻辑都是可行的（poll 函数中的 pre-handler 可能会调用多次）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    ...<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Future</span></span> = LogFuture&lt;S::Future&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, req: Req) -&gt; Self::Future &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;pre handler before pass the req&quot;</span>);<br>        <span class="hljs-keyword">let</span> f = <span class="hljs-keyword">self</span>.inner.call(req);<br>        LogFuture::new(f)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-LogLayer"><a href="#1-4-LogLayer" class="headerlink" title="1.4 LogLayer"></a>1.4 LogLayer</h3><p>完成了 LogService ，接下来让我们定义 LogLayer，其需要实现 Layer trait，接收 inner service，并创建 LogService。并且由于 LogSevice 不需要接收别的参数，这里的 LogLayer 也就不需要保存更多的信息了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LogLayer</span></span>;<br><br><span class="hljs-keyword">impl</span>&lt;S&gt; Layer&lt;S&gt; <span class="hljs-keyword">for</span> LogLayer &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Service</span></span> = LogService&lt;S&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">layer</span></span>(&amp;<span class="hljs-keyword">self</span>, inner: S) -&gt; Self::Service &#123;<br>        LogService::new(inner)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h2><p>通过编写一个简单的 Log 中间件，我们可以学习到下面几种规范（by Tower）：</p><ol><li>自定义 Service，保存内层 Service，并实现 Service trait</li><li>Service::call 方法的实现中，返回一个 Future，这里有两种选择：<br> a. 返回 <strong>Box::pin(async { … })</strong><br> b. 返回 <strong>自定义Future</strong>，保存 inner service 调用返回的 Future，并且手动实现 poll 逻辑，借助 pin_project! 实现 projection</li><li>自定义 Layer，并实现 Layer trait，在 Layer::layer 中创建对应的 Wrapper Service</li></ol>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
      <category>tower</category>
      
      <category>middlewares</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.2 tower-rate limit</title>
    <link href="/2022/01/10/rust/tower_internal/middleware-rate/"/>
    <url>/2022/01/10/rust/tower_internal/middleware-rate/</url>
    
    <content type="html"><![CDATA[<p>Tower 自带的流量控制中间件，核心功能为：<strong>在 x 时间内，最多接收 n 个请求，如果超出最大流量，休眠直到下一个刷新点</strong></p><h2 id="1-核心数据结构"><a href="#1-核心数据结构" class="headerlink" title="1. 核心数据结构"></a>1. 核心数据结构</h2><p>为了描述这个核心功能，我们定义了下面的核心数据结构:</p><ol><li>rate: 描述一段时间内，最多允许多少请求通过</li><li>sleep: 定时器，表示休眠的时间</li></ol><p>而这里的 RateLimit 就是我们想要对外提供的 Service，通过相对应的 RateLayer 创建，结构非常清晰。<br>接下来的主要问题是，我们应该如何为 RateLimit 实现 <code>Service trait</code>？</p><figure class="highlight rust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> tokio::time::&#123;Instant, Sleep&#125;;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><br><span class="hljs-comment">/* Rate */</span><br><span class="hljs-meta">#[derive(Debug, Copy, Clone)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rate</span></span> &#123;<br>    num: <span class="hljs-built_in">u64</span>,<br>    per: Duration,<br>&#125;<br><br><span class="hljs-comment">/* Service */</span><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RateLimit</span></span>&lt;T&gt; &#123;<br>    inner: T,<br>    rate: Rate,<br>    sleep: Pin&lt;<span class="hljs-built_in">Box</span>&lt;Sleep&gt;&gt;,<br>&#125;<br><br><span class="hljs-comment">/* Layer */</span><br><span class="hljs-meta">#[derive(Debug, Clone)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RateLimitLayer</span></span> &#123;<br>    rate: Rate,<br>&#125;<br><br><span class="hljs-keyword">impl</span> RateLimitLayer &#123;<br>    <span class="hljs-comment">/// Create new rate limit layer.</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(num: <span class="hljs-built_in">u64</span>, per: Duration) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">let</span> rate = Rate::new(num, per);<br>        RateLimitLayer &#123; rate &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;S&gt; Layer&lt;S&gt; <span class="hljs-keyword">for</span> RateLimitLayer &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Service</span></span> = RateLimit&lt;S&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">layer</span></span>(&amp;<span class="hljs-keyword">self</span>, service: S) -&gt; Self::Service &#123;<br>        RateLimit::new(service, <span class="hljs-keyword">self</span>.rate)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-为-RateLimit-实现-Service-trait"><a href="#2-为-RateLimit-实现-Service-trait" class="headerlink" title="2. 为 RateLimit 实现 Service trait"></a>2. 为 RateLimit 实现 Service trait</h2><p>我们的想法很简单：通过一个计数器来计算请求了多少次，并且设置定时器，每隔一段时间就进行刷新，如果在这段时间内，统计出来请求数目高于我们规定的最大限额，就应该拒绝服务，否则，返回 Ready 状态</p><p>在这个设计中，我们也发现了， RateLimit 组件其实是一个 Stateful 的有状态组件，因此之前的设计其实存在一些缺陷，需要保存 RateLimit 的状态<br>接下来就创建该结构，并且给 RateLimit 添加一个字段 state</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">State</span></span> &#123;<br>    <span class="hljs-comment">// The service has hit its limit</span><br>    Limited,<br>    Ready &#123; until: Instant, rem: <span class="hljs-built_in">u64</span> &#125;,<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RateLimit</span></span>&lt;T&gt; &#123;<br>    inner: T,<br>    rate: Rate,<br>    state: State,<br>    sleep: Pin&lt;<span class="hljs-built_in">Box</span>&lt;Sleep&gt;&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><p>这里还有一点需要明确，当我们因为请求数目过多，需要拒绝服务的时候，理应在 poll_ready 阶段直接返回 Err，这样就可以使得用户尽早感知，避免通过 RateLimit::call 创建 Future，带来不必要的开销。但是，对于 <strong>请求量</strong> 的统计，只能在 call 函数中实现，因为用户完全有可能在 poll_ready 之后没有调用这个 Service。  </p><p>有了上面这两点，就很容易设计了：</p><ol><li>poll_ready 函数中，判断 Self.state，如果是 Ready，返回内部服务的状态，否则如果是 Limited 状态，说明我们已经进入了休眠状态，需要查看是否到了下一次刷新时间点，如果已经到点，我们就可以将原先的计数刷新，开始新一轮的<strong>流量控制</strong>，也只有在刷新之后，此时才会去判断内层服务是否 ready</li><li>call 函数中，我们需要完成对请求数目的统计，首先统计当前请求的时间，如果已经开始下一轮流量控制，需要重置计数。<strong>当剩余能够对外提供服务的数量</strong> 这个计数递减到 0 的时候，状态将从 Ready 转变为 Limited，同时设置定时器，表示直到下次请刷新之前，都会拒绝服务</li></ol><p>RateLimit 的代码实现也非常清晰，总的来说是一个良好设计的中间件，并且也能够在实际服务中派上用场</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;S, Request&gt; Service&lt;Request&gt; <span class="hljs-keyword">for</span> RateLimit&lt;S&gt;<br><span class="hljs-keyword">where</span><br>    S: Service&lt;Request&gt;,<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Response</span></span> = S::Response;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = S::Error;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Future</span></span> = S::Future;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll_ready</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;<span class="hljs-built_in">Result</span>&lt;(), Self::Error&gt;&gt; &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.state &#123;<br>            State::Ready &#123; .. &#125; =&gt; <span class="hljs-keyword">return</span> Poll::Ready(ready!(<span class="hljs-keyword">self</span>.inner.poll_ready(cx))),<br>            State::Limited =&gt; &#123;<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> Poll::Pending = Pin::new(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.sleep).poll(cx) &#123;<br>                    tracing::trace!(<span class="hljs-string">&quot;rate limit exceeded; sleeping.&quot;</span>);<br>                    <span class="hljs-keyword">return</span> Poll::Pending;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">self</span>.state = State::Ready &#123;<br>            until: Instant::now() + <span class="hljs-keyword">self</span>.rate.per(),<br>            rem: <span class="hljs-keyword">self</span>.rate.num(),<br>        &#125;;<br><br>        Poll::Ready(ready!(<span class="hljs-keyword">self</span>.inner.poll_ready(cx)))<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, request: Request) -&gt; Self::Future &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.state &#123;<br>            State::Ready &#123; <span class="hljs-keyword">mut</span> until, <span class="hljs-keyword">mut</span> rem &#125; =&gt; &#123;<br>                <span class="hljs-keyword">let</span> now = Instant::now();<br><br>                <span class="hljs-comment">// If the period has elapsed, reset it.</span><br>                <span class="hljs-keyword">if</span> now &gt;= until &#123;<br>                    until = now + <span class="hljs-keyword">self</span>.rate.per();<br>                    rem = <span class="hljs-keyword">self</span>.rate.num();<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> rem &gt; <span class="hljs-number">1</span> &#123;<br>                    rem -= <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">self</span>.state = State::Ready &#123; until, rem &#125;;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// The service is disabled until further notice</span><br>                    <span class="hljs-comment">// Reset the sleep future in place, so that we don&#x27;t have to</span><br>                    <span class="hljs-comment">// deallocate the existing box and allocate a new one.</span><br>                    <span class="hljs-keyword">self</span>.sleep.as_mut().reset(until);<br>                    <span class="hljs-keyword">self</span>.state = State::Limited;<br>                &#125;<br><br>                <span class="hljs-comment">// Call the inner future</span><br>                <span class="hljs-keyword">self</span>.inner.call(request)<br>            &#125;<br>            State::Limited =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;service not ready; poll_ready must be called first&quot;</span>),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h2><p>和上一小节实现的 LogService 相比，大体流程没有变化：</p><ol><li>自定义 RateLimit，实现 Service</li><li>自定义 RateLimitLayer，实现 Layer trait，并且在 layer 函数中创建 RateLimit 这个 Wrapper Service</li></ol><p>不太一样的是，这里在 RateLimit 中维护了一个状态 State，实际上这种模式在中间件当中是十分常见的，对于这种 State，我们定义一个良好的结构，用来描述 RateLimit 可能处于的状态，目标就完成了一大半，接下来就与实现 Future trait 类似，手动完成状态的转换，驱动中间件不断运转</p><p>这里一直没有提到，RateLimit 有一个非常致命的问题：无法 Clone！之所以这是一个很大的问题，是因为我们在处理请求的时候，为了横向扩展，会希望通过 tokio::spawn 处理每一个请求，也就要求 service 是可以 Clone 的，这样才能将其移动到 aysnc {..} 代码块中，整个服务的运转流程如下所示</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> service = ServiceBuilder::new()<br>    .layer(l1)<br>    .layer(l2)<br>    .layer(l3)<br>    .service(coreService);<br><br><span class="hljs-keyword">loop</span>&#123;<br>    <span class="hljs-keyword">let</span> conn = get_connection(..).<span class="hljs-keyword">await</span>;<br>    <span class="hljs-keyword">let</span> s = service.clone();<br><br>    <span class="hljs-comment">// 每一个 connection，都为其 clone 一个 &quot;一模一样&quot; 的 service</span><br>    tokio::spawn(<span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123;<br>        <span class="hljs-comment">/* s and conn were moved here */</span><br>        handle_conn(...).<span class="hljs-keyword">await</span>;<br>        ...<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>RateLimit 无法通过 Clone 创建，其实是有一定道理的：单线程环境中，完全没有必要将 Service Clone 出来再使用，只有在多线程多任务的模型中，才需要对每一个请求都 Clone 一个相应的 Service。但 RateLimit 的定义是：<strong>对单个服务一段时间内请求量的控制</strong>，这完全是针对单线程做出的限制。<br>后面小节中，我们也可以看到，对于多线程服务模型中的请求量，我们也可以做一定的限制，那就需要换一个名词了：<strong>并发控制</strong></p>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
      <category>tower</category>
      
      <category>middlewares</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.3 tower-timeout limit</title>
    <link href="/2022/01/10/rust/tower_internal/middleware-timeout/"/>
    <url>/2022/01/10/rust/tower_internal/middleware-timeout/</url>
    
    <content type="html"><![CDATA[<p>Timeout 这个中间件的责任也非常明确：如果某个服务调用时间过长，超出了规定的超时时间，直接返回错误</p><h2 id="1-模型抽象"><a href="#1-模型抽象" class="headerlink" title="1. 模型抽象"></a>1. 模型抽象</h2><p>为此，Timeout 肯定需要保留下面两个结构</p><ol><li>inner Service</li><li>超时时间 duration</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug, Clone)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Timeout</span></span>&lt;T&gt; &#123;<br>    inner: T,<br>    timeout: Duration,<br>&#125;<br></code></pre></td></tr></table></figure><p>参考 RateLimit，在这里需要明确定时器的工作起止时机。对于 Timeout 来说，我们关注的是内部服务调用的时长，因此，只有通过 <code>inner.call(req)</code> 发生了调用，才会开始计时，调用内部服务时候，每次返回 Pending 状态之后，再来检查定时器是否超时，做出响应的处理</p><p>仔细一看，这和我们之前自定义的 LogService 有一定相似之处：都需要在内部 Service 返回一定状态之后，添加 post-hook 逻辑，只不过 LogService 是在返回 Poll::Ready 之后输出 Response 内容，这里是在返回 Pending 之后，再去检查定时器。</p><p>对 Timeout 的场景再做一层抽象，其实和 <code>select!</code> 非常类似：按顺序循环等待多个任务执行，如果前面的 future 返回正确结果，直接返回，否则 falldown，检查优先级较低的 future 的结果。但这也要求在 async 代码块中执行这个操作。</p><h2 id="2-为-Timeout-实现-Service-trait"><a href="#2-为-Timeout-实现-Service-trait" class="headerlink" title="2. 为 Timeout 实现 Service trait"></a>2. 为 Timeout 实现 Service trait</h2><p>接下来就试着将刚刚分析的模型用代码表述出来，大体是下面的结构：</p><ol><li>poll_ready 函数中，仅仅是转发 inner service 的 poll_ready 结果，这没有什么好说的</li><li>call 函数中，一旦我们通过 <code>inner.call(reqeust)</code> 调用内层服务，马上设置 sleep 这个定时器</li></ol><p>最关键的问题是，返回什么样的 Future？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;S, Request&gt; Service&lt;Request&gt; <span class="hljs-keyword">for</span> Timeout&lt;S&gt;<br><span class="hljs-keyword">where</span><br>    S: Service&lt;Request&gt;,<br>    S::Error: <span class="hljs-built_in">Into</span>&lt;crate::BoxError&gt;,<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Response</span></span> = S::Response;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = todo!();<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Future</span></span> = todo!();<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll_ready</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;<span class="hljs-built_in">Result</span>&lt;(), Self::Error&gt;&gt; &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.inner.poll_ready(cx) &#123;<br>            Poll::Pending =&gt; Poll::Pending,<br>            Poll::Ready(r) =&gt; Poll::Ready(r.map_err(<span class="hljs-built_in">Into</span>::into)),<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, request: Request) -&gt; Self::Future &#123;<br>        <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">self</span>.inner.call(request);<br>        <span class="hljs-keyword">let</span> sleep = tokio::time::sleep(<span class="hljs-keyword">self</span>.timeout);<br><br>        todo!()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和 LogService 类似，我们在这里也有两个选择：</p><ol><li>手动实现 Future，包装 response</li><li>返回 <code>Box::pin(async &#123; todo!()&#125;)</code></li></ol><h3 id="2-1-高级-Future"><a href="#2-1-高级-Future" class="headerlink" title="2.1 高级 Future"></a>2.1 高级 Future</h3><p>先来看后者，通过 <code>Box::pin</code> 封装一个 async 代码块，虽然带来了额外的开销，但是有一个最大的好处：<strong>可以用上 async/await 这组高级抽象</strong>。这也带来了一连串的效应：可以使用 <code>select!</code> 宏来简化我们的实现，更加优雅，大体实现如下所示</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, request: Request) -&gt; Self::Future &#123;<br>    <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">self</span>.inner.call(request);<br>    <span class="hljs-keyword">let</span> sleep = tokio::time::sleep(<span class="hljs-keyword">self</span>.timeout);<br><br>    <span class="hljs-built_in">Box</span>::pin(<span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span>&#123;<br>        tokio::<span class="hljs-built_in">select!</span> &#123;<br>            v = response =&gt; &#123;<br>                Poll::Ready(v.map_err(<span class="hljs-built_in">Into</span>::into))<br>            &#125;<br>            _ = sleep =&gt; &#123;<br>                Poll::Ready(<span class="hljs-literal">Err</span>(Elapsed(()).into()))<br>            &#125;<br>        &#125;;<br>        Poll::Pending<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然 async 可以简化 Future 的编写，但也带来了额外的开销，真正 zero-cost 的众人就轮到了 <strong>手动实现 Future</strong> 手上</p><h3 id="2-2-手动实现-ResponseFuture"><a href="#2-2-手动实现-ResponseFuture" class="headerlink" title="2.2 手动实现 ResponseFuture"></a>2.2 手动实现 ResponseFuture</h3><p>在 LogFuture 的实现中也提到了 pin_project! 的必要性：因为我们在 ResponseFuture::poll 函数中只能获取到 Poll&lt;&amp;mut Self&gt;，但是我们真正想要做的是 poll 内部的 future，这就要求从 Pin&lt;&amp;mut Self&gt; 投影到 Pin&lt;&amp;mut T&gt;，同时也应当投影到 Pin&lt;&amp;mut Sleep&gt;，而 pin_proejct! 在内部也为我们保证安全性，可以放心大胆使用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust">pin_project! &#123;<br>    <span class="hljs-meta">#[derive(Debug)]</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ResponseFuture</span></span>&lt;T&gt; &#123;<br>        <span class="hljs-meta">#[pin]</span><br>        response: T,<br>        <span class="hljs-meta">#[pin]</span><br>        sleep: Sleep,<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; ResponseFuture&lt;T&gt; &#123;<br>    <span class="hljs-keyword">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(response: T, sleep: Sleep) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        ResponseFuture &#123; response, sleep &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为 ResponseFuture 实现的 Future trait 也非常简单，我们要做的仅仅是通过投影，分别获取到 Pin&lt;&amp;mut InnerService&gt; 和 Pin&lt;&amp;mut Sleep&gt;，参考 select!，轮流去查看这两个 Future 是否已经 Ready 即可，分为三种情况：</p><ol><li>response 为 Ready。返回该结果</li><li>response 为 Pending，sleep 也为 Pending。此时内部服务仍在调用过程中，且没有超时</li><li>response 为 Pending，sleep 已经返回 Ready。说明内部服务调用已经超时了，返回 Error</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;F, T, E&gt; Future <span class="hljs-keyword">for</span> ResponseFuture&lt;F&gt;<br><span class="hljs-keyword">where</span><br>    F: Future&lt;Output = <span class="hljs-built_in">Result</span>&lt;T, E&gt;&gt;,<br>    E: <span class="hljs-built_in">Into</span>&lt;crate::BoxError&gt;,<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = <span class="hljs-built_in">Result</span>&lt;T, crate::BoxError&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll</span></span>(<span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;<br>        <span class="hljs-keyword">let</span> this = <span class="hljs-keyword">self</span>.project();<br><br>        <span class="hljs-comment">// First, try polling the future</span><br>        <span class="hljs-keyword">match</span> this.response.poll(cx) &#123;<br>            Poll::Ready(v) =&gt; <span class="hljs-keyword">return</span> Poll::Ready(v.map_err(<span class="hljs-built_in">Into</span>::into)),<br>            Poll::Pending =&gt; &#123;&#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Now check the sleep</span><br>        <span class="hljs-keyword">match</span> this.sleep.poll(cx) &#123;<br>            Poll::Pending =&gt; Poll::Pending,<br>            Poll::Ready(_) =&gt; Poll::Ready(<span class="hljs-literal">Err</span>(Elapsed(()).into())),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后千万别忘记了给 Timeout 创建一个对应的 Layer，否则无法在 ServiceBuilder 中创建这个服务<br>TimeoutLayer 只需要<strong>透传</strong>给 Timeout 一个 timeout 参数即可，实现起来也非常容易。<br>至此，超时控制中间件圆满完成。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug, Clone)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TimeoutLayer</span></span> &#123;<br>    timeout: Duration,<br>&#125;<br><br><span class="hljs-keyword">impl</span> TimeoutLayer &#123;<br>    <span class="hljs-comment">/// Create a timeout from a duration</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(timeout: Duration) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        TimeoutLayer &#123; timeout &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;S&gt; Layer&lt;S&gt; <span class="hljs-keyword">for</span> TimeoutLayer &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Service</span></span> = Timeout&lt;S&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">layer</span></span>(&amp;<span class="hljs-keyword">self</span>, service: S) -&gt; Self::Service &#123;<br>        Timeout::new(service, <span class="hljs-keyword">self</span>.timeout)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>Timeout 中间件也遵循了中间件编写的几个准则:</p><ol><li>首先考虑中间件的功能，为 Timeout 添加对应的字段</li><li>考虑 Timeout::call 函数中应当返回什么样的 Future，是 high-level 的 <code>async &#123;..&#125;</code>，但是有额外的开销，还是 low-level 的手动实现 Future，麻烦但 zero-cost，需要进行权衡</li><li>最终通过 TimeoutLayer，为 Timeout 添加创建流程，相对来说是一个 boilerplate</li></ol>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
      <category>tower</category>
      
      <category>middlewares</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.4 tower-ext</title>
    <link href="/2022/01/10/rust/tower_internal/service-ext/"/>
    <url>/2022/01/10/rust/tower_internal/service-ext/</url>
    
    <content type="html"><![CDATA[<h2 id="1-ext-设计模式"><a href="#1-ext-设计模式" class="headerlink" title="1. ext 设计模式"></a>1. ext 设计模式</h2><p>xxx-ext 是 Rust 当中常用的一个设计模式，在满足某个 Trait 的前提下，引入很多的扩展功能（比如最常用的 Iterator，其实 <code>skip, enumerate, take</code> 都是针对 <code>Iterator trait</code> 的扩充）</p><p>Tower 也给 Service 引入了这个设计模式，十分好用。</p><p>源码如下，TL；DR</p><figure class="highlight rust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">ServiceExt</span></span>&lt;Request&gt;: tower_service::Service&lt;Request&gt; &#123;<br>    <span class="hljs-meta">#[deprecated(since = <span class="hljs-meta-string">&quot;0.3.1&quot;</span>, note = <span class="hljs-meta-string">&quot;prefer `ready_and` which yields the service&quot;</span>)]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">ready</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; Ready&lt;<span class="hljs-symbol">&#x27;_</span>, <span class="hljs-keyword">Self</span>, Request&gt;<br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>,<br>    &#123;<br>        <span class="hljs-meta">#[allow(deprecated)]</span><br>        Ready::new(<span class="hljs-keyword">self</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">ready_and</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; ReadyAnd&lt;<span class="hljs-symbol">&#x27;_</span>, <span class="hljs-keyword">Self</span>, Request&gt;<br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>,<br>    &#123;<br>        ReadyAnd::new(<span class="hljs-keyword">self</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">ready_oneshot</span></span>(<span class="hljs-keyword">self</span>) -&gt; ReadyOneshot&lt;<span class="hljs-keyword">Self</span>, Request&gt;<br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>,<br>    &#123;<br>        ReadyOneshot::new(<span class="hljs-keyword">self</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">oneshot</span></span>(<span class="hljs-keyword">self</span>, req: Request) -&gt; Oneshot&lt;<span class="hljs-keyword">Self</span>, Request&gt;<br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>,<br>    &#123;<br>        Oneshot::new(<span class="hljs-keyword">self</span>, req)<br>    &#125;<br><br>    <span class="hljs-meta">#[cfg(feature = <span class="hljs-meta-string">&quot;call-all&quot;</span>)]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call_all</span></span>&lt;S&gt;(<span class="hljs-keyword">self</span>, reqs: S) -&gt; CallAll&lt;<span class="hljs-keyword">Self</span>, S&gt;<br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>,<br>        Self::Error: <span class="hljs-built_in">Into</span>&lt;Error&gt;,<br>        S: futures_core::Stream&lt;Item = Request&gt;,<br>    &#123;<br>        CallAll::new(<span class="hljs-keyword">self</span>, reqs)<br>    &#125;<br>  <br>   ...<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span>, Request&gt; ServiceExt&lt;Request&gt; <span class="hljs-keyword">for</span> T <span class="hljs-keyword">where</span> T: tower_service::Service&lt;Request&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p><code>ServiceExt</code> 中的的几个函数，对于当前的 Service 做了不同的封装，下面会挑选几个进行细致的分析。</p><h2 id="2-ReadyOneShot-amp-Ready-实现"><a href="#2-ReadyOneShot-amp-Ready-实现" class="headerlink" title="2. ReadyOneShot &amp; Ready  实现"></a>2. ReadyOneShot &amp; Ready  实现</h2><p>ReadyOneshot 结构中，保存了一个 <code>Option&lt;Service&gt;</code>，并且在 poll 方法中通过 <code>ready!</code> 匹配 <code>poll_ready</code> 的结果</p><p>之所以称为 ReadyOneShot，是因为 ReadyOneShort::poll 方法返回 Ready 之前会将 Option 中的 Service  取出来，如果再次 poll 这个 ReadyOneShot 结构，肯定会发生 panic（符合预期）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// Oneshot</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ReadyOneshot</span></span>&lt;T, Request&gt; &#123;<br>    inner: <span class="hljs-built_in">Option</span>&lt;T&gt;,<br>    _p: PhantomData&lt;<span class="hljs-function"><span class="hljs-keyword">fn</span></span>() -&gt; Request&gt;,<br>&#125;<br><br><span class="hljs-comment">// Safety: This is safe because `Services`&#x27;s are always `Unpin`.</span><br><span class="hljs-keyword">impl</span>&lt;T, Request&gt; Unpin <span class="hljs-keyword">for</span> ReadyOneshot&lt;T, Request&gt; &#123;&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T, Request&gt; ReadyOneshot&lt;T, Request&gt;<br><span class="hljs-keyword">where</span><br>    T: Service&lt;Request&gt;,<br>&#123;<br>    <span class="hljs-meta">#[allow(missing_docs)]</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(service: T) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            inner: <span class="hljs-literal">Some</span>(service),<br>            _p: PhantomData,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T, Request&gt; Future <span class="hljs-keyword">for</span> ReadyOneshot&lt;T, Request&gt;<br><span class="hljs-keyword">where</span><br>    T: Service&lt;Request&gt;,<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = <span class="hljs-built_in">Result</span>&lt;T, T::Error&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll</span></span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;<br>        ready!(<span class="hljs-keyword">self</span><br>            .inner<br>            .as_mut()<br>            .expect(<span class="hljs-string">&quot;poll after Poll::Ready&quot;</span>)<br>            .poll_ready(cx))?;<br><br>        Poll::Ready(<span class="hljs-literal">Ok</span>(<span class="hljs-keyword">self</span>.inner.take().expect(<span class="hljs-string">&quot;poll after Poll::Ready&quot;</span>)))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Ready 是针对 ReadyOneshot 结构简单封装，主要是为了重复利用 Service，不需要拿到 Service 的所有权，只需 Service 的可变引用即可。Ready::poll 中所做的，也仅仅是 forward 内部 ReadyOneShot::poll 的结果。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// Core Api，Ready</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Ready</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T, Request&gt;(ReadyOneshot&lt;&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T, Request&gt;);<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T, Request&gt; Ready&lt;<span class="hljs-symbol">&#x27;a</span>, T, Request&gt;<br><span class="hljs-keyword">where</span><br>    T: Service&lt;Request&gt;,<br>&#123;<br>    <span class="hljs-meta">#[allow(missing_docs)]</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(service: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span>(ReadyOneshot::new(service))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T, Request&gt; Future <span class="hljs-keyword">for</span> Ready&lt;<span class="hljs-symbol">&#x27;a</span>, T, Request&gt;<br><span class="hljs-keyword">where</span><br>    T: Service&lt;Request&gt;,<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = <span class="hljs-built_in">Result</span>&lt;&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T, T::Error&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll</span></span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;<br>        Pin::new(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>).poll(cx)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你可能不禁要问了，ReadyOneShot 和 Ready 有什么好处吗？我真的需要它吗？</p><p>哎，别提，你还真离不开它！</p><p>由于 Service 将 poll_ready 函数单独抽离出来，导致我们在 call 之前，一定要先等待 poll_ready 返回，但手动去匹配 <code>Poll::Ready</code> 和 <code>Poll::Pending</code> 是一件很枯燥，但又不得不去做的事情。</p><p>得益于这套扩展，我们可以非常轻松地在代码中写出下面的链式调用 <code>service.ready().await.unwrap().call(req).await</code>，省去了大段的 <strong>boilerplate</strong></p><h2 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h2><p>再来看一下其它的拓展功能，其实在实际中用的不算太多了，但也是很有意思的功能。</p><p>比如 <code>call_all</code> 函数，会接收一个 Stream of Request，返回一个 Stream of Respone，相当于 JavaScript 里面的 <code>Promise.all</code></p><p>而 and_then 描述的 service 执行依赖关系，相当于 JavaScript 里面的 <code>Promise.resolve</code>，这个名字听上去就很 Rusty，还有更多的组合式的扩展机制，比如 map_response, map_err, map_result，这里就不一一列举了。</p>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
      <category>tower</category>
      
      <category>basic</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.1 tower 核心抽象</title>
    <link href="/2022/01/10/rust/tower_internal/tower-core/"/>
    <url>/2022/01/10/rust/tower_internal/tower-core/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Tower-的起源"><a href="#1-Tower-的起源" class="headerlink" title="1. Tower 的起源"></a>1. Tower 的起源</h2><p>说起 Tower，就不得不提到 Rust 另一个重要的框架，Tokio，这两个单词连起来读，就是 Tokyo Tower（东京塔），这也从另一个方面说明，Tower 是 Tokio 官方支持的中间件框架，Axum ，Tower-web，Tonic 这些项目，都广泛使用了 Tower 这层抽象。</p><p>那么，我们不禁要问，Tower 到底是什么？官方给出的答案是：<strong>Tower 是一个模块化，可重用的中间件框架</strong></p><p>所谓的中间件，之后会详细解释，在这里，可以简单将其理解为从用户到核心服务之间的中间层。有句话说得好，计算机任何问题都可以通过添加一个间接的中间层来解决，这里也是如此。中间件可以带来很多好处，比如数据管理、应用服务、消息传递、身份验证、日志，但是作为一个<strong>框架</strong>，Tower 的核心任务是<strong>如何定义一个良好的抽象，让上层开发人员能够方便地编写高质量中间件</strong>！</p><p>所以，我们首先要来了解一下 Tower 的几个核心抽象。</p><h2 id="2-Service"><a href="#2-Service" class="headerlink" title="2. Service"></a>2. Service</h2><p>对于一个应用来说，可以简单将其概括为 <strong>请求 + 相应</strong>，类似于 <code>Ping-Pong</code> 模型，而网络又为应用赋予了异步属性，结合 Rust 的 Future 抽象，我们不难得出下面这种抽象：</p><p><code>async fn handler(req:Request) -&gt; Response &#123;..&#125;</code></p><p>为了更好地描述这种<strong>服务</strong>，更加自然的方式是将其定义为 trait，不妨称这个 trait 为 Service，而和这个 Service 想关联的下面几个类型：</p><ol><li>Request</li><li>Response</li><li>Error</li><li>Future</li></ol><p>因而 <code>Service trait</code> 有如下的结构</p><figure class="highlight rust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Service</span></span>&lt;Request&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Response</span></span>;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span>;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Future</span></span>: Future;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll_ready</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; Poll&lt;<span class="hljs-built_in">Result</span>&lt;(), Self::Error&gt;&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, req: Request) -&gt; Self::Future;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心函数自然是 call，用来返回一个 Future，提供给 Runtime 执行。</p><p>但是这里还涉及到了 poll_ready 函数，用来表示服务是否可用，这一点在<strong>限制流量或者并发度</strong>的时候非常好用，如果服务本身不关心是否可用，就可以直接返回 Poll::Ready，开销很小，但是极大地提高了 Service 的灵活度。</p><h2 id="3-组合"><a href="#3-组合" class="headerlink" title="3. 组合"></a>3. 组合</h2><h3 id="3-1-还缺少什么"><a href="#3-1-还缺少什么" class="headerlink" title="3.1 还缺少什么"></a>3.1 还缺少什么</h3><p> 通过 <code>Service</code> 这个抽象，已经可以很好地描述一个小功能了，比如 EchoService（相信不必我多解释了），但始终不要忘记，我们是一个中间件框架，还需要将中间件组合在一起才行，这样才能提供更加强大的拓展能力。</p><p>事实上，对于中间件而言，我们可以沿用 <code>Service</code> 这种抽象，理由是：即使是添加了 n 个中间件，我们描述的<strong>仍然是</strong>一个异步的请求-相应服务，只不过我们想要在中间的某些环节上加以拓展，更加专业的说法是，添加 hook 逻辑，比如在调用核心服务之前和之后输出日志就是一个很基本的需求。</p><p>仔细思索，这不就是装饰器（Decorator）模式？接收一个函数，返回一个新的函数。只不过将普通的函数装饰转换成了对 <code>Service trait</code> 的装饰。</p><p>接下来的核心问题是，应该如何<strong>一层层</strong>把最核心的服务包装起来？</p><p>针对这个问题，其实有很多实现方式，node 的 koa，golang 的 gin 都有很好的实现方式，我们不妨先看一下 Tower 里面的使用方式再做评判。</p><h3 id="3-2-Tower-Layer"><a href="#3-2-Tower-Layer" class="headerlink" title="3.2 Tower Layer"></a>3.2 Tower Layer</h3><p>Tower 使用 Layer 这个 trait 来粘合 Service。</p><p>上面我们提到，中间件实际上就是对内层服务的包装，那么，肯定要先有内层的 Service，才谈得上进一步包装。因此，Tower 抽象出了 <code>Layer trait</code>，用来表示：接收内层的 Service 类型，返回一个包装之后的 Service。</p><p>因而 <code>Service trait</code> 有如下的结构，通过 layer 函数来描述这件事，包装之后的 Service 是什么类型，已经定义在关联类型中了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Layer</span></span>&lt;S&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Service</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">layer</span></span>(&amp;<span class="hljs-keyword">self</span>, inner: S) -&gt; Self::Service;<br>&#125;<br></code></pre></td></tr></table></figure><p>用上面的 Layer trait，来实现一个 Constant 的粘合层，所谓 Constant，意味着接收一个 Service，原封不动返回这个 Service。显然，返回的 Service 类型和 inner Service 相同，因此，在关联类型中，直接声明 <code>type Service = S;</code> 就好了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Constant</span></span>;<br><br><span class="hljs-keyword">impl</span>&lt;S&gt; Layer&lt;S&gt; <span class="hljs-keyword">for</span> Constant&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Service</span></span> = S;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">layer</span></span>(&amp;<span class="hljs-keyword">self</span>, inner: S) -&gt; Self::Service &#123;<br>        inner<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-3-换个方式理解-Layer"><a href="#3-3-换个方式理解-Layer" class="headerlink" title="3.3 换个方式理解 Layer"></a>3.3 换个方式理解 Layer</h3><p>Layer 这个东西很神奇，它只是规定了如何去做，具体生效，还需要传入一个目标 Service 才行。</p><p>可以换一个方式理解，Layer 相当于<strong>骨架</strong>，是一副干巴巴的躯壳，本身不具有对外服务的能力，只有当我们传入一个核心的函数，才会<strong>注入血肉</strong>，得到一个中间件加持的究极无敌 Service。（或者理解为 Java 的 Factory 和 Bean 的关系）</p><p>同时可以非常方便地引入 Builder 建造者模式，通过 ServiceBuilder，我们将 Layer <strong>按顺序</strong>叠加，最终传入<strong>血肉</strong>，也就是核心的 service</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> wrapped_svc= ServiceBuilder::new()<br>                  .buffer(<span class="hljs-number">100</span>)<br>                  .concurrency_limit(<span class="hljs-number">10</span>)<br>                  .layer(l4)<br>                  .layer(l5)<br>                  .service(svc);<br></code></pre></td></tr></table></figure><p>通过 ServiceBuilder 操作，我们就完成了对于 svc 的中间件包装，之后的使用就很简单了：</p><ol><li>poll_ready 等待服务准备好</li><li>传入 request，调用 <code>wrapped_svc.call(request)</code> 来获取一个 Future</li><li>将该 Future 交给 Tokio 处理</li><li>循环 1-3</li></ol><h2 id="4-Tower-和应用程序"><a href="#4-Tower-和应用程序" class="headerlink" title="4. Tower 和应用程序"></a>4. Tower 和应用程序</h2><p>已经解释完了 Tower 的两个核心 trait：Service 和 Layer，之后的章节中，会详细介绍各个关键中间件的使用方式，以及如何利用 Tower 的抽象，来搭建一个应用。</p><p>不知道大家注意到没有，Tower 自始至终，都在描述 <code>async fn handler(req)-&gt;resp</code> 这件事，但是没有提到 req 是怎么来的，相信聪明的你已经想到了，Tokio，或者更加准确的说，还需要一个连接器。</p><p>在实际应用中，需要在建立连接之后，才能获取到 request 内容，才能启动整个中间件链条，完成 <code>Ping-Pong</code> 的任务。大致逻辑长下面这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> wrapped_svc= ServiceBuilder::new()<br>                  .buffer(<span class="hljs-number">100</span>)<br>                  .concurrency_limit(<span class="hljs-number">10</span>)<br>                  .layer(l4)<br>                  .layer(l5)<br>                  .service(svc);<br><br><span class="hljs-keyword">loop</span>&#123;<br>  <br>  <span class="hljs-keyword">let</span> req = make_connection();<br>  <span class="hljs-keyword">let</span> s = wrapped_svc.clone();<br>  <br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   todo!(handle connection,get the request)</span><br><span class="hljs-comment">  */</span><br>  <br>  tokio::spawn(<span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123;<br>     <span class="hljs-comment">// s has been moved into this closure</span><br>      <span class="hljs-keyword">let</span> f = s.ready().<span class="hljs-keyword">await</span>.call(req);<br>   f.<span class="hljs-keyword">await</span>;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
      <category>tower</category>
      
      <category>basic</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3.1 tower 不足之处</title>
    <link href="/2022/01/10/rust/tower_internal/tower-issues/"/>
    <url>/2022/01/10/rust/tower_internal/tower-issues/</url>
    
    <content type="html"><![CDATA[<p>这一部分，主要是探讨 Tower 中的一些不足之处，主要参考我实习期间使用 Tower 之后的一些体验以及和同事的讨论。</p><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><h3 id="1-1-call是否应该使用-Pin-lt-amp-mut-Self-gt-？"><a href="#1-1-call是否应该使用-Pin-lt-amp-mut-Self-gt-？" class="headerlink" title="1.1 call是否应该使用 Pin&lt;&amp;mut Self&gt; ？"></a>1.1 <code>call</code>是否应该使用 <code>Pin&lt;&amp;mut Self&gt;</code> ？</h3><p>关于这个问题，已经有了一些<a href="https://github.com/tower-rs/tower/issues/319">github 讨论</a>。但是到目前为止，Tower 官方还是决定采用一个普通的 <code>&amp;mut self</code>，这意味着 Service 必须是<code>Unpin</code>。</p><p>这个问题的出发点在于，如果在 Service 内部保存一个 Future，并且在 poll_ready 中使用，这就会和 call 函数的签名有一定的冲突，因为 <code>Service::poll_ready</code> 接收一个 <code>&amp;mut self</code> ，而非 <code>Pin&lt;&amp;mut Self&gt;</code>。</p><p>为了在 <code>poll_ready</code> 中保证安全，必须防止在 <code>poll_ready</code> 中调用  <code>Pin::new_unchecked</code>（因为我们无法承诺不移动这个 service），而 <code>Pin::new()</code> 要求 future 实现 Unpin 的，对于 async/await 生成的自引用 Future 来说，只有用将其分配在堆上，才能确保 Pin，因此带来了额外的开销。该讨论旨在用一个更好的方式来加以约束。</p><h3 id="1-2-GAT-（generic-associate-type）支持"><a href="#1-2-GAT-（generic-associate-type）支持" class="headerlink" title="1.2 GAT （generic associate type）支持"></a>1.2 GAT （generic associate type）支持</h3><p>GAT，正如其名字所言，允许在 trait 的关联类型上定义泛型参数，声明周期参数。这个功能很有用，尤其是当你熟悉如今的妥协方式时。</p><p>在 Tower 定义的 <code>Service trait</code> 中，要求响应返回的 Future 必须是<code>&#39;static&#39;</code>的，因为目前不支持 GAT 功能，也就无法将 <code>Self::Future</code>  和 <code>call</code> 的声明周期关联起来，因此会强制要求返回的 Future 具有 <code>&#39;static&#39;</code>  生命周期。 因为写 <code>Box&lt;dyn Future&gt;</code> 实际上会被 desugar 成<code>Box&lt;dyn Future + &#39;static&gt;</code>，因此在<code>fn call(&amp;&#39;_ mut self, ...)</code>中的匿名  <code>lifetime</code> 并不满足这个要求。在未来，Rust 编译器团队计划增加一个名为泛型关联类型（GAT）的功能，这将解决这个问题。泛型关联类型允许我们将响应的 future 定义为 <code>type Future&lt;&#39;a&gt;</code>，<code>call</code>定义为<code>fn call&lt;&#39;a&gt;(&amp;&#39;a mut self, ...) -&gt; Self::Future&lt;&#39;a&gt;</code>，但现在响应返回的 Future 必须是<code>&#39;static</code>的。</p><h3 id="1-3-filter-or-middleware-模式"><a href="#1-3-filter-or-middleware-模式" class="headerlink" title="1.3  filter or middleware 模式"></a>1.3  filter or middleware 模式</h3><p>Tower 目前采用的 middleware 模式，<strong>严重依赖于类型推导</strong>，使得<strong>运行期增加或删除中间件</strong>非常困难，因为通过 <code>ServiceBuilder</code> 叠加 layer 之后，其泛型参数已经固定了。</p><p>你可能会好奇，运行期去增加删除中间件有什么作用？事实上，在有些场景下，还是很有必要的。</p><p>比如使用中间件实现 proxy 组件的时候，如果要进行动态更新，就依赖于运行期的增删能力，而 Tower 目前根本无法实现。有解决办法吗？有，只不过有一定的代价，也就是前文中说过的，用<code>Vec&lt;Box&lt;dyn Service&gt;&gt;</code> 或者 <code>LinkedList&lt;Box&lt;dyn Service&gt;&gt;</code> 来保存中间件 ，通过牺牲一定的性能代价，换来更多的灵活性，并且省去了很多泛型的烦恼。</p><p>同时，我们也考虑，在某些场景下，是否可以使用更加简洁的 Filter 模式去拓展功能，而不是大而全的 Middleware 模式</p><h3 id="1-4-类型系统"><a href="#1-4-类型系统" class="headerlink" title="1.4 类型系统"></a>1.4 类型系统</h3><p>上面也提到了，Tower 目前类型推导非常复杂，一个小小的错误，都会导致很多类型错误。在写中间件的时候会非常痛苦，Tower 里面的类型，几乎都是自动推导出来的，几乎无法手写，也就很难在 tls 中保存下来，导致有一些比较 hack 的操作无法实现。</p><h3 id="1-5-poll-ready-和-call"><a href="#1-5-poll-ready-和-call" class="headerlink" title="1.5 poll_ready 和 call"></a>1.5 poll_ready 和 call</h3><p>就目前的 Rust stable 生态而言，Tower 这一套已经是比较好的解决方式了。但是，poll_ready 和 call 分离这一点，着实带来了不少的苦恼。</p><p>目前要求 poll_ready 和 call 必须要同步调用（poll_ready 和 call 两个函数中都接收 <code>&amp;mut self</code>，根据 Rust 的所有权机制，必须串行调用）</p><p>事实上这套接口也是有其合理性的，想不到更好的解决方式了。</p><h3 id="1-6-生态"><a href="#1-6-生态" class="headerlink" title="1.6 生态"></a>1.6 生态</h3><p>目前 hyper 这个 http 公认的第三方标准，强依赖了 Tower 这一套逻辑，如果想要重新定义 <code>Service trait</code>，就需要花费很大的精力去兼容这种接口，而且几乎没有生态支持…</p>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
      <category>tower</category>
      
      <category>more</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.2 tower service 设计心路历程</title>
    <link href="/2022/01/10/rust/tower_internal/tower-service/"/>
    <url>/2022/01/10/rust/tower_internal/tower-service/</url>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/dRz0qJJtUAt6mJ_z2knoXw">Tower Service 设计思路 -by tokio</a></p>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
      <category>tower</category>
      
      <category>basic</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ftrace</title>
    <link href="/2022/01/09/linux/tracing/ftrace/"/>
    <url>/2022/01/09/linux/tracing/ftrace/</url>
    
    <content type="html"><![CDATA[<p>先说一个非常重要的参考资料，也就是 ftrace 作者本人的 pdf：<a href="https://blog.linuxplumbersconf.org/2014/ocw/system/presentations/1773/original/ftrace-kernel-hooks-2014.pdf">ftrace kernel hook</a></p><p>接下来，主要跟着作者的思路，融入自己的一些思考，给大家解读一下 ftrace 究竟做了什么？</p><h2 id="1-什么是-ftrace"><a href="#1-什么是-ftrace" class="headerlink" title="1. 什么是 ftrace"></a>1. 什么是 ftrace</h2><p>ftrace，顾名思义，就是 <code>function trace</code>，针对函数级别的追踪调试机制。</p><p>我们平时是如何使用这个强大功能的呢？</p><h3 id="1-1-如何使用-ftrace"><a href="#1-1-如何使用-ftrace" class="headerlink" title="1.1 如何使用 ftrace"></a>1.1 如何使用 ftrace</h3><p>可以通过 tracefs <strong>和内核进行交互</strong>，比如向 current_tracer 文件中写入 <code>function</code>，内核就会追踪所有的函数调用</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /sys/kernel/debug/tracing<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-keyword">function</span> &gt; current_tracer<br>$ cat trace<br><span class="hljs-comment"># tracer: function</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># entries-in-buffer/entries-written: 205022/119956607 #P:4</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># _-----=&gt; irqs-off</span><br><span class="hljs-comment"># / _----=&gt; need-resched</span><br><span class="hljs-comment"># | / _---=&gt; hardirq/softirq</span><br><span class="hljs-comment"># || / _--=&gt; preempt-depth</span><br><span class="hljs-comment"># ||| / delay</span><br><span class="hljs-comment"># TASK-PID CPU# |||| TIMESTAMP FUNCTION</span><br><span class="hljs-comment"># | | | |||| | |</span><br> &lt;idle&gt;-0 [002] dN.1 1781.978299: rcu_eqs_exit &lt;-rcu_idle_exit<br> &lt;idle&gt;-0 [002] dN.1 1781.978300: rcu_eqs_exit_common &lt;-rcu_eqs_exit<br> &lt;idle&gt;-0 [002] .N.1 1781.978301: arch_cpu_idle_exit &lt;-cpu_startup_entry<br> &lt;idle&gt;-0 [002] .N.1 1781.978301: tick_nohz_idle_exit &lt;-cpu_startup_entry<br> &lt;idle&gt;-0 [002] dN.1 1781.978301: ktime_get &lt;-tick_nohz_idle_exit<br> &lt;idle&gt;-0 [002] dN.1 1781.978302: update_ts_time_stats &lt;-tick_nohz_idle_exit<br> &lt;idle&gt;-0 [002] dN.1 1781.978302: nr_iowait_cpu &lt;-update_ts_time_stats<br> &lt;idle&gt;-0 [002] dN.1 1781.978303: tick_do_update_jiffies64 &lt;-tick_nohz_idle_exit<br> &lt;idle&gt;-0 [002] dN.1 1781.978303: update_cpu_load_nohz &lt;-tick_nohz_idle_exit<br> &lt;idle&gt;-0 [002] dN.1 1781.978303: calc_load_exit_idle &lt;-tick_nohz_idle_exit <br></code></pre></td></tr></table></figure><p>向 current_tracer 文件中写入 <code>function_graph</code>，内核就会追踪所有的函数调用，并且将其调用链，函数执行时间都展示出来（这个功能在阅读内核代码的时候极其好用）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /sys/kernel/debug/tracing<br>$ <span class="hljs-built_in">echo</span> function_graph &gt; current_tracer<br>$ cat trace<br><span class="hljs-comment"># tracer: function_graph</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># CPU  DURATION                  FUNCTION CALLS</span><br><span class="hljs-comment"># |     |   |                     |   |   |   |</span><br> 2)   0.666 us    |                        load_new_mm_cr3();<br> 2)   0.170 us    |                        switch_ldt();<br> 2)   1.500 us    |                      &#125; /* switch_mm_irqs_off */<br> 2)               |                      <span class="hljs-function"><span class="hljs-title">switch_mm_irqs_off</span></span>() &#123;<br> 2)   0.273 us    |                        load_new_mm_cr3();<br> 2)   0.157 us    |                        switch_ldt();<br> 2)   1.071 us    |                      &#125;<br> 2)   0.166 us    |                      flush_tlb_mm_range();<br> 2)   0.152 us    |                      _raw_spin_unlock();<br> 2)   4.541 us    |                    &#125; /* __text_poke */<br> 2)               |                    <span class="hljs-function"><span class="hljs-title">__text_poke</span></span>() &#123;<br> 2)               |                      <span class="hljs-function"><span class="hljs-title">__get_locked_pte</span></span>() &#123;<br> 2)   0.155 us    |                        _raw_spin_lock();<br> 2)   0.471 us    |                      &#125;<br> 2)               |                      <span class="hljs-function"><span class="hljs-title">switch_mm_irqs_off</span></span>() &#123;<br> 2)   0.380 us    |                        load_new_mm_cr3();<br> 2)   0.169 us    |                        switch_ldt();<br> 2)   1.155 us    |                      &#125;<br> 2)               |                      <span class="hljs-function"><span class="hljs-title">switch_mm_irqs_off</span></span>() &#123;<br> 2)   0.277 us    |                        load_new_mm_cr3();<br></code></pre></td></tr></table></figure><p>如果通过 <code>echo &#39;*schedule*&#39; &gt; set_ftrace_filter</code>  来设置过滤器，就会发现， <code>cat trace</code> 得到的结果中，果真就是我们想要留下来的满足 <code>*schedule*</code> 这个命名规则的函数。</p><p>那么问题来了，ftrace 究竟是如何生效的？我们真的可以为所欲为吗？我们来深入探究一下。</p><h2 id="2-ftrace-如何工作？"><a href="#2-ftrace-如何工作？" class="headerlink" title="2. ftrace 如何工作？"></a>2. ftrace 如何工作？</h2><p>ftrace 的目标是追踪每一个函数，肯定需要 hook 目标函数，并且执行我们自己的逻辑。思路很简单，在每个函数的入口，添加一个 trampoline。</p><p>（trampoline 可以翻译为跳板，意思是，这段代码并不直接起作用，只是起到了一个间接跳转的作用）</p><p>有了这个 trampoline，我们就可以通过修改 trampoline 中的指令，来跳转到 hook 代码中执行（内核代码也是需要载入内存的，理论上我们可以通过修改这段这块内存，完成各种各样的事情），那么问题来了：添加什么样的 trampoline，又如何添加呢？</p><p>这里要感谢编译器提供的一个功能： mcount，即：可以在每个函数执行开始前插入一个叫 <code>mcount</code> 的函数。</p><h3 id="2-1-编译器的超能力"><a href="#2-1-编译器的超能力" class="headerlink" title="2.1 编译器的超能力"></a>2.1 编译器的超能力</h3><h4 id="2-1-1-用户程序验证"><a href="#2-1-1-用户程序验证" class="headerlink" title="2.1.1 用户程序验证"></a>2.1.1 用户程序验证</h4><p>可以通过下面这段程序来验证 mcount 的功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// mcount.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">mcount</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;        <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mcount!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// main.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mcount</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b:%d\n&quot;</span>, i);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>        b(i);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">int</span> k = a(i);<br>        <span class="hljs-keyword">return</span> k;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先通过下面三条命令编译 mcount 和主程序</p><ol><li><p><code>gcc -c main.c -pg</code></p></li><li><p><code>gcc -c mcount.c</code></p></li><li><p><code>gcc mcount.o main.o -o main</code></p></li></ol><p>然后执行 <code>./main</code> 执行程序，就会发现，每一个函数调用都会输出  <code>mcount!</code>，Beego！</p><p>那么这段程序是如何起作用的呢？注意到，在编译 <code>main.c</code> 的时候，我们加上了一个特殊的编译参数 <code>-pg</code>，这就是告诉编译器：请在函数首部加上 <code>mcount</code> 的调用，接下只需要在链接程序的过程中，提供 <code>mcount</code> 这个函数就好了。</p><p>当然，如果不提供 mcount 的实现，也也不会有什么问题，gcc 提供了一个 <code>void __weak mcount()&#123;return;&#125;</code> 作为默认的实现，只有用户没有提供强 mcount 符号的时候才会使用</p><h4 id="2-1-2-内核程序验证"><a href="#2-1-2-内核程序验证" class="headerlink" title="2.1.2 内核程序验证"></a>2.1.2 内核程序验证</h4><p>内核当中也是这么玩的吗？答案是 YES！</p><p>要验证这一点也很容易，只需要通过 gdb 反汇编内核中的函数，就会发现，在这些函数的开头，都插入了一条 <code>call __fentry__</code> 指令！（PS：暂时不管 <code>__fentry__</code> 和 mcount 的区别，后续会解释）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>$ gdb -batch -ex <span class="hljs-string">&#x27;file vmlinux&#x27;</span> -ex <span class="hljs-string">&#x27;disassemble schedule&#x27;</span>  // disassemble 别的函数也是这种结果<br><br>Dump of assembler code <span class="hljs-keyword">for</span> <span class="hljs-keyword">function</span> schedule:<br>   0xffffffff81829730 &lt;+0&gt;:     callq  0xffffffff81062c80 &lt;__fentry__&gt;<br>   0xffffffff81829735 &lt;+5&gt;:     push   %rbx<br>   0xffffffff81829736 &lt;+6&gt;:     mov    %gs:0x17bc0,%rbx<br>   0xffffffff8182973f &lt;+15&gt;:    mov    0x18(%rbx),%eax<br>   0xffffffff81829742 &lt;+18&gt;:    <span class="hljs-built_in">test</span>   %eax,%eax<br>   ......<br>End of assembler dump.<br></code></pre></td></tr></table></figure><p>也就是说，在调用 schedule 函数的核心内容之前，都会调用 <code>__fentry__</code> 函数，和 <code>mcount</code> 一样，也是一个简单的 <code>retq</code> 指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/x86/kernel/ftrace_64.S</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_DYNAMIC_FTRACE</span><br><br>SYM_FUNC_START(__fentry__)<br> <span class="hljs-function">retq</span><br><span class="hljs-function"><span class="hljs-title">SYM_FUNC_END</span><span class="hljs-params">(__fentry__)</span></span><br><span class="hljs-function"><span class="hljs-title">EXPORT_SYMBOL</span><span class="hljs-params">(__fentry__)</span></span><br></code></pre></td></tr></table></figure><p>可以看到，该函数没有什么特别之处，直接 <code>retq</code> 返回。但正因为有了这个额外的 trampoline，让我们能完成很多相当 hack 的事情。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">Tips:<br>  如何让编译器加上这个 __fentry__ 的函数调用呢？这其实是因为 gcc 支持一个特殊的选项 `-pg -mfentry`<br>  查看内核的 MakeFile，就会看到其编译的时候正是用到了这几个参数，这样就会在每一个函数开头插入对于 __fentry__ 的额外调用:<br>  <br>    $ cat Makefile| rg fentry            // 查看源码中的 MakeFile<br>      ifeq ($(call cc-option-yn, -mfentry),y)<br>        CC_FLAGS_FTRACE     += -mfentry<br><br></code></pre></td></tr></table></figure><h4 id="2-1-3-fentry-VS-mcount"><a href="#2-1-3-fentry-VS-mcount" class="headerlink" title="2.1.3 fentry VS mcount"></a>2.1.3 fentry VS mcount</h4><p>这里来解答刚刚卖下的一个关子，编译器到底用的是 <code>mcount</code> 还是 <code>__fentry__</code> ？</p><p>早些年间，ftrace 确实依赖的 gcc mcount 这个特性，就连处理 mcount 的脚本都称作 <code>readmcount.pl</code>，但是，后来 gcc 将 mcount 改进为了 <code>__fentry__</code></p><p>这两者本质上都是跳板代码，没有特殊的意义（相信你也不会闲到在每一个 mcount 函数中输出 “hello world”），它们的区别在于，mcount 是建立栈帧（stack frame）之后才调用的，这样调用 trampoline 的时候，可能就需要保存一些寄存器，而 fentry 不需要。可以通过 <code>gcc -pg test.c</code> 和 <code>gcc -pg -mfentry test.c</code> 之后，<code>objdump -d a.out</code> 进行查看，显然，fentry 更优</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// test.c</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">0000000000001208 &lt;main&gt;:<br>    1208:       55                      push   %rbp<br>    1209:       48 89 e5                mov    %rsp,%rbp<br>    120c:       48 83 ec 10             sub    $0x10,%rsp<br>    1210:       ff 15 d2 2d 00 00       call   *0x2dd2(%rip)        # 3fe8 &lt;mcount@GLIBC_2.2.5&gt;<br>    ......<br><br>0000000000001208 &lt;main&gt;:<br>    1208:       ff 15 ea 2d 00 00       call   *0x2dea(%rip)        # 3ff8 &lt;__fentry__@GLIBC_2.13&gt;<br>    120e:       55                      push   %rbp<br>    120f:       48 89 e5                mov    %rsp,%rbp<br>    1212:       48 83 ec 10             sub    $0x10,%rsp<br>    .....<br></code></pre></td></tr></table></figure><h3 id="2-2-overhead"><a href="#2-2-overhead" class="headerlink" title="2.2 overhead"></a>2.2 overhead</h3><h4 id="2-2-1-dynamic-vs-static"><a href="#2-2-1-dynamic-vs-static" class="headerlink" title="2.2.1 dynamic vs static"></a>2.2.1 dynamic vs static</h4><p>始终铭记一点：<strong>计算机世界没有银弹！</strong></p><p>如果内核每一个函数开头都加上 <code>call __fentry__</code> 这个额外的操作，这个开销累积起来是相当可观的。据统计显示，仅仅在 <code>__fentry__</code> 中使用 retq（没有任何多余的操作），就会增加 13% 的开销（因为几乎每一个函数都有这条指令），显然无法接受！</p><p>因此内核开发者想要某种方式，以近乎零成本的方式来完成这件事。怎么做呢？nop 指令！</p><p>只需要想办法将所有的 <code>call __fentry__</code> 转换成 <code>nop</code> 指令，就几乎没有额外的开销，同时，在每一个函数开头也预留了 5个字节的<strong>腾挪空间</strong>，可以将其替换为任意的函数调用指令，理论上就可以完成很多神奇的事情。</p><p>并且始终要记住，程序运行在内存中，而内存是可以修改的，更何况内核对于程序的运行情况了如指掌，因此，我们只需要想办法确定所有函数开头的地址即可。显然在编译期间完成这项任务要轻松地多，compiler knows everything!</p><p>通过 scripts/recordmcount.c 这个文件 （fentry 仍然沿用了mcount 的一些命名，比如下面的），可以完成下面几件事：</p><ol><li>读取所有的二进制 object 文件</li><li>读取所有的 relocation table，并且：<ul><li>找出所有函数中的 <code>call __fentry__</code> 指令的地址，保存到一个数组中</li><li>将这个数组添加到原先的 object 文件中，保存在一个叫做 <code>__mcount_loc</code> 的新 section 中</li><li>通过 linker，将 <code>__mcount_loc</code> section 的内容都放在一起，开始和结束的位置分别命名为  <code>__start_mcount_loc</code> <code>__end_mcount_loc</code></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs linker">// include/asm-generic/vmlinux.lds.h<br>#define MCOUNT_REC()    . = ALIGN(8);                \<br>            __start_mcount_loc = .;            \<br>            KEEP(*(__mcount_loc))            \<br>            KEEP(*(__patchable_function_entries))    \<br>            __stop_mcount_loc = .;            \<br>            ftrace_stub_graph = ftrace_stub;<br></code></pre></td></tr></table></figure><p>这样，在 C语言源码中，就能通过 <code>extern unsigned long __start_mcount_loc[];</code> <code>extern unsigned long __stop_mcount_loc[];</code> 得到所有调用 <code>call __fentry__</code> 指令的地址</p><p>接下来只需要遍历这个 fentry 数组，将所有对应位置修改为 nop 即可。同时，<code>__mcount_loc</code> 已经光荣地完成了它的使命，不需要出现在最终编译得到的 vmlinux 中了。</p><p>这种在启动时候动态替换所有指令的方式，称为 dynamic ftrace，而原先那种带来很多 overhead 的方式，就成为 static tracing。</p><p>内核当中通过 <code>CONFIG_DYNAMIC_FTRACE</code> 来控制是否开启动态 ftrace，除了一些和动态追踪的字段需要通过这个编译选项开启，主要是作用于编译期间的一个 FLAG</p><p>只有打开了 <code>CONFIG_DYNAMIC_FTRACE</code>，才会开启 <code>BUILD_C_RECORDMCOUNT</code>，才在编译过程中执行 <code>recordmcount</code> ，才会让这些二进制黑魔法得以发挥，否则，啥都不干就只能是 static tracing 了。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-keyword">ifdef</span> CONFIG_DYNAMIC_FTRACE<br>        <span class="hljs-keyword">ifdef</span> CONFIG_HAVE_C_RECORDMCOUNT<br>                BUILD_C_RECORDMCOUNT := y<br>                <span class="hljs-keyword">export</span> BUILD_C_RECORDMCOUNT<br>        <span class="hljs-keyword">endif</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># scripts/Makefile</span><br>hostprogs-always-<span class="hljs-variable">$(BUILD_C_RECORDMCOUNT)</span>                += recordmcount<br></code></pre></td></tr></table></figure><h3 id="2-3-stateful-vs-stateless"><a href="#2-3-stateful-vs-stateless" class="headerlink" title="2.3 stateful vs stateless"></a>2.3 stateful vs stateless</h3><p>刚才已经解决了<strong>每个函数开头都要调用 <strong>fentry</strong></strong> 带来的 overhead，但还不够，因为当我们 trace kernel functions 的时候，是<strong>有状态</strong>的！该函数 fentry 是否启用，挂载了多少 trace 回调函数，这些都需要记录下来。因此，Linux 中，对于每一个 <code>call __fentry__</code> 的地址，都添加了 flags 来标记状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dyn_ftrace</span> &#123;</span><br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>           ip; <span class="hljs-comment">/* address of mcount call-site */</span><br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>           flags;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dyn_arch_ftrace</span>  <span class="hljs-title">arch</span>;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dyn_arch_ftrace</span> &#123;</span><br>        <span class="hljs-comment">/* No extra data needed for x86 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-ftrace-框架"><a href="#3-ftrace-框架" class="headerlink" title="3. ftrace 框架"></a>3. ftrace 框架</h2><p>接下来把目光投向 ftrace 这个框架的启动过程，以及具体的运作。</p><h3 id="3-1-ftrace-启动"><a href="#3-1-ftrace-启动" class="headerlink" title="3.1 ftrace 启动"></a>3.1 ftrace 启动</h3><p>前面说到，现在已经可以通过 <code>__start_mcount_loc</code> <code>__stop_mcount_loc</code> 两个符号获得所有的 <code>call __fentry__</code> 指令的地址数组，启动的时候，应该如何将这些指令替换为 nop 呢？</p><p>众所周知，在程序运行之后，修改其指令是一件非常危险的事情，因为指令对应的 icache 默认是只读的，所以 CPU 不太会理会你修改之后的内存，仍然会使用位于缓存中预取指令，同时，由于 x86 的指令长度非常不一致，导致一条指令可能跨越缓存行/内存页，在 SMP 系统中，更需要精确控制，才不会产生不一致行为（导致 CPU 执行出错，reboot）</p><p>Linux 也为修改 text 提供了很多实用的 API，比如这里用到的 <code>text_poke_early</code>，就在 memcpy 之后通过 sync_core 进行同步，正如其文档所说，强制 icache 更新到当前修改过后的指令（通过 inter-process interrupt）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">* This function forces the icache and prefetched instruction stream to<br>* catch up with reality in two very specific cases:<br>*<br>*  a) Text was modified using one virtual address and is about to be executed<br>*     from the same physical page at a different virtual address.<br>*<br>*  b) Text was modified on a different CPU, may subsequently be<br>*     executed on this CPU, and you want to make sure the new version<br>*     gets executed.  This generally means you&#x27;re calling this in an IPI.<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> __init_or_module <span class="hljs-title">text_poke_early</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *opcode,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-keyword">size_t</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;<br>        local_irq_save(flags);<br>        <span class="hljs-built_in">memcpy</span>(addr, opcode, len);<br>        local_irq_restore(flags);<br>        <span class="hljs-comment">// SMP 多核同步</span><br>        sync_core();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-trampoline"><a href="#3-2-trampoline" class="headerlink" title="3.2 trampoline"></a>3.2 trampoline</h3><p>实际使用的时候，并不是通过直接将函数开头 5 bytes 的 nop 替换为 <code>call target_ip</code>，而是通过下面这段 trampoline 进行间接调用</p><p>不修改 <code>call ftrace_stub</code> 这条指令的话，执行顺序如下面标注所示，不得不说，设计得还是非常考究的，巧妙地利用了 <code>call</code> 和 <code>retq</code> 的特性，虽然也还有很多别的设计方式了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ftrace_caller:<br>        save regs   // 1<br>        load args   // 2<br>ftrace_call:<br>        call ftrace_stub // 3<br>        restore regs     // 4  6<br>ftrace_stub:<br>        retq             // 5  7<br></code></pre></td></tr></table></figure><p><img src="/images/ftrace1.png" alt="ftrace trampoline"></p><p>这段 assembly 代码位于 <code>arxh/x86/kernel/ftrace_64.S</code>，是一段模板代码，实际使用的时候，会在 <code>register_ftrace_function</code> 的时候，通过 <code>ops-&gt;trampoline = create_trampoline(ops, &amp;size)</code> 创建和上面这段几乎一样的跳板代码，然后将函数开头的 nop 指令替换为 <code>call xxx</code>，xxx 就是目标函数地址</p><p>其实，这里还做了一层封装，并不是直接将 xxx 设置为目标函数地址，因为那样根本无法扩展，实际中，如果想要在一个 fentry 点注册多个回调函数，只能将其保存在一个链表中，依次调用。</p><p>因此，ftrace_stub 最终会被替换为两种 wrapper 函数，一个是 <code>ftrace_ops_list_func</code>，另一个是 <code>ftrace_ops_assist_func</code>，或者就直接设置为 <code>ops-&gt;func</code> 也是有可能的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">ftrace_func_t</span> <span class="hljs-title">ftrace_ops_get_func</span><span class="hljs-params">(struct ftrace_ops *ops)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">if</span> (!(ops-&gt;flags &amp; FTRACE_OPS_FL_RECURSION_SAFE) ||<br>            ops-&gt;flags &amp; FTRACE_OPS_FL_RCU)<br>                <span class="hljs-keyword">return</span> ftrace_ops_assist_func;<br><br>        <span class="hljs-keyword">return</span> ops-&gt;func;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">ftrace_func_t</span> <span class="hljs-title">ftrace_ops_get_list_func</span><span class="hljs-params">(struct ftrace_ops *ops)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">if</span> (ops-&gt;flags &amp; (FTRACE_OPS_FL_DYNAMIC | FTRACE_OPS_FL_RCU) ||<br>            FTRACE_FORCE_LIST_FUNC)<br>                <span class="hljs-keyword">return</span> ftrace_ops_list_func;<br><br>        <span class="hljs-keyword">return</span> ftrace_ops_get_func(ops);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ftrace_ops_list_func</code> 则直接调用了 <code>__ftrace_ops_list_func</code>，主要的操作是，遍历 <code>ftrace_ops_list</code> 中的每一个 op，依次调用其 <code>op-&gt;func</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> nokprobe_inline <span class="hljs-keyword">void</span><br>__ftrace_ops_list_func(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> ip, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> parent_ip,<br>                       struct ftrace_ops *ignored, struct pt_regs *regs)<br>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ftrace_ops</span> *<span class="hljs-title">op</span>;</span><br>        <span class="hljs-comment">// ...</span><br>        <br>        <span class="hljs-comment">// 遍历 ftrace_ops_list 链表</span><br>        do_for_each_ftrace_op(op, ftrace_ops_list) &#123;<br>                <span class="hljs-comment">/* Stub functions don&#x27;t need to be called nor tested */</span><br>                <span class="hljs-keyword">if</span> (op-&gt;flags &amp; FTRACE_OPS_FL_STUB)<br>                        <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> ((!(op-&gt;flags &amp; FTRACE_OPS_FL_RCU) || rcu_is_watching()) &amp;&amp;<br>                    ftrace_ops_test(op, ip, regs)) &#123;<br>                        <span class="hljs-keyword">if</span> (FTRACE_WARN_ON(!op-&gt;func)) &#123;<br>                                pr_warn(<span class="hljs-string">&quot;op=%p %pS\n&quot;</span>, op, op);<br>                                <span class="hljs-keyword">goto</span> out;<br>                        &#125;<br>                        op-&gt;func(ip, parent_ip, op, regs);<br>                &#125;<br>        &#125; while_for_each_ftrace_op(op);<br>out:<br>        preempt_enable_notrace();<br>        <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因此，只需要在给 function 注册 ftrace op 的时候，提前判断一下是否已经有注册的 op，即可选择合适的 wrapper 函数</p><h3 id="3-3-preemption"><a href="#3-3-preemption" class="headerlink" title="3.3 preemption"></a>3.3 preemption</h3><p>对于这种 dynamic trampoline 来说，有一个问题必须要解决，那就是<strong>抢占</strong></p><p>因为这里的 trampoline 是动态创建的，一旦这个 fucntion 所有注册的 op 都释放了，就理所应当调用 <code>kfree(trampoline)</code> 来释放这段空间，但是，由于抢占的关系，无法确保这一点，这就引入了 RCU</p><p>具体的机制我暂时也没太搞明白，留个坑，慢慢补。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>trace</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>int3 黑魔法</title>
    <link href="/2022/01/09/linux/tracing/int3/"/>
    <url>/2022/01/09/linux/tracing/int3/</url>
    
    <content type="html"><![CDATA[<p>发现和 tracing 有关的好多内容，脱离了 int3 都无法很好的展开。要么需要额外写很多内容，要么是不够详细，所以想在这里单独说明一下 int3 的黑魔法。</p><h2 id="1-程序执行视角"><a href="#1-程序执行视角" class="headerlink" title="1. 程序执行视角"></a>1. 程序执行视角</h2><p>众所周知，可执行程序，在 CPU 看来，只是很多的指令罢了，对于不同的指令，CPU 会有不同的<strong>反应</strong>，如果学习过汇编，可能会了解 <code>mov</code> <code>add</code> <code>sub</code> <code>mul</code> <code>push</code> <code>pop</code> <code>call</code> 这些最常见的指令，但是 CPU 还有非常特殊的一类指令，是 CPU 设计者（硬件）专门用来方便软件调试的一种手段，CPU 执行完这条指令之后，会触发异常，然后执行操作系统预先设置好的异常处理函数，这样，软件开发人员就能对于程序有了更多的掌控：只需要想办法触发 int3 异常，就可以进入到异常处理函数中，只需要进入异常处理函数，就能实现各种 fancy 的功能（比如统计程序中的 int3 指令个数（dog）……）。</p><h2 id="2-如何触发-int3"><a href="#2-如何触发-int3" class="headerlink" title="2. 如何触发 int3"></a>2. 如何触发 int3</h2><p>那究竟如何让一个好端端的程序，触发 int3 异常呢？</p><p>对于一个<code>正常</code>编译的程序，显然会在 CPU 中顺利执行完所有指令，安详地过完它的一生。Sure，聪明的你可能想到了，我们可以通过内嵌汇编代码的方式，手动添加 int3 指令，不过那不是我们想要的效果了，就没有一个手段，在不修改源代码的情况下，去 hack 一个再正常不过的程序吗？</p><p>这就要用到 text poke 了。</p><p>一般来说，程序可以大体分为数据段和代码段，并且被分别载入虚拟内存中的不同区域，分配不同的权限，数据段是可读可写，代码段是可读可执行。之所以设计成这样，是非常容易理解的，如果数据段可执行，那么，就有一万种黑掉你电脑的手段，而代码段之所以不可写，是因为这是一条 <code>slow slow slow path</code>，只有在极少数情况下，才会有将代码段动态修改的需求，这也同时导致了 icache 不会轻易刷新，因为不管是操作系统还是硬件，都会默认代码段是只读的。</p><p>不过，万事没有绝对，对于可执行程序而言，我们只需要记住一点：只要是在内存中的玩意，我们都可以想办法 hack！代码段只读是吧？那就 mmap 修改掉权限咯！icache 不会轻易刷新？那就手动给它刷新咯！虽然实际操作起来有很多 trivial 的地方需要注意，但是理论上完全可行。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>trace</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kprobe</title>
    <link href="/2022/01/09/linux/tracing/kprobe/"/>
    <url>/2022/01/09/linux/tracing/kprobe/</url>
    
    <content type="html"><![CDATA[<h2 id="1-kprobe-是什么"><a href="#1-kprobe-是什么" class="headerlink" title="1. kprobe 是什么"></a>1. kprobe 是什么</h2><p>Kprobe是一种内核调测手段，它可以动态地跟踪内核的行为、收集debug信息和性能信息。 可以跟踪内核<strong>几乎所有的代码地址</strong>。这点非常神奇啊，几乎所有的代码，Wow，究竟如何办到这一点呢？我们可以从 debugger 角度出发，探究一下这个问题。</p><p>众所周知，debugger 是依赖于 ptrace 这个系统调用，ptrace 赋予了程序调试别的进程的能力，这一点是如何办到的呢？</p><p>不得不仔细观察 ptrace 的参数选项，我们发现，ptrace 有一个神奇的选项，叫做 <code>PTRACE_POKETEXT</code>，文档中说，这个选项可以 <code>Copy the word data to the address addr in the tracee&#39;s memory</code>，既然是修改内存中的内容，也就可以修改指令？</p><p>kprobe 是作用于指令级别的探针手段，因此和指令的执行分不开关系，必须要提前明确其中的细节：cpu取指令，执行指令，pc指向下一条指令地址，并且检查标志位（中断，eflags），判断是否会触发异常。而异常处理程序是由操作系统提前设置好的。</p><h2 id="2-kprobe-实现原理"><a href="#2-kprobe-实现原理" class="headerlink" title="2. kprobe 实现原理"></a>2. kprobe 实现原理</h2><p>有的同学可能很诧异，what？代码段还能修改？不是只有可读可写的数据段之类的，才能修改其中的内容吗？Too young too simple</p><p>只要是内存中的东西，内核都有办法将其修改掉，只不过，这种手段并不会轻易暴露给用户，否则可不把系统玩崩了</p><h3 id="2-1-register-kprobe"><a href="#2-1-register-kprobe" class="headerlink" title="2.1 register_kprobe"></a>2.1 register_kprobe</h3><p>做了下面几件事：</p><ol><li>根据符号获取 kprobe 的地址，或者直接获取到传入参数中的 kprobe 地址</li><li>准备一个可执行 mmap 区间中的 slot，并且将被 probe 的指令保存到 slot 中</li><li>添加这个 kprobe 到全局的 kprobe 哈希表中</li><li>通过 arm_probe 将对应位置上的指令的第一个字节替换为 0xcc</li></ol><p>如此一来，执行到这个 kprobe 之后，就会触发 int3 trap，就会陷入内核设置的 int3 处理函数中，即 <code>do_int3</code></p><h3 id="2-2-kprobe-int3-handler"><a href="#2-2-kprobe-int3-handler" class="headerlink" title="2.2 kprobe_int3_handler"></a>2.2 kprobe_int3_handler</h3><p>做了下面几件事：</p><ol><li>执行 pre_handler</li><li>设置单步中断标志位</li><li>将 pt_regs 中的 ip 指向保存的指令地址</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs markdown">Tips:<br><span class="hljs-bullet">1.</span> 注意，此时已经将被修改指令的第一个字节修改为 0xcc(int3)，如果该指令的地址为 x,那么此时的 ip = x + 1<br><span class="hljs-bullet">2.</span> 因为单步中断是完全可控的，所以可以将 ip 指向我们保存在可执行段中的指令，之后再将 ip 重新指回去就好了<br></code></pre></td></tr></table></figure><h3 id="2-3-kprobe-debug-handler"><a href="#2-3-kprobe-debug-handler" class="headerlink" title="2.3 kprobe_debug_handler"></a>2.3 kprobe_debug_handler</h3><p>重置该 kprobe，并且修正一些由于上一条指令执行导致的问题：</p><ol><li>函数调用</li></ol><p>之所以要修正，主要是因为如果我们刚好将一条 <code>call %rip(xxx)</code> 执行的第一个字节修改为 <code>0xcc</code> 了，在单步执行之后，就会将返回地址压栈，压栈的地址又是通过当前的 EIP 来决定的，但此时的 EIP 已经不是正常执行流中的预期值了，这样，函数调用返回之后，return 直接爆炸</p><p>因此，这里有必要修正一下位于栈顶的 return_address</p><h3 id="2-4-unregister-kprobe"><a href="#2-4-unregister-kprobe" class="headerlink" title="2.4 unregister_kprobe"></a>2.4 unregister_kprobe</h3><p>做了几件事：</p><ol><li>弹出对应指令地址处，最上方的一个 kprobe 探针</li><li>对于弹出的探针，将其禁止，也就是通过 <code>disarm_kprobe</code> 将原先指令还原</li></ol>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>trace</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>notify chain</title>
    <link href="/2022/01/09/linux/tracing/notify_chain/"/>
    <url>/2022/01/09/linux/tracing/notify_chain/</url>
    
    <content type="html"><![CDATA[<p>Linux 中广泛采用了事件通知机制，即 <strong>注册 + 回调</strong>，<code>notify chain</code> 就是很典型的例子。</p><h2 id="1-notify-chain-是什么"><a href="#1-notify-chain-是什么" class="headerlink" title="1. notify chain 是什么"></a>1. notify chain 是什么</h2><p>首先要明白，notify chain 是什么？</p><p>将其比作 <strong>发布-订阅模式</strong>，可能更加容易理解：</p><p>某个读者订阅了某个杂志，当杂志发版之后，就会收到对应的通知；一旦不再想看这个杂志，取消订阅即可。</p><p>Linux 中为了及时相应某一些到来的事件，采取了通知链机制，可以区分为三个角色：</p><ol><li>订阅者。可以使用通知者提供的 API，注册感兴趣的事件，以及对应的回调函数</li><li>通知者。通常是某个中断处理程序，或者是某个关键函数；</li><li>事件。当某个事件发生时，通知者这段代码得到执行，就可以查找是否有订阅者对当前事件感兴趣，如果已经注册，那么调用对应的回调函数。</li></ol><h2 id="2-show-me-the-code"><a href="#2-show-me-the-code" class="headerlink" title="2. show me the code"></a>2. show me the code</h2><p>我们可以从一个具体的地方开始看起：do_int3</p><p>熟悉 debugger 原理的同学会知道，单步中断用到了 <code>int 3</code> 这个特殊的指令，该指令会触发 CPU 异常，CPU 查找异常处理函数向量表之后，就会调用到之前注册的  <code>do_int3</code> 函数上。</p><p><code>do_int3</code>  这个函数可以说完成了相当多的功能，比如 kprobe，ftrace，都在其中加入了自己的处理逻辑，我们这里暂时不去理会。</p><p>关注函数返回之前的  <strong>notify_die</strong> 函数调用，这个名字似曾相识，没错，马上就会进入通知链处理了！</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">do_int3</span><span class="hljs-params">(struct pt_regs *regs)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">int</span> res;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_KGDB_LOW_LEVEL_TRAP</span><br> <span class="hljs-keyword">if</span> (kgdb_ll_trap(DIE_INT3, <span class="hljs-string">&quot;int3&quot;</span>, regs, <span class="hljs-number">0</span>, X86_TRAP_BP,<br>    SIGTRAP) == NOTIFY_STOP)<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* CONFIG_KGDB_LOW_LEVEL_TRAP */</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_KPROBES</span><br> <span class="hljs-keyword">if</span> (kprobe_int3_handler(regs))<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br> res = notify_die(DIE_INT3, <span class="hljs-string">&quot;int3&quot;</span>, regs, <span class="hljs-number">0</span>, X86_TRAP_BP, SIGTRAP);<br><br> <span class="hljs-keyword">return</span> res == NOTIFY_STOP;<br>&#125;<br></code></pre></td></tr></table></figure><p>noitfy_die 函数中，会将 <code>寄存器 + 异常名称 + 错误码 + 错误信号</code> 封装到 die_args 结构体中 ，并且调用 <code>atomic_notifier_call_chain</code> 函数，传入该结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> notrace <span class="hljs-title">notify_die</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> die_val val, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str,</span></span><br><span class="hljs-params"><span class="hljs-function">        struct pt_regs *regs, <span class="hljs-keyword">long</span> err, <span class="hljs-keyword">int</span> trap, <span class="hljs-keyword">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">die_args</span> <span class="hljs-title">args</span> =</span> &#123;<br>  .regs = regs,<br>  .str = str,<br>  .err = err,<br>  .trapnr = trap,<br>  .signr = sig,<br> &#125;;<br> RCU_LOCKDEP_WARN(!rcu_is_watching(),<br>      <span class="hljs-string">&quot;notify_die called but RCU thinks we&#x27;re quiescent&quot;</span>);<br> <span class="hljs-keyword">return</span> atomic_notifier_call_chain(&amp;die_chain, val, &amp;args);<br>&#125;<br>NOKPROBE_SYMBOL(notify_die);<br></code></pre></td></tr></table></figure><p><code>atomic_notifier_call_chain</code> 其实只是针对  <code>notifier_call_chain</code> 的一层封装，目的主要是为了 RCU lock 的加锁和解锁，核心处理逻辑在下面这段代码中，主要是遍历 notifiter_block 这个单向链表，分别调用这个注册链上的所有回调函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">notifier_call_chain</span><span class="hljs-params">(struct notifier_block **nl,</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> val, <span class="hljs-keyword">void</span> *v,</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-keyword">int</span> nr_to_call, <span class="hljs-keyword">int</span> *nr_calls)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">int</span> ret = NOTIFY_DONE; <br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">notifier_block</span> *<span class="hljs-title">nb</span>, *<span class="hljs-title">next_nb</span>;</span><br><br> nb = rcu_dereference_raw(*nl);<br><br> <span class="hljs-keyword">while</span> (nb &amp;&amp; nr_to_call) &#123;<br>  next_nb = rcu_dereference_raw(nb-&gt;next);<br><br>  ret = nb-&gt;notifier_call(nb, val, v);<br><br>  <span class="hljs-keyword">if</span> (nr_calls)<br>   (*nr_calls)++;<br><br>  <span class="hljs-keyword">if</span> (ret &amp; NOTIFY_STOP_MASK)<br>   <span class="hljs-keyword">break</span>;<br>  nb = next_nb;<br>  nr_to_call--;<br> &#125;<br> <span class="hljs-keyword">return</span> ret;<br>&#125;<br>NOKPROBE_SYMBOL(notifier_call_chain);<br><br></code></pre></td></tr></table></figure><p>这里的 <code>notifier_block</code> 这个链表中的内容，也不是凭空而来，一定需要通过某种机制向该链表添加结点，或者用更加专业一点的词汇：register</p><p>上面的 atomic notifier chain，也对应了这样一个 注册函数 <code>atomic_notifier_chain_register</code>，本质上是调用 <code>notifier_chain_register</code> 这个核心逻辑，注册到通知链中，这种 wrapper function，大部分情况是通过 spinlock 或者 rcu 机制来确保并发安全。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">atomic_notifier_chain_register</span><span class="hljs-params">(struct atomic_notifier_head *nh,</span></span><br><span class="hljs-params"><span class="hljs-function">  struct notifier_block *n)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;<br> <span class="hljs-keyword">int</span> ret;<br><br> spin_lock_irqsave(&amp;nh-&gt;lock, flags);<br> ret = notifier_chain_register(&amp;nh-&gt;head, n);<br> spin_unlock_irqrestore(&amp;nh-&gt;lock, flags);<br> <span class="hljs-keyword">return</span> ret;<br>&#125;<br>EXPORT_SYMBOL_GPL(atomic_notifier_chain_register);<br></code></pre></td></tr></table></figure><p><code>notifier_chain_register</code> 这个核心逻辑中，关键是根据 notifier_block 的优先级，将其插入到链表的合适位置中去，逻辑很清晰。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">notifier_chain_register</span><span class="hljs-params">(struct notifier_block **nl,</span></span><br><span class="hljs-params"><span class="hljs-function">  struct notifier_block *n)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">while</span> ((*nl) != <span class="hljs-literal">NULL</span>) &#123;<br>  <span class="hljs-keyword">if</span> (unlikely((*nl) == n)) &#123;<br>   WARN(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;double register detected&quot;</span>);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (n-&gt;priority &gt; (*nl)-&gt;priority)<br>   <span class="hljs-keyword">break</span>;<br>  nl = &amp;((*nl)-&gt;next);<br> &#125;<br> n-&gt;next = *nl;<br> rcu_assign_pointer(*nl, n);<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-what’s-more"><a href="#3-what’s-more" class="headerlink" title="3. what’s more?"></a>3. what’s more?</h2><p>上面拿 <code>int 3</code> 异常中的 notify_die 机制来作为示例，演示了一下 notify chain 是如何起作用的，但其实除了这个 <code>atomic_notifier_chain</code>，还有 <code>blocking_notifier_chain</code>，<code>raw_notifier_chain</code>，<code>srcu_notifier_chain</code>，本质上都是相通的。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>trace</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>tracepoint</title>
    <link href="/2022/01/09/linux/tracing/tracepoint/"/>
    <url>/2022/01/09/linux/tracing/tracepoint/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TraceEvent-是什么"><a href="#1-TraceEvent-是什么" class="headerlink" title="1. TraceEvent 是什么"></a>1. TraceEvent 是什么</h2><p>要搞明白 TraceEvent，首先要去了解一下 Tracepoint。</p><h3 id="1-1-tracepoint"><a href="#1-1-tracepoint" class="headerlink" title="1.1 tracepoint"></a>1.1 tracepoint</h3><p>Tracepoint 是内核中一种探测的机制。放置在代码中的 tracepoint（跟踪点）提供了一个钩子来调用您可以在运行时提供的函数（probe）。 tracepoint 可以是 “on”（开启）或 “off”（关闭）。 当跟踪点关闭时，它没有任何影响，除了添加一个微小的时间损失（检查分支条件）和空间损失（函数调用的指令所占空间）。 当 tracepoint 处于 “on” 状态时，每次执行 tracepoint 时都会在调用者的执行上下文中调用您提供的函数。 当提供的函数结束其执行时，直接返回给调用者。</p><p>简单来说，可以在一些关键函数中增加一个 tracepoint 调用，在这个调用中，会去检查是否开启了该 tracepoint，如果开启，才回去执行上面注册的所有回调函数。</p><p>再概括来说，tracepoint 也是基于 <strong>注册 + 回调</strong> 的思想，类似于 <strong>发布者/订阅者</strong> 模式，如果需要在某个函数上执行 trace 逻辑，就需要将回调函数注册上去，并且保证该 tracepoint 是开启状态。</p><p>和 kprobe 这种运行期动态修改指令的方式不同，tracepoint 是静态的，保存开启状态+回调函数，就可以轻松地完成 trace 的功能。</p><h3 id="1-2-tracepoint-的实现"><a href="#1-2-tracepoint-的实现" class="headerlink" title="1.2 tracepoint 的实现"></a>1.2 tracepoint 的实现</h3><p>tracepoint 的原理并不是那么复杂，但是为了方便开发者使用，内核大神们可是动用了各种<strong>宏</strong>里面的黑魔法</p><p>首先提供了一个<strong>声明trace</strong>  的宏 <code>DECLARE_TRACE</code> ，这个宏其实是给别的几个宏包装了一下，核心在于 <code>__DECLARE_TRACE</code></p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECLARE_TRACE(name, proto, args)    \</span><br><span class="hljs-meta"> __DECLARE_TRACE(name, PARAMS(proto), PARAMS(args),  \</span><br><span class="hljs-meta">   cpu_online(raw_smp_processor_id()),  \</span><br><span class="hljs-meta">   PARAMS(void *__data, proto),   \</span><br><span class="hljs-meta">   PARAMS(__data, args))</span><br></code></pre></td></tr></table></figure><p>在 <code>__DECLARE_TRACE</code> 中，主要是按照注册的 tracepoint 名字，添加了几个函数，通过名字可以大致推测出其功能，大致有：</p><ol><li>do action                        <code>trace##name</code></li><li>register/unregister       <code>register_trace_##name</code>/<code>unregister_trace_##name</code></li><li>enable/disable              <code>trace_##name##_enabled</code></li></ol><p>因为大部分都是重复的函数，所以用一个宏来帮开发者解决了这个问题，只不过对于内核开发人员，以及我们这些想要通过源码一探究竟的好奇宝宝来说，就不是那么友好了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __DECLARE_TRACE(name, proto, args, cond, data_proto, data_args) \</span><br><span class="hljs-meta"> extern int __traceiter_##name(data_proto);   \</span><br><span class="hljs-meta"> DECLARE_STATIC_CALL(tp_func_##name, __traceiter_##name); \</span><br><span class="hljs-meta"> extern struct tracepoint __tracepoint_##name;   \</span><br><span class="hljs-meta"> static inline void trace_##name(proto)    \</span><br><span class="hljs-meta"> &#123;        \ </span><br>  <span class="hljs-keyword">if</span> (static_key_false(&amp;__tracepoint_#<span class="hljs-meta">#name.key))  \</span><br><span class="hljs-meta">   __DO_TRACE(name,    \</span><br><span class="hljs-meta">    TP_PROTO(data_proto),   \</span><br><span class="hljs-meta">    TP_ARGS(data_args),   \</span><br><span class="hljs-meta">    TP_CONDITION(cond), 0);   \</span><br><span class="hljs-meta">  <span class="hljs-meta-keyword">if</span> (IS_ENABLED(CONFIG_LOCKDEP) &amp;&amp; (cond)) &#123;  \</span><br><span class="hljs-meta">   rcu_read_lock_sched_notrace();   \</span><br><span class="hljs-meta">   rcu_dereference_sched(__tracepoint_##name.funcs);\</span><br><span class="hljs-meta">   rcu_read_unlock_sched_notrace();  \</span><br><span class="hljs-meta">  &#125;       \</span><br><span class="hljs-meta"> &#125;        \</span><br><span class="hljs-meta"> __DECLARE_TRACE_RCU(name, PARAMS(proto), PARAMS(args),  \</span><br><span class="hljs-meta">  PARAMS(cond), PARAMS(data_proto), PARAMS(data_args)) \</span><br><span class="hljs-meta"> static inline int      \</span><br><span class="hljs-meta"> register_trace_##name(void (*probe)(data_proto), void *data) \</span><br><span class="hljs-meta"> &#123;        \</span><br><span class="hljs-meta">  return tracepoint_probe_register(&amp;__tracepoint_##name, \</span><br><span class="hljs-meta">      (void *)probe, data); \</span><br><span class="hljs-meta"> &#125;        \</span><br><span class="hljs-meta"> static inline int      \</span><br><span class="hljs-meta"> register_trace_prio_##name(void (*probe)(data_proto), void *data,\</span><br><span class="hljs-meta">       int prio)    \</span><br><span class="hljs-meta"> &#123;        \</span><br><span class="hljs-meta">  return tracepoint_probe_register_prio(&amp;__tracepoint_##name, \</span><br><span class="hljs-meta">           (void *)probe, data, prio); \</span><br><span class="hljs-meta"> &#125;        \</span><br><span class="hljs-meta"> static inline int      \</span><br><span class="hljs-meta"> unregister_trace_##name(void (*probe)(data_proto), void *data) \</span><br><span class="hljs-meta"> &#123;        \</span><br><span class="hljs-meta">  return tracepoint_probe_unregister(&amp;__tracepoint_##name,\</span><br><span class="hljs-meta">      (void *)probe, data); \</span><br><span class="hljs-meta"> &#125;        \</span><br><span class="hljs-meta"> static inline void      \</span><br><span class="hljs-meta"> check_trace_callback_type_##name(void (*cb)(data_proto)) \</span><br><span class="hljs-meta"> &#123;        \</span><br><span class="hljs-meta"> &#125;        \</span><br><span class="hljs-meta"> static inline bool      \</span><br><span class="hljs-meta"> trace_##name##_enabled(void)     \</span><br><span class="hljs-meta"> &#123;        \</span><br><span class="hljs-meta">  return static_key_false(&amp;__tracepoint_##name.key); \</span><br><span class="hljs-meta"> &#125;</span><br></code></pre></td></tr></table></figure><p>上面提到过，tracepoint 是有状态的，需要记录是否开启，以及所有注册的回调函数，这些信息都记录在 <code>struct tracepoint</code> 当中</p><p>对应到上面的各个难懂的宏，每个字段的功能分为是：</p><ol><li>key 用来记录 tracepoint 是否开启</li><li>regfunc 也就是注册回调函数的方法</li><li>unregfunc 也就是取消注册的方法</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tracepoint</span> &#123;</span><br> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;  <span class="hljs-comment">/* Tracepoint name */</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">static_key</span> <span class="hljs-title">key</span>;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">static_call_key</span> *<span class="hljs-title">static_call_key</span>;</span><br> <span class="hljs-keyword">void</span> *static_call_tramp;<br> <span class="hljs-keyword">void</span> *iterator;<br> <span class="hljs-keyword">int</span> (*regfunc)(<span class="hljs-keyword">void</span>);<br> <span class="hljs-keyword">void</span> (*unregfunc)(<span class="hljs-keyword">void</span>);<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tracepoint_func</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">funcs</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>再来看一下系统启动的时候，tracepoint 是如何注册到内核当中的。</p><p>Todo!()</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>trace</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>how perf works</title>
    <link href="/2022/01/09/linux/tracing/perf/"/>
    <url>/2022/01/09/linux/tracing/perf/</url>
    
    <content type="html"><![CDATA[<h2 id="1-perf-是什么"><a href="#1-perf-是什么" class="headerlink" title="1. perf 是什么"></a>1. perf 是什么</h2><p>perf  这个工具大家可能都用过，非常强大，但是也不免让人好奇，底层是如何实现的呢？</p><p>官方的定义为：Perf 是访问 processor monitor unit (PMU) 以及记录和展示 software events（例如页面错误）的接口。 它支持系统范围、线程级别和 KVM 虚拟化的各种监控。</p><p>但这种解释还是无法让人完全理解，别着急，听我慢慢道来。</p><p>首先明确一点：perf 是用来衡量 <strong>计算机/系统性能</strong>的工具。这一点应该没有什么疑问，那么，可以从哪些角度来衡量呢？大致上需要两个维度：</p><ol><li>硬件。比如 cache 丢失，流水线停顿，页面交换等</li><li>软件。内核产生的事件，分布在各个功能模块中，统计和操作系统相关性能事件。比如系统调用次数、上下文切换次数、任务迁移次数、缺页例外次数等。</li></ol><p>后者其实比较好理解，因为只需要内核代码当中添加一些 hack，比如添加 <strong>打点、metrix</strong> 这些工作就好了，但是前者对我们来说，着实有些陌生。</p><p>换一个角度考虑，既然内核可以为我们打点，记录一些程序执行情况，那么 CPU 是否也能记录一些更加 low-level 的事件呢？比如 cache miss, branch predict fail, TLB miss，这些硬件上的事件，都在 CPU 掌控之中，CPU 玩去哪有能力统计出来，并汇报给它的上层软件：操作系统。</p><h2 id="2-perf-底层如何实现"><a href="#2-perf-底层如何实现" class="headerlink" title="2. perf 底层如何实现"></a>2. perf 底层如何实现</h2><p>其实 perf 底层依赖于 PMU 这样一个硬件。PMU 的全称是 Performance Monitoring Unit，也就是性能监控单元。PMU 会初始化一个 硬件性能计数器 PMC（Performance Monitoring Counter），PMC随着指定硬件事件的发生而自动累加。在 PMC 溢出时，PMU 触发一个 PMI（Performance Monitoring Interrupt）中断。内核在 PMI  中断的处理函数中保存下面几个内容：</p><ol><li>PMC 的计数值</li><li>触发中断时的指令地址</li><li>当前时间戳以及当前进程的PID，TID，comm 等信息。</li></ol><p>我们把这些信息统称为一个采样（sample）。内核会将收集到的 sample 放入用于跟用户空间通信的 Ring Buffer。用户空间里的 perf  分析程序采用 mmap 机制从 ring buffer 中读入采样，并对其解析。</p><p>PMU 是体系相关的一个结构，对于 x86 &amp; intel 而言，核心代码在 arch/x86/events/intel 目录中。</p><p>针对 PMI 中断的处理函数便是 intel_pmu_handle_irq</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> __initconst <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">x86_pmu</span> <span class="hljs-title">intel_pmu</span> =</span> &#123;<br> .name   = <span class="hljs-string">&quot;Intel&quot;</span>,<br> .handle_irq  = intel_pmu_handle_irq,<br> .disable_all  = intel_pmu_disable_all,<br> .enable_all  = intel_pmu_enable_all,<br> .enable   = intel_pmu_enable_event,<br> .disable  = intel_pmu_disable_event,<br>   <span class="hljs-comment">/* other callbacks */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来研究一下 intel_pmu_handle_irq 中究竟做了什么<strong>黑科技</strong>？RTFSC！</p><p>这个 handler 的处理其实是一个循环，因为每当我们处理好一次 pmu overflow 之后，可能在这段时间内，重新触发了 overflow，导致我们不得不处理，但也应该防止这个 loop 执行次数过多，也就引入了  loops 变量进行统计。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">intel_pmu_handle_irq</span><span class="hljs-params">(struct pt_regs *regs)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu_hw_events</span> *<span class="hljs-title">cpuc</span>;</span><br> <span class="hljs-keyword">int</span> loops;<br> u64 status;<br> <span class="hljs-keyword">int</span> handled;<br> <span class="hljs-keyword">int</span> pmu_enabled;<br><br> cpuc = this_cpu_ptr(&amp;cpu_hw_events);<br> pmu_enabled = cpuc-&gt;enabled;<br> loops = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    setup context here</span><br><span class="hljs-comment">  */</span><br>  <br>  <span class="hljs-comment">// again loop</span><br>again:<br> intel_pmu_lbr_read();<br> intel_pmu_ack_status(status);<br> <span class="hljs-keyword">if</span> (++loops &gt; <span class="hljs-number">100</span>) &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> warned;<br><br>  <span class="hljs-keyword">if</span> (!warned) &#123;<br>   WARN(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;perfevents: irq loop stuck!\n&quot;</span>);<br>   perf_event_print_debug();<br>   warned = <span class="hljs-literal">true</span>;<br>  &#125;<br>  intel_pmu_reset();<br>  <span class="hljs-keyword">goto</span> done;<br> &#125;<br><br> handled += handle_pmi_common(regs, status);<br><br> status = intel_pmu_get_status();<br> <span class="hljs-keyword">if</span> (status)<br>  <span class="hljs-keyword">goto</span> again;<br><br>done:<br> cpuc-&gt;enabled = pmu_enabled;<br> <span class="hljs-keyword">if</span> (pmu_enabled)<br>  __intel_pmu_enable_all(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br> intel_bts_enable_local();<br><br> <span class="hljs-comment">// return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果将一些干扰因素抽离，就可以得到下面这个主干逻辑。就是一个不断处理 pmi 中断的过程。核心逻辑在 <code>handle_pmi_common</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">intel_pmu_handle_irq</span><span class="hljs-params">(struct pt_regs *regs)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 1. set up context</span><br>  <br>  <span class="hljs-comment">// 2. loop</span><br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// core logic </span><br>  handled += handle_pmi_common(regs, status);<br>  &#125; <span class="hljs-keyword">while</span> (intel_pmu_get_status()!=<span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，<code>handle_pmi_common</code> 主要分为三个步骤进行处理</p><ol><li>processor trace</li><li>perf metrics</li><li>perf event overflow</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">handle_pmi_common</span><span class="hljs-params">(struct pt_regs *regs, u64 status)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// 上下文环境准备</span><br><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  * Intel PT(Processor Trace) 处理</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">if</span> (__test_and_clear_bit(GLOBAL_STATUS_TRACE_TOPAPMI_BIT, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *)&amp;status)) &#123;<br>  handled++;<br>  <span class="hljs-keyword">if</span> (unlikely(perf_guest_cbs &amp;&amp; perf_guest_cbs-&gt;is_in_guest() &amp;&amp;<br>   perf_guest_cbs-&gt;handle_intel_pt_intr))<br>   perf_guest_cbs-&gt;handle_intel_pt_intr();<br>  <span class="hljs-keyword">else</span><br>   intel_pt_interrupt();<br> &#125;<br><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  * Intel Perf mertrics 处理</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">if</span> (__test_and_clear_bit(GLOBAL_STATUS_PERF_METRICS_OVF_BIT, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *)&amp;status)) &#123;<br>  handled++;<br>  <span class="hljs-keyword">if</span> (x86_pmu.update_topdown_event)<br>   x86_pmu.update_topdown_event(<span class="hljs-literal">NULL</span>);<br> &#125;<br><br> status |= cpuc-&gt;intel_cp_status;<br><br>  <span class="hljs-comment">// 针对每个 overflow bit，都要进行对应的处理，上报 perf event</span><br> for_each_set_bit(bit, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *)&amp;status, X86_PMC_IDX_MAX) &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">perf_event</span> *<span class="hljs-title">event</span> =</span> cpuc-&gt;events[bit];<br><br>  handled++;<br><br>  <span class="hljs-keyword">if</span> (!test_bit(bit, cpuc-&gt;active_mask))<br>   <span class="hljs-keyword">continue</span>;<br><br>  <span class="hljs-keyword">if</span> (!intel_pmu_save_and_restart(event))<br>   <span class="hljs-keyword">continue</span>;<br><br>  perf_sample_data_init(&amp;data, <span class="hljs-number">0</span>, event-&gt;hw.last_period);<br><br>  <span class="hljs-keyword">if</span> (has_branch_stack(event))<br>   data.br_stack = &amp;cpuc-&gt;lbr_stack;<br><br>  <span class="hljs-keyword">if</span> (perf_event_overflow(event, &amp;data, regs))<br>   x86_pmu_stop(event, <span class="hljs-number">0</span>);<br> &#125;<br><br> <span class="hljs-keyword">return</span> handled;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Tips:<br>  Intel Processor Trace（PT）是Intel在其第五代 CPU 之后引入的一个硬件部件。该硬件部件的作用是记录程序执行中的分支信息，从而帮  助构建程序运行过程中的控制流图。在默认情况下 CPU 的 PT 部件是处于关闭状态，这意味着 CPU 不会记录程序的分支信息，因此也不会产生  任何开销。通过写 MSR 寄存器可以打开 PT 开关。在打开 PT 开关后，CPU开始记录分支指令信息，所记录的信息以压缩数据包的形式存储在内   存中<br></code></pre></td></tr></table></figure><p>硬件相关的机制我们可能不是很熟悉，但是 perf 采集的数据上报给用户的过程，这总得看一看呗。在针对 overflow bit 的处理逻辑末尾，都会调用 <code>perf_event_overflow</code> 函数，看到这个名字也不难猜出意思：perf 溢出事件。来看其核心处理逻辑。</p><p><code>__perf_event_overflow</code> 主要逻辑很简单，调用 event-&gt;overflow_handler，而这个 event 又是什么呢？这个 overflow_handler 在哪里设置的呢？嘿嘿，**<code>sys_perf_event_open</code>** 系统调用！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __perf_event_overflow(struct perf_event *event,<br>       <span class="hljs-keyword">int</span> throttle, struct perf_sample_data *data,<br>       struct pt_regs *regs)<br>&#123;<br> <span class="hljs-comment">// 准备工作 ...</span><br><br>  <span class="hljs-comment">// 调用 overflow_handler</span><br> READ_ONCE(event-&gt;overflow_handler)(event, data, regs);<br><br>  <span class="hljs-comment">// fasync 同步刷新，如果没有成功，需要提交到 work_queue 中 </span><br> <span class="hljs-keyword">if</span> (*perf_event_fasync(event) &amp;&amp; event-&gt;pending_kill) &#123;<br>  event-&gt;pending_wakeup = <span class="hljs-number">1</span>;<br>  irq_work_queue(&amp;event-&gt;pending);<br> &#125;<br><br> <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>深挖了这么多层，终于找到了和 perf 相关的系统调用了！在 perf_event_open 系统调用中，会通过 <code>perf_event_alloc</code> 分配一个 <code>perf event</code> 结构，并且设置对应的 overflow_handler，闭环啦！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">perf_event_alloc(...)&#123;<br>  ...<br>  <span class="hljs-keyword">if</span> (overflow_handler) &#123;<br>  event-&gt;overflow_handler = overflow_handler;<br>  event-&gt;overflow_handler_context = context;<br> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is_write_backward(event))&#123;<br>  event-&gt;overflow_handler = perf_event_output_backward;<br>  event-&gt;overflow_handler_context = <span class="hljs-literal">NULL</span>;<br> &#125; <span class="hljs-keyword">else</span> &#123;<br>  event-&gt;overflow_handler = perf_event_output_forward;<br>  event-&gt;overflow_handler_context = <span class="hljs-literal">NULL</span>;<br> &#125;  <br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>Hold on，事情还没有结束，我们现在已经自底向上捋了一下 perf PMU 事件的调用流程，还需自上而下来总览一下整个 perf event 的实现原理。</p><h2 id="3-perf-event-open-系统调用"><a href="#3-perf-event-open-系统调用" class="headerlink" title="3. perf_event_open 系统调用"></a>3. perf_event_open 系统调用</h2><p>Todo!()</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>trace</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>小妇人</title>
    <link href="/2021/12/26/movies/%E5%B0%8F%E5%A6%87%E4%BA%BA/"/>
    <url>/2021/12/26/movies/%E5%B0%8F%E5%A6%87%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<p>再次感谢 @越哥说电影</p><p>第一次看小妇人，是在合肥，和最爱的唯唯一起，她就靠在我的肩上，边看边跟我说悄悄话，真美好啊！这部电影质量也很好，总之是一次很不错的回忆。记得同时上映的还有别的电影，她唯独选了这个，现在看来，却有其用意。</p><p>什么用意呢？经历了这么多，感觉她和剧中女主-乔，有很多的相似之处：她们都渴望美好的爱情，但是又希望通过自己的能力去实现自身价值，不愿意依附男生，如果说乔是旧时代的独立女性，那唯唯就是新时代的独立女性，有能力，有抱负，敢于闯荡。</p><p>说来好笑，很长一段时间中，都把唯唯当成了大姐-梅格一样的小女生：深爱自己的 npy，愿意做出牺牲，放弃很多，换来和丈夫在一起的美好时光（当然梅格的丈夫和我还是差了很多的，至少我还有一个体面的 job），但在她看来，我可能在精神上还比不上梅格的丈夫吧。</p><p>剧中的四姐妹都给我留下了深刻的印象，活灵活现，有血有肉。</p><p>大姐梅格，是最有大家闺秀气质的一个，从小畅想着嫁入豪门，过上体面的生活，不过最终还是嫁给了爱情，付出的代价是，只能和一个穷教书匠丈夫拮据过日，甚至买不到自己心爱的衣服，同时受着内心虚荣心的折磨，受不了一个个“好闺蜜”的攀比。但就算犯了错，一时赌气，用过冬的几个小钱买下了一个华而不实的布匹，也能意识到自己的问题，和丈夫重归于好，继续过着平凡的生活。</p><p>二女儿乔，是本剧的主人公，她就有更多可说的了：从小热爱写作，这让她和周围的姐妹们“格格不入”，当然也不是不合，她们的感情超级好，只是要按照那个时代的眼光来看，女人就应该嫁一个有钱的男人，其它的都是歪门邪道，没有出路。</p><p>乔在追逐自己写作梦想的途中，经历了许许多多值得我们体味的事。小时候，她的妹妹因为一件小事和她赌气，烧了她的手稿，她回来之后怒不可遏，但在妹妹掉入冰窟窿之后，费劲九牛二虎之力救起来之后，反倒陷入了自责，在最小的妹妹患病卧床之后，也是她日夜陪在妹妹身边，抱着她睡觉，妹妹病好之后，她也是最兴奋的那个，从这几件事都可以看出她是一个情感非常丰富，敢爱敢恨的，惹人喜爱的女生（555，这不就是我家唯唯吗）。</p><p>她经历过小说险些退稿，杂志编辑强加给她的写作路线，大学教授的否定，但依然坚持着写作，一个女生，在外面闯荡，</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>男人四十</title>
    <link href="/2021/12/26/movies/%E7%94%B7%E4%BA%BA%E5%9B%9B%E5%8D%81/"/>
    <url>/2021/12/26/movies/%E7%94%B7%E4%BA%BA%E5%9B%9B%E5%8D%81/</url>
    
    <content type="html"><![CDATA[<p>越哥说电影，真的是一个宝藏！在我最需要情感开导的时候，我看到了这样一部电影的影评，真的是沉浸其中，对 npy 分手的决定有了更多的理解。</p><p>看完了影评之后，我决定还是去看一下原片，才能更加深切地感受其中的细节。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Strange Things</title>
    <link href="/2021/12/26/movies/Stranger%20Things/"/>
    <url>/2021/12/26/movies/Stranger%20Things/</url>
    
    <content type="html"><![CDATA[<p>写在前面：</p><p>说来很奇怪，一直很喜欢看影评，但是自己从来没有写过，所以这算是一次全新的尝试吧。</p><p>第一次接触怪奇物语这部片子，是在B站上的小片片说大片的解说，不过那已经是很早以前的事情了，而且这个系列无疾而终，所以也没有给我留下很深刻的印象。第二次则是在上海字节跳动，和同事散步的时候，他聊起的这部电视剧，说是相当好看。</p><p>正好和 npy 分手之后，意志比较消沉，什么正经事都不想干，于是乎去搜了搜 Netflix 的爆款电视剧，再一次见到了 <code>Strange Things</code> 这个名字，心动不如行动，花了一个半天的时间，终于将三季的内容全部看完了。也想改变一下过去的自己，记录一点什么，随便写写就好。</p><h2 id="1-第一季"><a href="#1-第一季" class="headerlink" title="1. 第一季"></a>1. 第一季</h2><p>第一季给我的感受可以用两个字来形容：惊艳！<br>从各个方面，都可以达到我心目中的 Top 电视剧的水准，情节，氛围，人物，完美契合一部好电视剧（小说）的要素。</p><p>首先最值得夸赞的一点是，大家的智商都非常在线，这一点很关键啊，因为这可以推动情节快速发展，非常紧凑。令我印象非常深刻的是 Will’s Mom 面对 Will 失踪的反应，完全感受不到演的成分，在接触到 电话接二连三报废，家里灯光奇异闪烁，墙上钻出了一个恐怖的生物… 这一系列事情，在外人看来，完全无法理解，甚至她的大儿子都觉得她是个疯子，不过我们知道，她是一个坚强的女人（从别的情节得知）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V -- instruction set</title>
    <link href="/2021/12/24/riscv/instruction-set/"/>
    <url>/2021/12/24/riscv/instruction-set/</url>
    
    <content type="html"><![CDATA[<h1 id="RISC-V-–-instruction-set"><a href="#RISC-V-–-instruction-set" class="headerlink" title="RISC-V  – instruction set"></a>RISC-V  – instruction set</h1><h2 id="1-什么是-RISC-V"><a href="#1-什么是-RISC-V" class="headerlink" title="1. 什么是 RISC-V"></a>1. 什么是 RISC-V</h2><p><strong>定义</strong>： <strong>RISC-V</strong>（发音为“risk-five”）是一个基于<a href="https://zh.wikipedia.org/wiki/%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E9%9B%86">精简指令集</a>（RISC）原则的<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%BA%90%E6%A0%87%E5%87%86">开源</a><a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B">指令集架构</a>（ISA），简易解释为<a href="https://zh.wikipedia.org/wiki/%E9%96%8B%E6%BA%90%E8%BB%9F%E9%AB%94">开源软件</a>运动相对应的一种“开源硬件”。该项目2010年始于<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%B7%9E%E5%A4%A7%E5%AD%B8%E6%9F%8F%E5%85%8B%E8%90%8A%E5%88%86%E6%A0%A1">加州大学柏克莱分校</a>，但许多贡献者是该大学以外的志愿者和行业工作者。</p><p>作为除了 x86 和 Arm 以外的第三大指令集，RISC-V 正在逐渐受到巨头们的青睐，并纷纷布局 RISC-V 生态，中科院计算所领导的团队也在大力开展 RISC-V 相关的工作。</p><p>RISC-V 有什么有点呢？一个字：<strong>简单！</strong></p><p>RISC-V 指令使用模块化的设计，没有历史包袱，优雅简洁，十分便于学习，其 包括几个可以互相替换的基本指令集，以及额外可以选择的扩展指令集，大致包含了：</p><ol><li>基础整数指令集</li><li>乘除指令</li><li>浮点数指令</li><li>原子指令</li><li>压缩指令</li><li>向量指令</li><li>特权级指令</li></ol><h2 id="2-RISC-V-设计"><a href="#2-RISC-V-设计" class="headerlink" title="2. RISC-V 设计"></a>2. RISC-V 设计</h2><h3 id="2-1-寄存器集"><a href="#2-1-寄存器集" class="headerlink" title="2.1 寄存器集"></a>2.1 寄存器集</h3><p>RISC-V 包含了 32 个整数寄存器，以及一个用户可见程序计数器 PC。实现浮点数规范之后，还有 32 个浮点数寄存器（对于嵌入式系统，整数寄存器的数量可以为 16）。</p><p>和 MIPS 这种 RISC 架构类似，RISC-V 的第一个寄存器为 “<strong>零寄存器</strong>“（永远为 0，这可以带来很多好处，比如，<code>mov X, Y</code> 可以修改为 <code>add X, Y, 0 </code>）RISC-V 还提供了 “控制寄存器” 和 “状态寄存器” ，但是 User 模式无法访问。</p><p>RISC-V 没有指令可以同时操作多个寄存器，和 X86 这种功能强大但复杂的架构完全不同。</p><h3 id="基本指令格式"><a href="#基本指令格式" class="headerlink" title="基本指令格式"></a>基本指令格式</h3><p>基本指令包含下面几个部分：R I S U </p><ol><li>imm：立即数</li><li>rs1：源寄存器</li><li>rs2：源寄存器2</li><li>rd：目标寄存器</li><li>opcode：操作码</li></ol><h3 id="2-2-立即数"><a href="#2-2-立即数" class="headerlink" title="2.2 立即数"></a>2.2 立即数</h3><p>RISC-V 的立即数需要根据不同指令拼装（这一点对于手写 decoder 来说挺麻烦的）</p><h3 id="整数计算"><a href="#整数计算" class="headerlink" title="整数计算"></a>整数计算</h3><h3 id="2-3-函数调用，分支，跳转"><a href="#2-3-函数调用，分支，跳转" class="headerlink" title="2.3 函数调用，分支，跳转"></a>2.3 函数调用，分支，跳转</h3><p>RISC-V 的函数通过 JAL（jump and link）将返回地址放在一个寄存器中，这样就可以省下一次堆栈的访问（push rip + jmp xxx） </p><h3 id="2-4-原子指令"><a href="#2-4-原子指令" class="headerlink" title="2.4 原子指令"></a>2.4 原子指令</h3><p>RISC-V 支持多个 CPU 与 thread。其允许 CPU 执行时重排序：读取和写入顺序可以重排。但是有些读取可以被设置成“获取”运算，会在其后的访问之前被执行，有些写入可以被当作“释放”运算。基本指令中通过 <code>fence</code> 来保证存储器的访问顺序，</p><h3 id="系统指令"><a href="#系统指令" class="headerlink" title="系统指令"></a>系统指令</h3><p>RISC-V 规定了 8 条系统指令，简单的实现中，可以不定义这些软件，但是，如果是写一个 RISC-V 的系统模拟器，是一定要完成的。</p><p>scall 用于系统调用，sbreak 用于调试器调试，剩下的指令用于操作 csr（control and status registers）</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>scall</td><td>system call</td></tr><tr><td>sbreak</td><td>Breakpoint</td></tr><tr><td>csrrw rd, csr, rs1</td><td>read csr into rd, store rs1 into csr</td></tr><tr><td>csrrc rd, csr, rs1</td><td>read csr into rd, set bit of csr</td></tr><tr><td>csrrs rd, csr, rs1</td><td>read csr into rd, clear bit of csr</td></tr><tr><td>csrrwi rd, csr, imm[4:0]</td><td>read csr into rd, store immediate into csr</td></tr><tr><td>csrrci rd, csr, imm[4:0]</td><td>read csr into rd, set bit of csr with imm</td></tr><tr><td>csrrsi rd, csr, imm[4:0]</td><td>read csr into rd, clear bit of csr with imm</td></tr></tbody></table><p>在大多数的系统当中，csr 只有在特权模式下才能访问，但是也存在一些只读寄存器，可以在用户模式下直接访问，比如：</p><ol><li>cycle：从任意参照的时间流逝的时钟周期数</li><li>time：流逝的系统时间</li><li>instret：实时时钟</li><li>cycleh</li><li>timeh</li><li>instreth</li></ol><h2 id="3-参考文件"><a href="#3-参考文件" class="headerlink" title="3. 参考文件"></a>3. 参考文件</h2><p><a href="http://crva.ict.ac.cn/documents/RISC-V-Reader-Chinese-v2p1.pdf.11.3">risc-v manual</a></p><p><a href="https://riscv.org/wp-content/uploads/2015/11/riscv-compressed-spec-v1.9.pdf">risc-v compression set manual</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TLS</title>
    <link href="/2021/12/24/linux/network/tls/"/>
    <url>/2021/12/24/linux/network/tls/</url>
    
    <content type="html"><![CDATA[<h2 id="1-TLS-是什么"><a href="#1-TLS-是什么" class="headerlink" title="1. TLS 是什么"></a>1. TLS 是什么</h2><p>我们需要在网络中实现安全通信，最直接的思路是，将内容通过某种手段加密，再通过某种手段解密。</p><p>这个手段可以有两种：</p><ol><li>非对称加密。比如 RSA，ECC 算法，加解密过程是不可逆的，可以方便地对于数据进行签名/验证，但是计算速度慢</li><li>对称加密。计算速度快，加密强度大，但关键是，加解密用的是相同的密钥，需要通过安全的手段传输密钥才行。</li></ol><p>我们最终肯定还是希望可以使用性能更好的对称加密，但是协商对称加密密钥的过程，本身是不安全的，TLS 协议主要就是为了解决这个问题。</p><p>其实最关键的一步，就是从 0 到 1 的建立信任的过程，只要这个步骤做好了，之后就可以在已经加密的信道上面进行通信。</p><p>但是我们始终要明确一点：<strong>网络是不安全的！</strong> 不仅是你发出去的信息会被别人截获，甚至可能收到中间人发送的假消息，前者关注点在于<strong>发送</strong>，后者关注点在于<strong>接收</strong>。</p><p>针对发送和接收这两种情况，非对称加密分别有两个对策：</p><ol><li>接收方将公钥放在公开的地方，私钥自己好好保存，发送方需要使用公钥将数据加密，然后发送出去。这样，只有拥有私钥的接收方可以正确地解密；</li><li>发送方使用私钥进行加密，只有通过公钥才能解密，并且，如果篡改了其中的内容，公钥解密是会失败的，这样，接收者也就可以接收到正确的消息了。</li></ol><p>这两者都利用了非对称加密当中，<strong>只有同时拥有公钥和私钥，才能进行解密</strong> 这个先决条件，互为逆过程。</p><p>上面这两种方式中，都有一个很关键的问题：<strong>公钥的安全传输！</strong> 试想一下，如果公钥和私钥同时被他人截获并替换，那我们的信息就完全暴露在攻击者面前了。非对称加密又是建立在成功获取公钥的基础上，这两者的冲突似乎无法很好地解决！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs text">Tips:<br>  其实几乎所有的加密，都会建立在某些已经确定的信任链基础上，然后才能慢慢扩展。<br></code></pre></td></tr></table></figure><p>为了解决这个问题，引入了根证书的概念。所谓根证书，是最最权威的机构颁发的认证，内置在操作系统当中，因此不会因为网络上的传输而无法验明真伪。而需要加密认证的网站，需要将自己的公钥上传，交给根证书认证机构，用该机构的密钥进行加密，作为 Certificate 颁发给网站申请者。</p><p>有访客访问网站的时候，会将这个 Certificate 下载到本地，并且根据系统内置的根证书链，对其内容验明真伪，如果为真，解密之后就可以获取到其中包含的网站公钥。</p><p>上面所说的 Certificate，就是真正的证书，目前几乎遵守 X.509 格式，内容大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">版本号<br>序列号<br>签名算法<br>颁发者<br>证书有效期<br>  开始日期<br>  终止日期<br>主题<br>主题公钥信息<br>  公钥算法<br>  主体公钥<br>颁发者唯一身份信息（可选）<br>主题唯一身份信息（可选）<br>扩展信息（可选）<br>签名<br></code></pre></td></tr></table></figure><h2 id="2-TLS-证书"><a href="#2-TLS-证书" class="headerlink" title="2. TLS 证书"></a>2. TLS 证书</h2><p>SSL/TLS  有多种文件格式，主要的文件有：PEM, DER, PFX, JKS, KDB, CER, KEY, CRT, CSR，同时也会设计到几个协议，如 CRL, OCSP, SCEP  等，下面主要针对常用的文件格式和协议进行解释</p><h3 id="2-1-introduction"><a href="#2-1-introduction" class="headerlink" title="2.1 introduction"></a>2.1 introduction</h3><p>其实上面的证书类型，笼统来说叫做类型，细分起来，区别还是很大的，可以大致划分为：</p><ol><li>编码格式</li><li>文件扩展名</li></ol><h3 id="2-2-编码格式"><a href="#2-2-编码格式" class="headerlink" title="2.2 编码格式"></a>2.2 编码格式</h3><p>编码格式可以分为 PEM 和 DER 两种，</p><ol><li><p>PEM（private enhanced mail）</p><p>​ Openssl 默认使用 PEM 格式（文本）来存放各种信息，这是 openssl 默认的存放方式，一般 PEM 文件包含一下信息：</p><ul><li>内容类型。表示本文件存放的是什么内容的信息，以 <code>-----BEGIN XXX-----</code> 开始，以 <code>-----END XXX-----</code> 结束，XXX 可以是 <code>PRIVATE KEY</code> ，也可以是 <code>CERTIFICATE</code>，分别表示这是一个私钥还是公钥。</li><li>头部信息。表示数据加密处理的方式，一般等同于加密算法+初始化向量。</li><li>信息内容。BASE64 编码之后的数据。</li></ul></li><li><p>DER（distinguished encoding rules）</p><p>​  使用二进制格式进行存储，对人类不友好。</p></li></ol><p>两种编码可以互相进行转换：</p><ol><li>PEM 转为 DER <code>openssl x509 -in cert.crt -outform der -out cert.der</code></li><li>DER 转为 PEM: <code>openssl x509 -in cert.crt -inform der -outform pem -out cert.pem</code></li></ol><h3 id="2-3-文件扩展名"><a href="#2-3-文件扩展名" class="headerlink" title="2.3 文件扩展名"></a>2.3 文件扩展名</h3><p>这里是比较迷惑人的地方，虽然编码格式就 PEM 和 DER 两种，但是，文件扩展名千奇百怪。</p><ol><li>CRT。certificate 的缩写，常见于 *NIX 系统，编码格式 unknown，如果为 PEM 编码，上面已经说明如何辨；</li><li>CET。还是 certificate，常见于Windows系统，同样编码格式 unknown，不过大多数应该是 DER 编码。和 CRT 是同义词；</li><li>KEY。这个含义应该很明确了，钥匙，可以是私钥，也可以是公钥，编码格式unknown；</li><li>PFX/P12。 对*NIX 服务器来说，一般 CRT 和 KEY 是分开存放在不同文件中的，但 Windows 则将它们存在一个 PFX 文件中（因此这个文件同时包含了证书及私钥）并且 PFX 通常会有一个“密码”，如果你想把里面的东西读取出来的话，它就要求你提供提取密码；</li><li>CSR。certificate signing request，即证书签名请求，这个并不是证书，而是向权威证书办法机构获取签名证书的申请，核心内容是一个公钥，在生成公钥的时候，同时还会生成一个相匹配的私钥，需要自己保管好。</li><li>JKS。Java Key Storage，这个是 Java 的专利，可以和 PFX 互相转换，但是和 Openssl 关系不大。</li></ol><p>总结一下，CRT/CET 表示证书，Key 表示密钥（公钥/私钥），它们都可以表示为 PEM 和 DER 两种格式。很多时候人们并不会按照文件内容来添加后缀，有时候会很困惑，所以最好还是在文本编辑器中打开，然后自行查看。</p><h2 id="3-TLS-建立加密通信过程"><a href="#3-TLS-建立加密通信过程" class="headerlink" title="3. TLS 建立加密通信过程"></a>3. TLS 建立加密通信过程</h2><p>下面这个图片借鉴自网络，我觉得非常清晰，所以就直接粘贴了。</p><p><img src="https://segmentfault.com/img/bVbCCMD" alt="SSL : TLS 握手过程"></p><p>TLS 握手的详细过程：</p><ol><li>“client hello” 消息：客户端通过发送 “client hello” 消息向服务器发起握手请求，该消息包含了客户端所支持的 TLS 版本和密码组合以供服务器进行选择，还有一个 “client random” 随机字符串。</li><li>“server hello” 消息：服务器发送 “server hello” 消息对客户端进行回应，该消息包含了数字证书，服务器选择的密码组合和 “server random” 随机字符串。</li><li>验证：客户端对服务器发来的证书进行验证，确保对方的合法身份，验证过程可以细化为以下几个步骤：<ol><li>检查数字签名</li><li>验证证书链 (这个概念下面会进行说明)</li><li>检查证书的有效期</li><li>检查证书的撤回状态 (撤回代表证书已失效)</li></ol></li><li>“premaster secret” 字符串：客户端向服务器发送另一个随机字符串 “premaster secret (预主密钥)”，这个字符串是经过服务器的公钥加密过的，只有对应的私钥才能解密。</li><li>使用私钥：服务器使用私钥解密 “premaster secret”。</li><li>生成共享密钥：客户端和服务器均使用 client random，server random 和 premaster secret，并通过相同的算法生成相同的共享密钥 KEY。</li><li>客户端就绪：客户端发送经过共享密钥 KEY 加密过的 “finished” 信号。</li><li>服务器就绪：服务器发送经过共享密钥 KEY 加密过的 “finished” 信号。</li><li>达成安全通信：握手完成，双方使用对称加密进行安全通信。</li></ol><p>参考资料：</p><ol><li>[<a href="https://segmentfault.com/a/1190000021559557">HTTPS详解二：SSL / TLS 工作原理和详细握手过程</a>]</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>zero copy</title>
    <link href="/2021/12/24/linux/network/zero%20copy/"/>
    <url>/2021/12/24/linux/network/zero%20copy/</url>
    
    <content type="html"><![CDATA[<h2 id="1-传统-IO"><a href="#1-传统-IO" class="headerlink" title="1. 传统 IO"></a>1. 传统 IO</h2><p>为了更好的理解零拷贝解决的问题，我们首先了解一下传统 I/O 方式存在的问题：</p><p>在 Linux 系统中，传统的访问方式是通过 write() 和 read() 两个系统调用实现的，通过 read() 函数读取文件到到缓存区中，然后通过 write() 方法把缓存中的数据输出到网络端口：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs c">read(file_fd, tmp_buf, len);<br>write(socket_fd, tmp_buf, len);<br></code></pre></td></tr></table></figure><p>整个过程中，涉及到了 2 次系统调用，2 次内核态和用户态之间的数据拷贝，2 次内核态和 DMA 之间的数据拷贝，代价非常大， 有没有什么方式可以尽量减少这些开销呢？</p><p>有下面几个思路：</p><ol><li>减少系统调用。也就是说，我尽可能一次性将要完成的 IO 操作，告诉内核，这样就不需要频繁地进行上下文切换</li><li>直接从磁盘拷贝文件到 DMA。如果我们可以将所要进行的 IO 操作描述清楚，比如需要将某个文件通过某个 socket 发送出去，就没有必要先将文件读取到用户空间，再拷贝到内核中，来完成剩下的操作；相反，我们可以直接在内核态读取文件内容，并且拷贝到 DMA 中。</li></ol><p>简要概括：Context switch is expensive, copy is expensive,  copy directly in kernel !</p><h2 id="2-零拷贝"><a href="#2-零拷贝" class="headerlink" title="2. 零拷贝"></a>2. 零拷贝</h2><h3 id="2-1-direct-IO"><a href="#2-1-direct-IO" class="headerlink" title="2.1 direct IO"></a>2.1 direct IO</h3><h3 id="2-2-mmap-write"><a href="#2-2-mmap-write" class="headerlink" title="2.2 mmap + write"></a>2.2 mmap + write</h3><h3 id="2-3-sendfile"><a href="#2-3-sendfile" class="headerlink" title="2.3 sendfile"></a>2.3 sendfile</h3><h3 id="2-4-splice"><a href="#2-4-splice" class="headerlink" title="2.4 splice"></a>2.4 splice</h3><h3 id="2-5-sockmap"><a href="#2-5-sockmap" class="headerlink" title="2.5 sockmap"></a>2.5 sockmap</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>future explained(3)</title>
    <link href="/2021/11/24/rust/futures/future-explained3/"/>
    <url>/2021/11/24/rust/futures/future-explained3/</url>
    
    <content type="html"><![CDATA[<p>withoutboats 是 Rust 异步的主要负责人，他在一次分享中详细描述了 Pin 的演变过程和背后的心路历程</p><h2 id="1-Future-模式引入"><a href="#1-Future-模式引入" class="headerlink" title="1. Future 模式引入"></a>1. Future 模式引入</h2><p>在 Rust 之前的很多语言，绝大多数选择了回调机制实现的异步逻辑，比如C语言中的 libevent，再还有 nodejs 中的 callback。<br>首先在 Rust 中，你很难写出 <code>nodejs</code> 那种回调模式的异步代码，下面是一小段典型的 <code>nodejs</code> 回调模型</p><figure class="highlight rust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_foos</span></span>(client: Client) -&gt; <span class="hljs-keyword">impl</span> Future&lt;Output = <span class="hljs-built_in">Vec</span>&lt;Response&gt;&gt;&#123;<br>    client.get_index(<span class="hljs-string">&quot;/foos&quot;</span>).and_then(|index|&#123;<br>        client.get_responses(&amp;index).collect()<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Rust 中，且不说回调地狱问题，关键是这种写法 <strong>根 本 编 译 不 过!</strong></p><p>这段代码，在 Rust 中存在很严重的所有权和生命周期问题，你会得到各种各样的编译错误。根据 rustc 的提示，缝缝补补，你或许会用下面这种方式去处理，也确实可以编译，但也仅此而已。且不说为了编译通过而付出的努力，单单是 Arc 和 Mutex 带来的额外开销，也是无法接受的。当创建大型程序时，简直无法想象。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_foos</span></span>(client: Client) -&gt; <span class="hljs-keyword">impl</span> Future&lt;Output = <span class="hljs-built_in">Vec</span>&lt;Response&gt;&gt;&#123;<br>    <span class="hljs-keyword">let</span> client: Arc&lt;Mutex&lt;Client&gt;&gt; = Arc::new(Mutex::new(Client));<br>    <span class="hljs-keyword">let</span> client2 = client.clone();<br><br>    client.lock().unwrap().get_index(<span class="hljs-string">&quot;/foos&quot;</span>).and_then(<span class="hljs-keyword">move</span> |index|&#123;<br>        client2.lock().unwrap().get_responses(&amp;index).collect()<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，Rust 团队进行设计了一套基于 Future 的 API，提出了 async/await 这组关键字，将异步代码转换成同步模型，这不仅回避了上面的所有权问题，还更加符合人体工程学。</p><p>这种写法非常接近 <code>blocking io</code>，程序员能轻易看出执行的逻辑，却能够以异步的方式运行，这主要归功于 Rust 编译器对于 async 代码块的高级抽象，async block 会被翻译成一个<strong>状态机 GenFuture</strong>（匿名结构体），并且其中任何跨越 await 代码块的引用，都会将被引用的变量和引用保存到当前为 async 代码块生成的状态机中，每一个 await 点都是状态的转变时机。  </p><p>这样的设计是十分优雅的，也非常有效，但是却带来了一个问题：<strong>自引用</strong> 。来看下面这个例子：  </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_foos</span></span>(client: Client) -&gt; <span class="hljs-built_in">Vec</span>&lt;Response&gt;&#123;<br>    <span class="hljs-keyword">let</span> index = client.get_index(<span class="hljs-string">&quot;/foos&quot;</span>).<span class="hljs-keyword">await</span>; <span class="hljs-comment">// State &#123; Client, &amp;mut Client&#125;</span><br>    client.get_responses(&amp;index).collect().<span class="hljs-keyword">await</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，<code>let index = client.get_index(&quot;/foos&quot;).await;</code> 存在一个跨越 await 关键字的对于 client 的引用，因此，必须要将 client 和 &amp;mut client 都保存在状态机中。（这里不去考虑手动构造的问题，需要 unsafe 代码操作裸指针才可以，编译器实现起来会轻松很多）</p><p>如果按照最原始的 Future 接口( <code>fn poll(&amp;mut self, ctx: &amp;mut Context&lt;&#39;_&gt;)</code>)，我们很轻易就能在安全代码中让 Rust 程序崩溃：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> future = get_foos(...);<br>    future.poll(...);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> future2 = get_foos(...); <span class="hljs-comment">// 为了防止 let mut future2 = future 只是一个别名，强制初始化 future2，从而下面的 future2 = future 成为一个 memcpy 操作</span><br>    future2 = future;       <span class="hljs-comment">// 自引用结构已经失效，因为 future 和 future2 都是栈上的结构</span><br>    future2.poll(...); <span class="hljs-comment">// 此时完全无法控制 poll 中是否会使用该失效的自引用 ，</span><br>                       <span class="hljs-comment">// 产生了 undefined behavior</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码存在的问题是：当 poll 一个 Future 之后，我们移动了它原本的位置，导致 Future 中的<strong>自引用结构失效</strong>。</p><p>这似乎有一点莫名其妙，深究一下根源，你会发现，这和堆、栈的特性有关。</p><p>在栈上分配的变量，如果移动了所有权，其大概率（如果不是通过别名复用这块内存的话）也会重新分配一块内存，并且原先的内存会失效。参照下图，在 <code>state2 = state1;</code> 之后，会将 state1 中的内容完完整整拷贝到 state2 中，但是 State 中的 <code>&amp;mut client</code>，还指向 state1 那块已经失效的内存，这才产生的 UB 行为</p><p><img src="/images/pin1.png" alt="pin on stack"></p><p>解决的办法很简单：堆内存分配！</p><p>如果我们在栈上只保留一个指针，指向堆上分配的 State，那么，当所有权发生转移的时候，仅仅是之前这个指针失效了，堆上的<strong>值引用结构</strong>并没有移动，也没有被释放，仍然是有效的。</p><p><img src="/images/pin1.png" alt="pin on heap"></p><p>这种模式，就好像将 State 钉(Pin)在了堆空间中，无论栈上的指针怎么移动，堆上的内存都不会受到半点影响。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> state3 = state2;<br><span class="hljs-keyword">let</span> state4 = state3; <span class="hljs-comment">// totally fine</span><br>...<br><br></code></pre></td></tr></table></figure><h2 id="2-Future-改进，Pin-引入"><a href="#2-Future-改进，Pin-引入" class="headerlink" title="2. Future 改进，Pin 引入"></a>2. Future 改进，Pin 引入</h2><p>withoutboats 作为 Rust 异步机制的主要设计者，针对原始的 Future trait 提出了几个方案：</p><h3 id="2-1-unsafe-标记"><a href="#2-1-unsafe-标记" class="headerlink" title="2.1 unsafe 标记"></a>2.1 unsafe 标记</h3><p>这个方案解决的思路是：为了使用 Future，你必须要确保 SAFETY：该 Future 一旦被 poll 之后，直到其被 Drop 都不会被移动。<br>对于分配在堆上的 future 天生就满足这一点要求，所以这主要是针对在栈上的内存而言的约束。</p><p>虽然这确实可以解决现阶段 Future 移动导致的问题，但这会带来一个不得不考虑的问题：本就不受大家欢迎的 unsafe 可能会遍布代码库！而且相当于把锅都甩给了用户，大大加重了开发人员心智负担，该方案作为针对 Future 接口的第一次改进，也就到此为止。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Future</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span>;<br><br>    <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, ctx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-Pin-的原始版本"><a href="#2-2-Pin-的原始版本" class="headerlink" title="2.2 Pin 的原始版本"></a>2.2 Pin 的原始版本</h3><p>unsafe Future Trait 的方案被 pass 之后，Rust 团队开始寻求别的解决方式，并提出了 Pin 的概念。</p><p>但 Pin 最一开始并不像现在这样简洁，其也是经历了很多设计上的改进。最一开始的设计其实长下面这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PinMut</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T);<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; PinMut&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_mut_unchecked</span></span>(<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T&#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PinBox</span></span>&lt;T&gt;(<span class="hljs-built_in">Box</span>&lt;T&gt;);<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">From</span>&lt;<span class="hljs-built_in">Box</span>&lt;T&gt;&gt; <span class="hljs-keyword">for</span> PinBox&lt;T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(b: <span class="hljs-built_in">Box</span>&lt;T&gt;) -&gt; PinBox&lt;T&gt; &#123;<br>        PinBox(b)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; PinBox&lt;T&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_mut</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T&#123;<br>        PinMut(&amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Future</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll</span></span>(<span class="hljs-keyword">self</span>: PinMut&lt;<span class="hljs-symbol">&#x27;_</span>, <span class="hljs-keyword">Self</span>&gt;, ctx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里引入了 <code>PinBox</code> 和 <code>PinMut</code> 两个概念，都是对于指针的封装，最大的不同是，如果想要通过 <code>PinMut</code> 获取到背后的指针，必须要通过非安全方法完成，而对于 <code>PinBox</code> 而言，则是可以直接在安全代码中获取 Box 背后的对象指针。  </p><p>这种封装，带来了一个很大的好处：如果想要通过 PinMut 获取背后的引用，只能通过 get_mut_unchecked 这种 unsafe 的方式，那么，当我们将 Future 的 self 类型限定为 <code>PinMut&lt;&#39;_, Self&gt;</code> 的时候，就会发现，并不是那么轻易就能获取到 <code>&amp;mut self</code> 的哦，必须要确保这个操作的 <strong>SAFETY</strong>，也就不可能在安全代码中，直接获取到 &amp;mut self，继而导致 future 中内容被轻易移动。并且，基于这两个抽象，正确性证明起来是比较容易的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> a = PinMut(&amp;<span class="hljs-keyword">mut</span> p);<br><span class="hljs-comment">// error to compile</span><br>mem::swap(a.get_mut_unchecked(),&amp;<span class="hljs-keyword">mut</span> something_else);<br><span class="hljs-comment">// ok to compile, but usage of unsafe is wrong</span><br>mem::swap(<span class="hljs-keyword">unsafe</span> &#123; a.get_mut_unchecked() &#125;,&amp;<span class="hljs-keyword">mut</span> something_else);<br><br></code></pre></td></tr></table></figure><p>这段话中还引入了一点，如果能够在安全代码中，获取到自引用结构的可变引用，也会导致 Rust 给我们做出的安全规范轰然倒塌<br>结合之前的堆、栈分配的特点，实际使用中，会先将其分配在堆上，保证不会因为 <code>let mut future2 = future1;</code> 这种语义将其移动，其次，就是遵守 PinMut 给我们的约束，保证不会获取到可变引用而移动。</p><p>相比如第一个 unsafe 提案，我们虽然免不了和 unsafe 打交道，但是已经可以得到一个非常干净的 Future 接口，调用 poll 也不需要再用 unsafe 来方式误用了，相当于是将 unsafe 逻辑转移到了内层实现中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">spawn</span></span>&lt;F: Future&gt;(f: F)&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> fut = PinBox::from(<span class="hljs-built_in">Box</span>::new(f));<br>    <br>    <span class="hljs-comment">// safe the fut to somewhere</span><br><br>    <span class="hljs-comment">// handin to the executor</span><br><br>    <span class="hljs-comment">// construct PinMut, then poll</span><br>    fut.as_mut().poll(...);<br>&#125; <br></code></pre></td></tr></table></figure><p>但即使是内层的 unsafe 逻辑，也会给开发人员带来很大的心智负担！</p><p>在上面的约束下，我们如果想要在 poll 方法中更新 self 的状态，或者调用 self 某一些 field 的方法，都要首先通过非安全代码，获取 &amp;mut Self，相当于声明：我遵守 unsafe 赋予我的一切权力，我保证不会移动 self。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AsyncIoHandle</span></span>&#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll_read</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>,buf: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-built_in">u8</span>]) -&gt;Poll&lt;<span class="hljs-built_in">usize</span>&gt;&#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IoFuture</span></span> &#123;<br>    buf: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;,<br>    file: AsyncFileHandle<br>&#125;<br><br><span class="hljs-keyword">impl</span> Future <span class="hljs-keyword">for</span> IoFuture &#123;<br>    tyep Output = <span class="hljs-built_in">usize</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll</span></span>(<span class="hljs-keyword">self</span>: PinMut&lt;<span class="hljs-symbol">&#x27;_</span>, <span class="hljs-keyword">Self</span>&gt;, x: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;&#123;<br>        <span class="hljs-comment">// wont&#x27;t compile </span><br>        <span class="hljs-comment">// self.file.poll_read(&amp;mut self.buf[..]) </span><br><br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">let</span> this: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span> = <span class="hljs-keyword">self</span>.get_mut_unchecked();<br>            this.file.poll(&amp;<span class="hljs-keyword">mut</span> this.buf[..]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种恼人的问题对于 <strong>Leaf Future</strong> 尤为严重。所谓的 <strong>Leaf Future</strong>，其实是面向底层 Io(reactor)、需要手动实现的 Future，<strong>Non-Leaf Future</strong> 就是通过 async await 自动生成的 Future，包含了下面的所有结点，non-leaf or leaf。更令人无奈的一点是，对于 99% 手动实现的 <code>Leaf Future</code>，并没有 <code>self referential</code> 的问题，仍需要使用 unsafe。  async/await 中的 <code>self referential</code> 算是解决，但又发力过猛，一棒子打死了更多的 <strong>good future</strong>。</p><p>总结一点：<strong>目前为止，通过 PinMut 和 PinBox 的抽象，已经解决了 executor 中的问题(比如需要使用 unsafe)，提供了易用的 Future::poll 接口，但是对于 reactor 仍无太好的办法。PinMut 和 PinBox 的正确性是毋庸置疑的</strong>  </p><h3 id="2-3-Unpin-的引入"><a href="#2-3-Unpin-的引入" class="headerlink" title="2.3 Unpin 的引入"></a>2.3 Unpin 的引入</h3><p>为了解决上面的问题，withoutboats 引入了 Unpin 的概念。  </p><p>Unpin 是一个 auto trait，Rust 默认为所有结构都添加了这个标记 Trait（像 Send 和 Sync），但是，如果一个结构包含了 !Unpin 的字段，那么其自身也是 !Unpin（ !Unpin 属性会传播），几乎唯一的 !Unpin 结构就是编译器为 async 代码块生成的 GenFuture。其余所有的基础结构，包括 i32, usize 都是 Unpin 的结构，比较特殊的是对于复杂的自引用结构的指针。  </p><p>对于内部包含了 Unpin 结构的 PinMut，只需要为其实现 DerefMut 方法，就可以直接获取到 &amp;mut T，PinMut&lt;’a,T&gt; 和 &amp;mut T，也就不需要烦人的 unsafe 了! 乌拉！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> auto <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Unpin</span></span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: Unpin + ?<span class="hljs-built_in">Sized</span>&gt; DerefMut <span class="hljs-keyword">for</span> PinMut&lt;<span class="hljs-symbol">&#x27;a</span>,T&gt;&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Target</span></span> = T;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>) -&gt; &amp;<span class="hljs-keyword">mut</span> Self::Target&#123;<br>        ...<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-4-最终方案-Pin"><a href="#2-4-最终方案-Pin" class="headerlink" title="2.4 最终方案 Pin"></a>2.4 最终方案 Pin</h3><p>最终引入标准库的方案并不是上面的 PinMut + PinBox，而是更加简洁的一个统一接口： <strong>Pin</strong>  </p><p>Pin 也是一个智能指针，内层包装了一个指针，针对内部不同的指针类型，实现了不同的 trait。</p><p>标准库中有下面几个关键的函数，都对它们做了注解：  </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pin</span></span>&lt;P&gt;&#123;<br>    pointer: P<br>&#125;<br><br><span class="hljs-comment">// 直接通过裸指针创建 Pin 是不安全的，使用者必须要确保，这个指针是有效的!</span><br><span class="hljs-keyword">impl</span> Deref&lt;P: Deref&gt; Pin&lt;P&gt;&#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new_unchecked</span></span>(pointer: P) -&gt; Pin&lt;P&gt; &#123;<br>        Pin &#123; pointer &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 同理，将 Pin 转换成内部的裸指针，也是不安全的!</span><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, P&gt; Pin&lt;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> P&gt;&#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_unchecked_mut</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> P &#123;<br>        <span class="hljs-keyword">self</span>.pointer<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Target::Unpin 的指针 P，可以安全获取 &amp;mut P::Target</span><br><span class="hljs-keyword">impl</span>&lt;P: DerefMut&lt;Target: Unpin&gt;&gt; <span class="hljs-keyword">for</span> Pin&lt;P&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-keyword">mut</span> P::Target &#123;<br>        Pin::get_mut(Pin::as_mut(<span class="hljs-keyword">self</span>))<br>    &#125; <br>&#125;<br><br><span class="hljs-comment">// 如果要从 Pin&lt;P&gt; 创建出 Pin&lt;&amp;&#x27;a mut P::Target&gt;，还是可以办到的</span><br><span class="hljs-comment">// 因为 Pin 始终有这个指针的所有权，所以不需要担心会出现 UB 行为</span><br><span class="hljs-keyword">impl</span>&lt;P: DereMut&gt; Pin&lt;P&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_mut</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; Pin&lt;&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> P::Target&gt; &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123; Pin::new_unchecked(&amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span>.pointer) &#125;<br>    &#125;<br>&#125; <br><br><span class="hljs-comment">// 从 Box 创建 Pin 本身就是安全的，因为 Box 实现了 Unpin</span><br><span class="hljs-keyword">impl</span>&lt;P&gt; <span class="hljs-built_in">From</span>&lt;<span class="hljs-built_in">Box</span>&lt;P&gt;&gt; <span class="hljs-keyword">for</span> Pin&lt;<span class="hljs-built_in">Box</span>&lt;P&gt;&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(b: <span class="hljs-built_in">Box</span>&lt;P&gt;) -&gt; Pin&lt;<span class="hljs-built_in">Box</span>&lt;P&gt;&gt;&#123;<br>         <span class="hljs-keyword">unsafe</span> &#123; Pin::new_unchecked(b) &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码可能有一点绕，但是核心关注点就两个</p><ol><li>对于实现了 Deref 类型的 P，是否可以安全地获取到内层的这个 pointer</li><li>对于实现了 Deref 类型的 P，是否可以安全地获取内层 pointer 指针指向的对象</li></ol><p>始终要牢记 Pin 的使命：需要确保 Rust 中 async/await 代码中的自引用结构有效，不能在 safe code 中 crash Rust 的强安全保证。<strong>这段代码其实是有问题的，后面会提到</strong>。</p><p>目前的 Pin 的设计，最核心的 API 是 get_unchecked_mut，这里的 <strong>SAFETY</strong> 保障是：如果 <code>&lt;P as DerefMut&gt;::Target</code> 是 Unpin，那么无法通过安全手段得到其可变引用，否则就可能移动其内容，导致自引用失效（99%的Unpin都发生在自引用结构上）</p><p>结合上面的 Unpin 概念，我们可以针对基本类型和自引用结构分别探讨一下合理性。</p><p>基本类型是 Unpin 的，因此可以通过 <code>Pin::new</code> 创建，也可以通过 <code>b.get_mut()</code> 获取可变引用，跟普通使用指针没有任何区别</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> b = Pin::new(&amp;<span class="hljs-keyword">mut</span> a);<br><span class="hljs-keyword">let</span> c = b.get_mut();<br></code></pre></td></tr></table></figure><p>接来下考虑 Pin 在 async/await 这种自引用结构上的运用（前提是已经分配在堆上了）。为什么对于一个 <code>Box&lt;impl Future&lt;...&gt;&gt;</code>，我们不应该安全的获取代码块的可变引用？</p><p>换句话说，如果我们可以安全地获取，可能会怎样违背 Rust 的安全准则？  </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> a = <span class="hljs-built_in">Box</span>::new(<span class="hljs-keyword">async</span> &#123;&#125;); <span class="hljs-comment">// a is pined on the heap, but &lt;A as DerefMut&gt;::Target is still Unpin</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> b = <span class="hljs-keyword">unsafe</span> &#123; Pin::new_unchecked(a) &#125;;<br><span class="hljs-keyword">let</span> c = b.as_mut();<br><span class="hljs-comment">// let d = c.get_unchecked_mut();</span><br><span class="hljs-keyword">let</span> d = <span class="hljs-keyword">unsafe</span> &#123; c.get_unchecked_mut() &#125;;<br><br></code></pre></td></tr></table></figure><p>如果可以安全获取到 &amp;mut GenFuture，一旦在两次 poll 之间，被不知情的用户通过 <code>mem::swap()</code> 等手段将其移动出去，就会导致自引用结构失效 💥 。因此，<code>Pin::get_mut_unchecked()</code> 需要通过 unsafe 来让用户自己做出保证。</p><p>前面我们也提到，如果想要通过 <code>Pin::new()</code> 这种方式安全地构造 Pin，需要保障 <code>&lt;P as DerefMut&gt;::Target: Unpin</code>，对于 Future 来说，也就只能用 Box 包装两层，第一次是对内部 Future 的 Box，第二次是对指向 <code>async &#123;&#125;</code> 的指针的 Box，然后我们也可以通过 <code>b.as_mut().get_mut()</code> 的方式安全地获取到 <code>&amp;mut Box&lt;...&gt;</code>，WOW！我们可以移动里面的结构了耶！那么 Rust 崩了吗？就这？</p><p>等等，别高兴太早，注意到 Future::poll 的方法签名，要求被 poll 的 future 必须要被 Pin 保护起来，我们这里再怎么移动 Box 里面的 Future，都不可能影响 Future::poll。一个 Box 压根就无法被 poll</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> a = <span class="hljs-built_in">Box</span>::new(<span class="hljs-built_in">Box</span>::new(<span class="hljs-keyword">async</span> &#123;&#125;));<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> b = Pin::new(a);<br><span class="hljs-keyword">let</span> c = b.as_mut().get_mut();<br></code></pre></td></tr></table></figure><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>使用 Pin 主要是为了避免自引用 Future 的移动问题，核心会关注两点：</p><ol><li>是否分配在堆上</li><li>在给出了 Pin&lt;&amp;mut Self&gt; 之后，是否能安全地获取到 &amp;mut Self</li></ol><p>前者面向 executor，后者面向 reactor  </p><h3 id="3-1-第一个问题，Heap-or-Stack"><a href="#3-1-第一个问题，Heap-or-Stack" class="headerlink" title="3.1 第一个问题，Heap or Stack?"></a>3.1 第一个问题，Heap or Stack?</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 1. Pin to the heap </span><br><br><span class="hljs-comment">// Box::pin(future) : Pin&lt;Box&lt;T&gt;&gt;</span><br><span class="hljs-comment">// for example</span><br><span class="hljs-keyword">let</span> a: Pin&lt;<span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Future&gt;&gt; = <span class="hljs-built_in">Box</span>::pin(future);<br><br><span class="hljs-comment">// 2. Pin to the stack</span><br><br><span class="hljs-keyword">let</span> f: <span class="hljs-keyword">impl</span> Future = <span class="hljs-keyword">async</span> &#123;&#125;;<br><span class="hljs-comment">// pin-utils crate</span><br>pin_utils:pin_mut!(f);<br>f: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">impl</span> Future&lt;..&gt;&gt;;<br></code></pre></td></tr></table></figure><p>对于一个分配在堆上的 Future 来说，当然可以随意”移动”，这里的移动指的是，<code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code> 这个结构的所有权不管如何转移，该 Future 的内存一直(Pin)在堆上，直到 Box 被 Drop 才会被释放，比如下面的例子中，a 首先被 poll，不管之后所有权如何转移，改变的也只是栈上的指针位置，该 <code>Box&lt;dyn Future&gt;</code> 的内容仍然在堆上，因而自引用也是有效的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>()&#123;&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-built_in">Box</span>::pin(aysnc&#123; bar().<span class="hljs-keyword">await</span>; <span class="hljs-number">1</span>&#125;);<br>a.poll(...);<br><span class="hljs-keyword">let</span> b = a;<br><span class="hljs-keyword">let</span> c = b;<br><span class="hljs-comment">// 仍然是有效的</span><br>c.poll(...);<br></code></pre></td></tr></table></figure><p>对于一个分配在栈上的 Future 来说，如果我们想要手动 Poll 这个 Future，也需要将其 Pin 住，才能满足 <code>poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#39;_&gt;)</code> 的方法签名，有两种方式可以实现：</p><ol><li>通过 unsafe 代码，<code>Pin::new_unchecked(&amp;mut a)</code></li><li>通过 pin-utils 这个 crate 提供的 pin_mut! 宏来解决  </li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>()&#123;&#125;<br><br><span class="hljs-comment">// 1. unsafe 实现，需要手动保证 a 不被 move</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> a = bar();<br><span class="hljs-keyword">let</span> f = <span class="hljs-keyword">unsafe</span> &#123; Pin::new_unchecked(&amp;<span class="hljs-keyword">mut</span> a) &#125;;<br>f.poll(...);<br><span class="hljs-keyword">let</span> c = a;<br>f.poll(..); <span class="hljs-comment">// BOM!</span><br><br><span class="hljs-comment">// 2. pin_mut 宏实现，更加 clever 的方式，回避了 a 被 move 的可能</span><br><span class="hljs-keyword">let</span> a = bar(); <span class="hljs-comment">// a 是分配在栈上的</span><br>pin_mut!(a);  <span class="hljs-comment">// a now is Pin&lt;&amp;mut impl Future&lt;Output=()&gt;&gt;</span><br>a.poll(...)<br><br></code></pre></td></tr></table></figure><p>显然，对于栈上的 GenFuture 来说，仅仅是 <code>let c = a</code> 这种转移所有权的方式，也会让 Pin&lt;&amp;mut …&gt; 失效，栈上的 Future 一旦已经 poll，根本无法在线程间转移，更别提调度了，只有在没有堆内存分配的嵌入式系统中，才会实现特殊的 runtime，保证一定在特定的 Stack 上去 poll 这个已经 Pin 住的 Future。因为一旦离开了这个执行栈，这个 Future 也就失效了。而第二种方式中的 pin_mut!，由于 Rust 卫生宏的特性，将变量 a 覆盖了，就无法通过除非安全代码之外的方式获取到 <code>&amp;mut a</code>，从而保证安全性。</p><p>对比了 <code>Box::pin 和 pin_mut!</code>，我们可以得出下面的结论：</p><ul><li>当需要返回一个 Box，或者要将一个 Future 保存在结构体中，需要用 <code>Box::pin</code></li><li>当目的是在某个函数中使用 Future，更应该用上 pin_mut!，可以节省 heap allocation 的开销</li></ul><p>这里必须要补充一个知识点，也就是 Future 的两种执行方式:</p><ol><li>runtime::spawn(future)   – 顶层 Future</li><li>future.await                       – 交给 parent Future 执行</li></ol><p>第一种方式中，runtime 会首先对顶层的 Future 做一次堆分配，我们就叫它 root Future，无论 root Future 是否是 Unpin 的，<code>Box&lt;dyn Future&gt;</code> 一定实现了 Unpin，就可以交给 executor 安全地执行 poll 了</p><p>第二种方式中，该 Future 会被 parent Future(async) <strong>感知</strong>，在被 grand parent 感知…，到最后也一定是通过runtime::spawn 来执行的。如果将其视为一颗 Future 树，内部所有的子孙 Future 都会复用 root Future 分配的空间，也就是 spawn 中一次性分配在堆上的空间。</p><h3 id="3-2-第二个问题，获取-amp-mut-Self"><a href="#3-2-第二个问题，获取-amp-mut-Self" class="headerlink" title="3.2 第二个问题，获取 &amp;mut Self"></a>3.2 第二个问题，获取 &amp;mut Self</h3><p>针对 async/await 得到的 <code>Pin&lt;&amp;mut Future&gt;</code>，Pin 可以确保不会在安全代码中得到 <code>&amp;mut Future</code>，从而被滥用；针对手动实现、没有自引用结构的、面向底层 reactor 的 Future，则可以没有任何代价地获取到 <code>&amp;mut Future</code>。</p><p>针对 executor 和 reactor，有两种不同的 Future，async/await 是 high-level，面向 executor 的 Future，手动实现的是 low-level，面向系统的 Future。只有前者会导致自引用问题，但是 Rust 团队花了这么多精力去修补完善，这才拿出了这个比较好用的 API，如果不了解这些，完全没有办法想象，居然有这么多考量的因素。</p>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
      <category>async</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>future explained(2)</title>
    <link href="/2021/11/24/rust/futures/future-explained2/"/>
    <url>/2021/11/24/rust/futures/future-explained2/</url>
    
    <content type="html"><![CDATA[<p>前面提到了，future 其实分为 Non-Leaf-Future 和 Leaf-Future，前者由 async/await 生成，后者由开发者手动对接系统 Io。</p><p>那么为什么会出现 self referential 的问题呢？</p><p>其实主要的原因出现在 async/await 生成的 Non-Leaf-Future 上！</p><p>试想下面的这段代码</p><figure class="highlight rust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test</span></span>()&#123;<br>   <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> a = [<span class="hljs-number">1024</span>; <span class="hljs-built_in">u8</span>];<br>   <span class="hljs-keyword">let</span> f1 = read_to_string(&amp;<span class="hljs-keyword">mut</span> a).<span class="hljs-keyword">await</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果将其翻译为状态机，大致会是下面这个结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestFuture</span></span>&#123;<br>    Start(Start),<br>    State1(State1),<br>    Done,<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Start</span></span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">State1</span></span>&lt;<span class="hljs-symbol">&#x27;self</span>&gt;&#123;<br>    a: [<span class="hljs-number">1024</span>; <span class="hljs-built_in">u8</span>],<br>    ref_a: &amp;<span class="hljs-symbol">&#x27;self</span> <span class="hljs-keyword">mut</span> [<span class="hljs-number">1024</span>; <span class="hljs-built_in">u8</span>],<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Done</span></span>;<br></code></pre></td></tr></table></figure><p>由于需要用一个闭包来保存上下文中的变量，这里用到了 &amp;mut a，跨越了 await 点，所以既需要将原先的这个数组 a 保存下来，也需要将其引用保存下来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">Tips:<br>  跨越 await 点的引用，既需要保存被引用的结构（owner），也需要保存该引用。这是因为，我们需要始终保证引用指向的内容是有效的！<br></code></pre></td></tr></table></figure><p>可惜的是，上面这段代码只能是我们的一厢情愿！实际中，我们根本无法构造出 State1 这种结构！</p><p>这是因为 Rust 严格的所有权机制导致的，我们已经有了 TestFuture 结构的可变引用，就无法再将一个可变引用 ref_a 指向其自身的一个结构。那么 Rust 编译器是怎么做的呢？</p><p>嘿嘿，Rust 代码都是 Rustc 编译生成的，编译器自然有办法：所谓的引用，也不过是受到特殊约束的指针罢了，在确保安全的情况下，使用一个裸指针代替，效果完全相同！</p><p>也就是说，编译器实际上为我们生成了下面的结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">State1</span></span>&#123;<br>    a: [<span class="hljs-number">1024</span>; <span class="hljs-built_in">u8</span>],<br>    ref_a: *<span class="hljs-keyword">const</span> [<span class="hljs-number">1024</span>; <span class="hljs-built_in">u8</span>],<br>&#125;<br><br></code></pre></td></tr></table></figure><p>而该结构体，通过一个 new 函数是无法直接构造的，只有在确定了其<strong>在栈上的位置</strong>之后，才能通过 init 方法初始化其 ref_a 字段。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">State1</span></span> &#123;<br>    a: [<span class="hljs-number">1024</span>; <span class="hljs-built_in">u8</span>],<br>    b: *<span class="hljs-keyword">const</span> [<span class="hljs-number">1024</span>; <span class="hljs-built_in">u8</span>],<br>&#125;<br><br><span class="hljs-keyword">impl</span> State1 &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>() -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        State1 &#123;<br>            a: [<span class="hljs-number">1024</span>; <span class="hljs-built_in">u8</span>],<br>            ref_a: std::ptr::null(),<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">init</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> self_ref: *<span class="hljs-keyword">const</span> [<span class="hljs-number">1024</span>; <span class="hljs-built_in">u8</span>] = &amp;<span class="hljs-keyword">self</span>.a;<br>        <span class="hljs-keyword">self</span>.ref_a = self_ref;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面强调了一点：<strong>在栈上的位置</strong>。因为如果 ref_a 指向的是栈上的内存，一旦 State1 在栈上移动，比如拷贝到另一块区域，这个指针就会失效。相反，如果其分配在堆上，就不容易出现这个问题，因为只要这个堆内存没有释放，就不会被移动！</p>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
      <category>async</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>future explained(1)</title>
    <link href="/2021/11/24/rust/futures/future-explained1/"/>
    <url>/2021/11/24/rust/futures/future-explained1/</url>
    
    <content type="html"><![CDATA[<p>在<a href="#">Post not found: rust/future-explained0 上一篇文章</a>中，我们深入分析了 async/await 状态机的底层实现，接下我们就可以进一步探究，Rust 中的 Future ，以及为什么会出现 自引用结构。</p><h2 id="1-Future-是什么"><a href="#1-Future-是什么" class="headerlink" title="1. Future 是什么"></a>1. Future 是什么</h2><p>在浏览本节之前，希望你可以大致了解一下 Future 设计思想的演进过程，比如 javascript 中的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a></p><p>那么 Rust 中的 Future 是什么？</p><p>Future 是一些将<strong>在未来完成</strong>操作的表示。</p><p>Rust 中的异步机制使用的是基于<strong>轮询</strong>（Poll）的方法，一个异步任务会有三个阶段。</p><ol><li><strong>轮询阶段</strong>。 对一个 Future 进行轮询，推进其向前执行，直到不能再执行下去（被阻塞）。我们常把运行时中对 Future 进行轮询的部分称为执行器（executor）。</li><li><strong>等待阶段</strong>。 一个事件源，最常被称为反应器（reactor），它注册一个 Future 正在等待一个事件的发生，并确保在该事件准备好时，它将唤醒 Future。</li><li><strong>唤醒阶段</strong>。 事件发生了，Future 被唤醒了。现在，在第 1 步中轮询 Future 的执行器要安排 Future 再次被轮询，并继续推进其执行，直到它完成或达到一个新的阻塞点，重复这个循环。</li></ol><p>你可能对上面的一些术语不是很清楚，接下来我会慢慢解释。</p><h3 id="1-1-Executor"><a href="#1-1-Executor" class="headerlink" title="1.1 Executor"></a>1.1 Executor</h3><p>首先，你可以大致将 executor 看成是 <code>future queue + poll loop</code>，它的任务就是不断从 future 队列中取出 future，然后执行 poll 方法。一个最简单的 executor 其实很简单，基本上等同于一个 loop 循环。但是如果想要高效地进行调度，那就需要利用到很多策略了。</p><figure class="highlight rust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">loop</span> &#123;<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(f) = receiver.recv() &#123;<br>        f.poll(...);<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-Reactor"><a href="#1-2-Reactor" class="headerlink" title="1.2 Reactor"></a>1.2 Reactor</h3><p>有了 executor 还不够，因为一个应用，终归是要和底层 IO 打交道的（纯计算应用勿Q），如果 executor 很高效，但是 Io 效率很低，那么 Io 就会成为应用的性能瓶颈。</p><p>系统层面的 Io，大致可以按照 同步/异步，阻塞/非阻塞 分为几种模型：</p><ol><li>同步阻塞</li><li>同步非阻塞</li><li>异步阻塞</li><li>异步非阻塞</li></ol><p>目前各个操作系统的底层，几乎都采用了事件驱动的 IO 多路复用模型，在 Linux 上是 epoll，而在 windows 和 macOS 这种成熟的系统上，也分别有 iocp 和 kqueue。它们本质上做了这件事：当某一次操作依赖于某些资源的时候，需要向操作系统<strong>注册</strong>，告诉系统：等这个资源准备好之后，再来通知我，否则将我挂起。</p><p>因此可以做一个跨平台的抽象：<strong>reactor</strong>。含义是：当事件发生的时候，对此做出反应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">Tips:<br>  其实系统的阻塞 API 也是完成了这件事情，比如 socket 默认就是阻塞的模型，当 accept 一个 socket 的时候，整个进程都有可能陷入阻  塞状态，造成当前进程无法充分利用 CPU。但是 epoll 这种 IO 多路复用的模型，其实可以通过一个红黑树，高效地帮助我们监听多个文件描  述符，每次从内核返回，会将所有的 ready 状态的描述符都返回给用户，达到了 batch 操作的效果。<br></code></pre></td></tr></table></figure><h3 id="1-3-executor-reactor"><a href="#1-3-executor-reactor" class="headerlink" title="1.3 executor + reactor"></a>1.3 executor + reactor</h3><p>当我们将 executor 和 reactor 组合在一起，一个 runtime 框架就已经成型了。因为一个应用，要么在耗费 CPU 计算，要么在等待 Io 操作（资源）。</p><p>可以想象，如果是一个既涉及 CPU 计算，也要涉及底层 IO 的 future，其实会不断地在 executor 和 reactor 之间<strong>轮转</strong>：需要计算时，交给 executor 执行，需要 IO 的时候，交给 reactor，由 reactor 负责事件通知，资源准备好了之后，又交给 executor 执行，循环往复，直到该 future 执行完毕。</p><h2 id="2-Leaf-Future-VS-Non-Leaf-Future"><a href="#2-Leaf-Future-VS-Non-Leaf-Future" class="headerlink" title="2. Leaf Future VS Non-Leaf Future"></a>2. Leaf Future VS Non-Leaf Future</h2><p>上面提到，future 可以区分为 <code>CPU/IO</code> 两种类型，那么反映在其创建方式上，又是什么样的呢？</p><p>future 有两种实现方式，一种是手动为某一个类型实现 <code>Future trait</code>，另一种是通过 async/await 关键字创建，分别对应 Leaf-future 和 Non-leaf-future（第二小节会解释为什么这样取名）。</p><h3 id="2-1-叶子-Futures"><a href="#2-1-叶子-Futures" class="headerlink" title="2.1 叶子 Futures"></a>2.1 叶子 Futures</h3><p>先来看 Leaf Futures，它们代表系统中的 IO 资源，比如 socket，file，timer。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// stream is a leaf-future</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = tokio::net::TcpStream::connect(<span class="hljs-string">&quot;127.0.0.1:3000&quot;</span>);<br></code></pre></td></tr></table></figure><p>对 IO 资源的操作，比如对 socket 的 Read 将是非阻塞的，并返回一个 future，称之为叶子 future。之所以要求非阻塞，是因为只有这样，才能将所有权牢牢抓在用户态的 runtime 手里，否则一旦阻塞，当前进程就会被操作系统调度出去，效率就降低了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">Tips:<br>  除非你要写一个 runtime，否则你不太可能自己实现一个叶子 Future，或者更多的是针对 Leaf-Future 的封装。<br></code></pre></td></tr></table></figure><h3 id="2-2-非叶子-Futures"><a href="#2-2-非叶子-Futures" class="headerlink" title="2.2 非叶子 Futures"></a>2.2 非叶子 Futures</h3><p>Non-leaf-futures 是指作为 runtime 的用户，使用 async 关键字自己编写的 Future，用于创建一个可以在执行器上运行的任务。</p><p>一个异步程序大部分由非叶子 Futures 组成，它是一种可暂停的计算。这是一个重要的区别，因为这些 Futures 代表了一组操作。通常，这样的任务会等待（await）一个叶子 Future 作为完成任务的许多操作之一。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Non-leaf-future</span><br><span class="hljs-keyword">let</span> non_leaf = <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = TcpStream::connect(<span class="hljs-string">&quot;127.0.0.1:3000&quot;</span>).<span class="hljs-keyword">await</span>.unwrap();<span class="hljs-comment">// &lt;- yield</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;connected!&quot;</span>);<br>    <span class="hljs-keyword">let</span> result = stream.write(<span class="hljs-string">b&quot;hello world\n&quot;</span>).<span class="hljs-keyword">await</span>; <span class="hljs-comment">// &lt;- yield</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;message sent!&quot;</span>);<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-async-状态机"><a href="#3-async-状态机" class="headerlink" title="3. async 状态机"></a>3. async 状态机</h2><p> <a href="./state-machine.md">之前的文章</a>已经详细解释了 async/await 的实现原理，本质上是一个状态机。</p><p>一个 Future 在某个时刻只会都只有唯一的状态，因此，可以用 enum 表示，为每一个可能存在的状态，都生成一个对应的 State，比如下面的 <code>AsyncState</code>，这样，我们只需要为 future 分配状态最大需要占用的内存，其余的状态下，都可以复用这块空间。理论上来说，这是最高效的模型了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">root_future</span></span>()&#123;<br>    <span class="hljs-keyword">let</span> fut_one = <span class="hljs-comment">/* ... */</span>;<br>    <span class="hljs-keyword">let</span> fut_two = <span class="hljs-comment">/* ... */</span>;<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123;<br>        fut_one.<span class="hljs-keyword">await</span>;<br>        fut_two.<span class="hljs-keyword">await</span>;<br>    &#125;.<span class="hljs-keyword">await</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// The `Future` type generated by our `async &#123; ... &#125;` block</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AsyncFuture</span></span> &#123;<br>    fut_one: FutOne,<br>    fut_two: FutTwo,<br>    state: AsyncState,<br>&#125;<br><br><span class="hljs-comment">// List of states our `async` block can be in</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AsyncState</span></span> &#123;<br>    AwaitingFutOne,<br>    AwaitingFutTwo,<br>    Done,<br>&#125;<br><br><span class="hljs-keyword">impl</span> Future <span class="hljs-keyword">for</span> AsyncFuture &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = ();<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll</span></span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;()&gt; &#123;<br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.state &#123;<br>                AsyncState::AwaitingFutOne =&gt; <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.fut_one.poll(..) &#123;<br>                    Poll::Ready(()) =&gt; <span class="hljs-keyword">self</span>.state = AsyncState::AwaitingFutTwo,<br>                    Poll::Pending =&gt; <span class="hljs-keyword">return</span> Poll::Pending,<br>                &#125;<br>                AsyncState::AwaitingFutTwo =&gt; <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.fut_two.poll(..) &#123;<br>                    Poll::Ready(()) =&gt; <span class="hljs-keyword">self</span>.state = AsyncState::Done,<br>                    Poll::Pending =&gt; <span class="hljs-keyword">return</span> Poll::Pending,<br>                &#125;<br>                AsyncState::Done =&gt; <span class="hljs-keyword">return</span> Poll::Ready(()),<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>之前提到了 Leaf-Future 和 Non-leaf-Future，大家可能有一点困惑，为什么要这样命名？</p><p>如果将 future 看成是一个树状结构，答案就很明了了。一个 future 内部会包含多个 child future，每一个 child future 可能也有自己的 child …，直到最后的 left future，不会再有其叶子结点了。</p><p>poll 一个 future，其实就是在遍历这颗 future 树，交给 executor 执行的其实是整个 future 树，而编译器早就根据  async/await 帮我们构造好了树的遍历路径（状态匹配），但是涉及到底层 Io 的时候，一定是交给程序员完成的。</p>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
      <category>async</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>future explained(0)</title>
    <link href="/2021/11/24/rust/futures/future-explained0/"/>
    <url>/2021/11/24/rust/futures/future-explained0/</url>
    
    <content type="html"><![CDATA[<p>generator（生成器）是 Rust 中 async/await 的基础，state machine 又是生成器的基础。</p><p>和闭包类似，不同的编译器会给 generator 生成不同的语义。但有一点是约定俗成的，也就是生成器最大的特点：程序的执行流程可以在生成器和调用者之间来回切换。</p><p>当我们需要暂时从生成器中返回的时候，可以使用 yield 关键字，当调用者希望再次进入生成器的时候，就调用 resume 方法，这时程序就从上次 yield 返回的那个点之后继续执行，还能获取到上下文信息，就好像能够按下了暂停按钮，又按下了继续按钮，程序执行完全没有感知。</p><p>其实不仅仅是 Rust，LLVM 作为一个广泛使用的后端，也支持了 yield 语法（因此 c++ 最新版本也可以实现 stackless 协程了）。接下来我们就分别探究一下二者实现的思路，以求对于 async/await 有一个更加深入的认识。</p><h2 id="1-LLVM-实现"><a href="#1-LLVM-实现" class="headerlink" title="1. LLVM 实现"></a>1. LLVM 实现</h2><p>首先来看 LLVM 支持的方式：通过 <code>generator + yield</code> 两个关键字，可以将原先的一个普通函数，改写为生成器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function">generator <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    yield <span class="hljs-number">1</span>;<br>    yield <span class="hljs-number">2</span>;<br>    yield <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    foreach (<span class="hljs-keyword">int</span> i in <span class="hljs-built_in">foo</span>())<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value: %d\n&quot;</span>, i);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们希望的执行流是：</p><ol><li>下一次重新执行该 generator，可以从上一次 yield 点开始执行</li><li>可以保存栈的上下文</li></ol><p>可以想象，我们需要保存很多<strong>状态</strong>，比如必须要 yield 的位置，这样才能在 resume 的时候执行正确位置的代码。Where? What?</p><ol><li><p>我们肯定不会将状态保存在<strong>函数栈帧</strong>中，因为一旦函数返回，该栈帧中的所有局部变量都失效了。也就是说，必须要将上下文（context）保存在函数外的某个结构体内（static 局部变量也不行，因为如果重复调用就炸了）。</p></li><li><p>接下来考虑，需要保存什么样的状态，才能保证对于执行流和上下文没有感知？</p><ul><li>为了从 yield 下一条指令开始执行，肯定需要保存该指令的地址；</li><li>为了保证栈帧中的局部变量不会失效，一定要将其保存存在调用栈之外的某个结构中（其实就是闭包）</li></ul></li></ol><p>实际上 LLVM 正是这样做的，通过 context 保存下一次 resume 需要跳转执行的位置，以及调用栈中的局部变量。每次调用这个 generator，都需要从外部传入相应的 context 上下文变量，将某些局部变量的读写都映射为针对 context 中相应字段的读写。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Tips:<br>  上下文变量还需要一个特殊的 setup 函数来处理，每一个 generator 都唯一对应 context，从而保证状态的确定性。<br></code></pre></td></tr></table></figure><p>来简单看一下 LLVM 生成的 IR，围绕着 context 这个最关键的<strong>Generator 状态</strong>展开，关键位置都做了标记。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs llvm">// 上下文（状态）<br><span class="hljs-variable">%foo_context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">type</span> &#123;<br>    <span class="hljs-type">i8</span>*<span class="hljs-punctuation">,</span>      <span class="hljs-comment">; 0: block (pc 指针位置)    </span><br>    <span class="hljs-type">i32</span>       <span class="hljs-comment">; 1: value (result) </span><br>&#125;<br><br>// foo 初始化，必须在调用 foo 之前设置<br><span class="hljs-keyword">define</span> void <span class="hljs-title">@foo_setup</span>(<span class="hljs-variable">%foo_context</span>* <span class="hljs-variable">%context</span>) <span class="hljs-keyword">nounwind</span> &#123;<br>    <span class="hljs-comment">; set up &#x27;block&#x27;</span><br>    <span class="hljs-variable">%1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">getelementptr</span> <span class="hljs-variable">%foo_context</span>* <span class="hljs-variable">%context</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">store</span> <span class="hljs-type">i8</span>* <span class="hljs-keyword">blockaddress</span>(<span class="hljs-title">@foo_yield</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%.yield1</span>)<span class="hljs-punctuation">,</span> <span class="hljs-type">i8</span>** <span class="hljs-variable">%1</span><br><br>    <span class="hljs-keyword">ret</span> void<br>&#125;<br><br><span class="hljs-comment">; The boolean returned indicates if a result was available or not.</span><br><span class="hljs-comment">; Once no more results are available, the caller is expected to not call</span><br><span class="hljs-comment">; the iterator again.</span><br><span class="hljs-keyword">define</span> <span class="hljs-type">i1</span> <span class="hljs-title">@foo_yield</span>(<span class="hljs-variable">%foo_context</span>* <span class="hljs-variable">%context</span>) <span class="hljs-keyword">nounwind</span> &#123;<br>    <span class="hljs-comment">; 将 context.state 中的值作为下标，跳转到对应的位置</span><br>    <span class="hljs-variable">%1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">getelementptr</span> <span class="hljs-variable">%foo_context</span>* <span class="hljs-variable">%context</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-number">0</span><br>    <span class="hljs-variable">%2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">load</span> <span class="hljs-type">i8</span>** <span class="hljs-variable">%1</span><br>    <span class="hljs-keyword">indirectbr</span> <span class="hljs-type">i8</span>* <span class="hljs-variable">%2</span><span class="hljs-punctuation">,</span> [ label <span class="hljs-variable">%.yield1</span><span class="hljs-punctuation">,</span> label <span class="hljs-variable">%.yield2</span><span class="hljs-punctuation">,</span> label <span class="hljs-variable">%.yield3</span><span class="hljs-punctuation">,</span> label <span class="hljs-variable">%.done</span> ]<br><br>.yield<span class="hljs-number">1</span>:<br>    <span class="hljs-comment">; 将返回值保存在 foo_context.result 中 </span><br>    <span class="hljs-variable">%3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">getelementptr</span> <span class="hljs-variable">%foo_context</span>* <span class="hljs-variable">%context</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">store</span> <span class="hljs-type">i32</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span>* <span class="hljs-variable">%3</span><br><br>    <span class="hljs-comment">; 将 &#x27;block&#x27; 块的 index 保存在 foo_context.state 中 </span><br>    <span class="hljs-comment">; make &#x27;block&#x27; point to next block to execute</span><br>    <span class="hljs-variable">%4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">getelementptr</span> <span class="hljs-variable">%foo_context</span>* <span class="hljs-variable">%context</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">store</span> <span class="hljs-type">i8</span>* <span class="hljs-keyword">blockaddress</span>(<span class="hljs-title">@foo_yield</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%.yield2</span>)<span class="hljs-punctuation">,</span> <span class="hljs-type">i8</span>** <span class="hljs-variable">%4</span><br><br>    <span class="hljs-comment">; 返回</span><br>    <span class="hljs-keyword">ret</span> <span class="hljs-type">i1</span> <span class="hljs-number">1</span><br><br>.yield<span class="hljs-number">2</span>:<br>    <span class="hljs-comment">; 将返回值保存在 foo_context.result 中 </span><br>    <span class="hljs-variable">%5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">getelementptr</span> <span class="hljs-variable">%foo_context</span>* <span class="hljs-variable">%context</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">store</span> <span class="hljs-type">i32</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span>* <span class="hljs-variable">%5</span><br><br>    <span class="hljs-comment">; 将 &#x27;block&#x27; 块的 index 保存在 foo_context.state 中 </span><br>    <span class="hljs-variable">%6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">getelementptr</span> <span class="hljs-variable">%foo_context</span>* <span class="hljs-variable">%context</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">store</span> <span class="hljs-type">i8</span>* <span class="hljs-keyword">blockaddress</span>(<span class="hljs-title">@foo_yield</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%.yield3</span>)<span class="hljs-punctuation">,</span> <span class="hljs-type">i8</span>** <span class="hljs-variable">%6</span><br><br>    <span class="hljs-comment">; 返回</span><br>    <span class="hljs-keyword">ret</span> <span class="hljs-type">i1</span> <span class="hljs-number">1</span><br><br>.yield<span class="hljs-number">3</span>:<br>    <span class="hljs-comment">; 将返回值保存在 foo_context.result 中 </span><br>    <span class="hljs-variable">%7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">getelementptr</span> <span class="hljs-variable">%foo_context</span>* <span class="hljs-variable">%context</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">store</span> <span class="hljs-type">i32</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span>* <span class="hljs-variable">%7</span><br><br>    <span class="hljs-comment">; 将 &#x27;block&#x27; 块的 index 保存在 foo_context.state 中 </span><br>    <span class="hljs-variable">%8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">getelementptr</span> <span class="hljs-variable">%foo_context</span>* <span class="hljs-variable">%context</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">store</span> <span class="hljs-type">i8</span>* <span class="hljs-keyword">blockaddress</span>(<span class="hljs-title">@foo_yield</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%.done</span>)<span class="hljs-punctuation">,</span> <span class="hljs-type">i8</span>** <span class="hljs-variable">%8</span><br><br>    <span class="hljs-comment">; 返回</span><br>    <span class="hljs-keyword">ret</span> <span class="hljs-type">i1</span> <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">; 结束，返回默认值 0</span><br>.done:<br>    <span class="hljs-keyword">ret</span> <span class="hljs-type">i1</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-keyword">define</span> void <span class="hljs-title">@main</span>() <span class="hljs-keyword">nounwind</span> &#123;<br>    <span class="hljs-comment">; 为 generator 分配 context 空间</span><br>    <span class="hljs-variable">%context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">alloca</span> <span class="hljs-variable">%foo_context</span><br>    <span class="hljs-keyword">call</span> void <span class="hljs-title">@foo_setup</span>(<span class="hljs-variable">%foo_context</span>* <span class="hljs-variable">%context</span>)<br>    <span class="hljs-keyword">br</span> label <span class="hljs-variable">%.head</span><br><br>.head:<br>    <span class="hljs-comment">; 每次调用，都需要传入 context 参数</span><br>    <span class="hljs-comment">; foreach (int i in foo())</span><br>    <span class="hljs-variable">%1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">call</span> <span class="hljs-type">i1</span> <span class="hljs-title">@foo_yield</span>(<span class="hljs-variable">%foo_context</span>* <span class="hljs-variable">%context</span>)<br><br>    <span class="hljs-comment">; 省略 ...</span><br><br>.<span class="hljs-keyword">tail</span>:<br>    <span class="hljs-keyword">ret</span> void<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的 generator 中，实际上没有保存什么局部变量，但是如果 generator 中存在跨越 yield 的局部变量，就需要将这些内容保存到 context 的某个字段中，这里不过多演示。</p><h2 id="2-Rust-实现"><a href="#2-Rust-实现" class="headerlink" title="2. Rust 实现"></a>2. Rust 实现</h2><p>虽然 Rust 底层依赖于 LLVM，LLVM 也提供了 generator 的能力，但 Rust 单独实现了一套类似的 generator。实际上 generator 也不算太难，简单来说，等同于一个闭包，只不过这个闭包不是一次性执行完成，而是分为多个阶段，每一个阶段都会对应一个状态，状态之间会进行转移。That’s all！</p><p>下面主要会借助 Generator 和 Yield，探讨一下<strong>目前</strong> async/await 实现的底层原理。</p><h3 id="2-1-Yield-amp-Generator"><a href="#2-1-Yield-amp-Generator" class="headerlink" title="2.1 Yield &amp; Generator"></a>2.1 Yield &amp; Generator</h3><p>首先来看一个 yield 关键字的 demo。</p><p>由于迭代器是一个实验性质的特性，因此要打开 <code>generators,generator_trait</code> 这两个 feature。 在我们的代码中，可以通过 yield + 闭包来声明 Generator。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![feature(generators, generator_trait)]</span><br><br><span class="hljs-keyword">use</span> std::ops::&#123;Generator, GeneratorState&#125;;<br><span class="hljs-keyword">use</span> std::pin::Pin;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> g = || &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;foo&quot;</span><br>  &#125;;<br><br>  <span class="hljs-built_in">assert_eq!</span>(Pin::new(&amp;<span class="hljs-keyword">mut</span> g).resume(()), GeneratorState::Yielded(<span class="hljs-number">1</span>));<br>  <span class="hljs-built_in">assert_eq!</span>(Pin::new(&amp;<span class="hljs-keyword">mut</span> g).resume(()), GeneratorState::Complete(<span class="hljs-string">&quot;foo&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>之所以用闭包实现，按照 LLVM 的实现机制以及上面的一小段简介，不难推断出原因：没错，需要保存上下文状态信息！那么，现在最重要的问题就是，这个上下文究竟是怎么保存的？编译器在背后究竟做了什么<strong>黑魔法</strong>？</p><p>就像 <code>Future</code> 的核心是 <code>Future trait</code>，<code>Generator</code> 的核心是 <code>Generator trait</code>，我们先来看一下这几个 trait 的定义。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]</span><br><span class="hljs-meta">#[lang = <span class="hljs-meta-string">&quot;generator_state&quot;</span>]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">GeneratorState</span></span>&lt;Y, R&gt; &#123;<br>    Yielded(Y),<br>    Complete(R),<br>&#125;<br><br><span class="hljs-meta">#[lang = <span class="hljs-meta-string">&quot;generator&quot;</span>]</span><br><span class="hljs-meta">#[fundamental]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Generator</span></span>&lt;R = ()&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Yield</span></span>;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Return</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">resume</span></span>(<span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, arg: R) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单和 <code>Future trait</code> 进行一下对比:</p><ol><li>Future只有一个类型参数 Output，表示最终返回的结果，Poll 其实就相当于 Option；Generator 有两个类型参数 Yield 和 Return，可以在返回零次或多次 Yield 后最终返回Return，GeneratorState 其实就相当于 Result;</li><li>Future 的 poll 中有一个额外参数 ctx，一般是用来注册回调的；Generator 的 resume 中有一个额外参数 arg，也就是每次进入的时候都可以传一个参数，默认为 <code>()</code>，我理解是赋予了这个 Generator 扩展的能力。</li></ol><p><code>Generator trait</code> 在 99% 的情况下，不需要我们手动实现，而是编译器帮助我们生成：</p><p>参照 LLVM 的实现机制，对程序做控制流分析，将整个 generator 视为一个状态机，根据 <code>yield, return</code> 这两个关键字划分为多个子代码块。在 LLVM 中，实际上是通过一个指针保存了每次 resume 需要跳转的位置，但有一个更加优雅的方式：<strong>enum + match</strong>。</p><p>用一个 enum 保存每一个代码块执行中的状态，每次 yield 或者 return 之前，会将这段子代码块中的所有指令<strong>全部</strong>执行完成，然后修改 enum 中保存的状态，也就是<strong>状态转移</strong>，以及上下文中的局部变量，也都被捕获进来。</p><p>每一次 resume，其实就是需要匹配 enum 中的状态，去执行对应部分的代码，最后修改状态，是状态转移，直到返回 Complete。</p><p>按照这种思路，可以将上面 main 函数的闭包，翻译为下面的结构。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![feature(arbitrary_self_types, generators, generator_trait)]</span><br><br><span class="hljs-keyword">use</span> std::ops::&#123;Generator, GeneratorState&#125;;<br><span class="hljs-keyword">use</span> std::pin::Pin;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> ret = <span class="hljs-string">&quot;foo&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> generator = &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">__Generator</span></span> &#123;<br>            Start(&amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>),<br>            Yield1(&amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>),<br>            Done,<br>        &#125;<br><br>        <span class="hljs-keyword">impl</span> Generator <span class="hljs-keyword">for</span> __Generator &#123;<br>            <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Yield</span></span> = <span class="hljs-built_in">i32</span>;<br>            <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Return</span></span> = &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>;<br><br>            <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">resume</span></span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, resume: ()) -&gt; GeneratorState&lt;<span class="hljs-built_in">i32</span>, &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>&gt; &#123;<br>                <span class="hljs-keyword">use</span> std::mem;<br>                <span class="hljs-keyword">match</span> mem::replace(&amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span>, __Generator::Done) &#123;<br>                    __Generator::Start(s) =&gt; &#123;<br>                        *<span class="hljs-keyword">self</span> = __Generator::Yield1(s);<br>                        GeneratorState::Yielded(<span class="hljs-number">1</span>)<br>                    &#125;<br><br>                    __Generator::Yield1(s) =&gt; &#123;<br>                        *<span class="hljs-keyword">self</span> = __Generator::Done;<br>                        GeneratorState::Complete(s)<br>                    &#125;<br><br>                    __Generator::Done =&gt; &#123;<br>                        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;generator resumed after completion&quot;</span>)<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        __Generator::Start(ret)<br>    &#125;;<br><br>    Pin::new(&amp;<span class="hljs-keyword">mut</span> generator).resume(());<br>    Pin::new(&amp;<span class="hljs-keyword">mut</span> generator).resume(());<br>&#125;<br></code></pre></td></tr></table></figure><p><code>enum __Generator</code>   就是生成的匿名结构，编译器会为其实现  Generate trait，就是上面分析所说的状态机核心逻辑。</p><p>总的来说，就是通过 <strong>闭包 + 状态机</strong>，实现了整个 Generator。</p><p>有了 Generator 的基础，再去看 async/await 的实现，就会轻松不少。我们只需要去关心，究竟是如何将 async/await 转换成闭包，并且用 <strong>状态匹配 + 状态转移</strong> 的方式去驱动执行。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">Tips:</span><br>  需要提示一点，generator 在 Rust 中仍然是实验性的功能，只不过目前的 <span class="hljs-keyword">async</span>/<span class="hljs-built_in">await</span> 底层是借助了这一点来实现，未来不保证会不会修  改为别的方案，因为自引用结构的确有一些 annoying<br></code></pre></td></tr></table></figure><h3 id="2-2-HIR-amp-MIR"><a href="#2-2-HIR-amp-MIR" class="headerlink" title="2.2 HIR &amp; MIR"></a>2.2 HIR &amp; MIR</h3><p>Rust 针对 async/await 的处理，主要分为 HIR 和 MIR 两个阶段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Tips:<br>    Rust 面向 LLVM 编程，但是 rustc 编译器也做了非常多的优化，将其划分为 HIR，MIR <br>    <br>    1. HIR. 全称是 <span class="hljs-string">&quot;high-level (H) intermediate representation (IR)&quot;</span>，可以将其理解为 AST 的另一中表示方式，主要是将语法糖  做了转换。<br><br>    2. MIR. The <span class="hljs-string">&quot;mid-level (M) intermediate representation (IR)&quot;</span>。HIR 的简化版本，将高级的表达形式，转换成更加低级的结   构。rust 中的生命周期在这里会被抹除。<br><br>    3. LIR. Rust 中相当于 LLVM-IR。<span class="hljs-string">&quot;low-level (L) intermediate representation (IR)&quot;</span> 是一种非常接近机器码的表示方式，会  对 MIR 做进一步的精简。<br></code></pre></td></tr></table></figure><h4 id="2-2-1-HIR"><a href="#2-2-1-HIR" class="headerlink" title="2.2.1 HIR"></a>2.2.1 HIR</h4><p>在 HIR 中，其实是针对 <code>async fn test(f: F) where F:Future &#123; f.await &#125;</code> 做了脱糖处理。</p><p>比如，在 HIR 的表达式解析模块中，会将 async 代码块构造为一个实现了 future trait 的 generator：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::future::from_generator(<span class="hljs-keyword">static</span> <span class="hljs-keyword">move</span>? |_task_context| -&gt; &lt;ret_ty&gt; &#123;<br>    &lt;body&gt;<br>&#125;)<br></code></pre></td></tr></table></figure><p>会将 <code>&lt;expr&gt;.await</code> desugar 变为一个 <code>loop + match</code>。如果返回 Pending，下一句将会执行 <code>yield</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> &lt;expr&gt; &#123;<br>    <span class="hljs-keyword">mut</span> pinned =&gt; <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">unsafe</span> &#123; ::std::future::Future::poll(<br>            &lt;::std::pin::Pin&gt;::new_unchecked(&amp;<span class="hljs-keyword">mut</span> pinned),<br>            ::std::future::get_context(task_context),<br>        ) &#125; &#123;<br>            ::std::task::Poll::Ready(result) =&gt; <span class="hljs-keyword">break</span> result,<br>            ::std::task::Poll::Pending =&gt; &#123;&#125;<br>        &#125;<br>        task_context = <span class="hljs-keyword">yield</span> ();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，会将 async 代码块翻译为 <code>from_generator</code> 生成的匿名结构体，这个结构体由编译器实现 Future trait。</p><p>你可能会好奇，GeneratorState 和 Poll 并<strong>不兼容</strong>啊，前者返回 GeneratorState，后者返回 Poll，这是为什么呢？别担心，在 GeFuture::poll 函数中，特别做了处理：</p><p>GenFuture 包装了一个 Generator 的时候，GenFuture::poll 其实会调用内部的 generator 的 resume 方法，返回的 Yield 对应 Pending，Complete 对应 Ready。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GenFuture</span></span>&lt;T: Generator&lt;Yield = ()&gt;&gt;(T);<br><br><span class="hljs-keyword">impl</span>&lt;T: Generator&lt;Yield = ()&gt;&gt; !Unpin <span class="hljs-keyword">for</span> GenFuture&lt;T&gt; &#123;&#125;<br><br><span class="hljs-meta">#[unstable(feature = <span class="hljs-meta-string">&quot;gen_future&quot;</span>, issue = <span class="hljs-meta-string">&quot;50547&quot;</span>)]</span><br><span class="hljs-keyword">impl</span>&lt;T: Generator&lt;Yield = ()&gt;&gt; Future <span class="hljs-keyword">for</span> GenFuture&lt;T&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = T::Return;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll</span></span>(<span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;<br>        <span class="hljs-comment">// Safe because we&#x27;re !Unpin + !Drop mapping to a ?Unpin value</span><br>        <span class="hljs-keyword">let</span> gen = <span class="hljs-keyword">unsafe</span> &#123; Pin::map_unchecked_mut(<span class="hljs-keyword">self</span>, |s| &amp;<span class="hljs-keyword">mut</span> s.<span class="hljs-number">0</span>) &#125;;<br>        set_task_context(cx, || <span class="hljs-keyword">match</span> gen.resume() &#123;<br>            GeneratorState::Yielded(()) =&gt; Poll::Pending,<br>            GeneratorState::Complete(x) =&gt; Poll::Ready(x),<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from_generator</span></span>&lt;T: Generator&lt;Yield = ()&gt;&gt;(x: T) -&gt; <span class="hljs-keyword">impl</span> Future&lt;Output = T::Return&gt; &#123;<br>    GenFuture(x)<br>&#125;<br></code></pre></td></tr></table></figure><p>这一部分源码在 <a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_ast_lowering/src/expr.rs">rust expr code</a>，<a href="https://doc.bccnsoft.com/docs/rust-1.36.0-docs-html/src/std/future.rs.html#20-22">GenFuture code</a> 中可以找到，</p><p>到这一步为止，HIR 对于 async 代码块的处理就完成了，接下来是最重要的 MIR 处理。</p><h4 id="2-2-2-MIR"><a href="#2-2-2-MIR" class="headerlink" title="2.2.2 MIR"></a>2.2.2 MIR</h4><p>MIR 中有一个 <a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_mir_transform/src/generator.rs">transform</a> 模块专门做了这件事情。</p><p>其实主要的处理逻辑我们已经看过了，就是将 yield 转换成匿名 enum，并插入多个 yield point即可。这里并不过多展开。</p>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
      <category>async</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>linux tracing</title>
    <link href="/2021/11/23/linux/tracing/index/"/>
    <url>/2021/11/23/linux/tracing/index/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Summerize"><a href="#1-Summerize" class="headerlink" title="1. Summerize"></a>1. Summerize</h2><p>Linux 中的 tracing 机制非常丰富，比如最火热的 ebpf，还有老牌的 perf，systemtap，kprobe，tracepoint，uprobe，usdt，bcc，ftrace，这些花样繁多的手段，其实都可以完成一定程度上的 tracing 功能，但是也给我们带来了幸福的烦恼：选择困难！</p><p>看上去每一种方式都可以解决一定的问题，他们之间还有很多功能重叠的地方，如果不将各自的职责做一个详细的划分，就无法做到因地制宜地分析性能瓶颈。</p><p>首先要明确一点，tracing 机制和操作系统息息相关，Linux 内核中广发采用的事件通知机制，也在整个 tracing 系统中得到了广泛引用。</p><p>针对 tracing 这个场景，一般来说需要几个角色：</p><ol><li>Data source mechanism         – 数据源</li><li>Data-collecting mechanism    – 数据收集机制</li><li>visualize tools                            – 可视化机制</li></ol><p>接下来就一一探究各个 tracing 功能分别对应哪个角色。</p><h2 id="2-Data-source"><a href="#2-Data-source" class="headerlink" title="2. Data source"></a>2. Data source</h2><p>Data source 是真正产生 tracing 事件的底层机制。</p><p>不管 tracing 在外界看来有多透明，对于 CPU 而言，也仅仅是执行一段代码而已，或是调用了特定的函数，或有一些特殊的异常执行流，但不可能超出<code>instruction</code> 这个范畴。</p><p>如果你之前修改并编译过 kernel 代码，一定会感觉这个过程无比繁琐：定位一个问题，可能要反反复复很多次，最后甚至还无法定位问题所在。但很多人不知道的是， kernel 早就为提供了“<strong>无需编译，直接插入逻辑，甚至是热更新</strong>”的强大功能：</p><ul><li>静态打桩 tracepoint</li><li>动态打桩 kprobe/kretprobe</li></ul><p>用户态程序，实际上也在内核的掌控之中，因此也有相似的两种机制：</p><ul><li>静态打桩 USDT</li><li>动态打桩 uprobe/uretprobe</li></ul><p>更往底层来说，kernel还支持收集硬件的程序计数器 performance monitor counter (PMU)，提供更加精细的采样数据。</p><p>这些都是<strong>事件源</strong>，离开了事件源，其余的都无从谈起。</p><h3 id="2-1-静态打桩"><a href="#2-1-静态打桩" class="headerlink" title="2.1 静态打桩"></a>2.1 静态打桩</h3><p>之所以说是静态，是因为打桩点已经编译到二进制可执行文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">Tips<br><br>打桩实现是基于 hooks 的思想，在代码中提前做了插桩，代码运行到跟踪点（桩）上注册了钩子函数（hook），那么就会执行钩子函数达到调试的目的<br><br></code></pre></td></tr></table></figure><p>kernel 中的静态打桩点也被称为 tracepoint，有专门的开发人员维护，一般不会变动，非常稳定。内核可以通过 enable &amp; disable 的方式打开或者关闭 tracepoint，在 off 状态下，几乎没有开销，只有一个分支判断加上几条指令的 penalty，近乎于 zero-cost，只有在打开的时候，用户提供给内核的函数才会被执行。</p><p>最常用的 tracepoint 就是系统调用了，syscall 都实现了对应的 tracepoint，开启这些探测点，就能知道系统调用的执行情况</p><p>类似tracepoint，用户程序也可以自己维护一套静态，稳定的打桩点，这被称为 user statically defined tracing (USDT)。USDT 其实是从Dtrace 中引入的设计思路，自从 Dtrace 出现之后，各种各样的应用都会在程序的关键位置加入 USDT，从而暴露 probe 的能力。</p><h3 id="2-2-动态打桩"><a href="#2-2-动态打桩" class="headerlink" title="2.2 动态打桩"></a>2.2 动态打桩</h3><p>kprobe 是另外一种基于打桩机制实现的调试手法。kprobes的底层原理是：在程序运行的过程当中，动态修改内存中的指令，触发 int3 异常，再调用注册的 hook 函数执行，最后恢复原先的指令。因为可以在运行期间动态修改指令，赋予了kprobe极大的灵活性，几乎可以运用在任何地方。</p><p>但是，一定要铭记一点：计算机科学中<strong>没有银弹</strong>。kprobes 非常强大，也非常灵活，随之而来的代价是性能上的开销。因为每一次kprobe 会触发两次指令执行异常，并且，如果 kprobe attach 的函数发生了变动（比如函数名更改），该 probe 就会失效，没有tracepoint 那种稳定性保证。</p><p>uprobe 和 kprobe 原理类似，主要是用来追踪用户态程序，比如 malloc 这种容易发生问题的用户态底层组件。</p><p>至于 kretprobe 和  uretprobe，其实功能也比较类似，依赖于 kprobe(uprobe)，通过 trampoline 跳板代码，可让用户可以在某一个函数执行的首尾分别执行 pre-handler &amp; post-hander，达到了对于某一个函数 probe 的效果，可以方便地统计函数执行时长等情况。</p><h2 id="3-Collecing-mechanisms"><a href="#3-Collecing-mechanisms" class="headerlink" title="3. Collecing mechanisms"></a>3. Collecing mechanisms</h2><p>数据源的基本原理和大致划分已经看完了，并没有我们想象中那么复杂，无非划分为 动态/静态，用户态/内核态。接下来的数据收集机制才是 tracing system 的重中之重。</p><p>数据收集机制，顾名思义，是需要借助底层的 Data source，收集我们感兴趣的数据，才能进一步展示。</p><p>有了数据源做支撑，这里需要做的事情是：</p><ol><li>注册。告诉数据源，我们感兴趣的事件，请处理并将发送回来</li><li>收集。收集，通过某种交互方式，将内核收集到的内容传递到用户手中。</li></ol><p>接下来会对主流的 collecting mechanisms 做一个大致的对比</p><h3 id="3-1-ftrace"><a href="#3-1-ftrace" class="headerlink" title="3.1 ftrace"></a>3.1 ftrace</h3><p>ftrace 的原理是使用 gcc 编译器的 <code>-pg</code> 选项，达到在内核代码中插桩的目的。该选项会自动在函数的入口处加上对 mcount 的调用指令。这样每次进入一个函数时都可以调用对应的钩子函数来打印函数信息。事实上，对于 mcount 的函数调用，在 99%的情况下，都是无用的，也会对性能有极大的损耗，因此，默认情况下，在函数开头其实是插入了几条 nop 指令，运行期间，动态修改这个指令，就能达到 trace function call 的目的。</p><p>ftrace 通过 tracefs 文件系统和用户进行交互，tracefs 下面有很多特殊的文件，它们都注册了特定的 file_operations，写入操作大致相当于 <strong>读取指令 + 解析指令 + 执行</strong>，TODO!(读取操作…)。</p><h3 id="3-2-perf-events"><a href="#3-2-perf-events" class="headerlink" title="3.2 perf events"></a>3.2 perf events</h3><p>通过 perf_event_open 系统调用，在用户空间创建了一块ringbuf，内核将收集到的数据写入这块共享内存中，就完成了user-kernel的数据传输</p><h3 id="3-3-systemp-Tap"><a href="#3-3-systemp-Tap" class="headerlink" title="3.3 systemp Tap"></a>3.3 systemp Tap</h3><p>systemtap 在 kprobe 的基础上，加上脚本解析和内核模块编译运行单元，使开发人员在应用层即可实现 hook 内核，大大简化了开发流程。 工作原理是通过将脚本语句翻译成 C语句，编译成内核模块。 模块加载之后，将所有探测的事件以钩子的方式挂到内核上，当任何处理器上的某个事件发生时，相应钩子上的句柄就会被执行。</p><h3 id="3-4-eBPF"><a href="#3-4-eBPF" class="headerlink" title="3.4 eBPF"></a>3.4 eBPF</h3><p>eBPF 给Linux注入了超能力！内核为eBPF提供了一个虚拟机，可以运行特定格式的代码，并且有各种各样的 hook 点，而且可以借助kprobe，tracepoint，uprobe，USDT 中的任何一种底层机制来收集想要的数据，修改程序中的指令路径，简直无所不能。这一切功能，甚至建立在无需改动内核代码的基础之上，和 Linux 你中有我，我中有你（不是）。</p><h2 id="4-Front-end"><a href="#4-Front-end" class="headerlink" title="4. Front-end"></a>4. Front-end</h2><h3 id="4-1-perf"><a href="#4-1-perf" class="headerlink" title="4.1 perf"></a>4.1 perf</h3><p>perf trace 是跟踪syscall的非常棒的工具，perf record | report | bench | top | probe 也是非常好用的指令，实用且易于上手。</p><h3 id="4-2-trace-cmd-amp-kernelshark"><a href="#4-2-trace-cmd-amp-kernelshark" class="headerlink" title="4.2 trace-cmd &amp; kernelshark"></a>4.2 trace-cmd &amp; kernelshark</h3><p>ftrace作为老牌tracing工具，在前端方面肯定是少不了的。比如trace-cmd，kernelshark，perf都集成了ftrace的功能。</p><p>trace-cmd 非常值得一提，我经常用它来看内核中函数的执行路径，比如执行 show 指令，就可以清晰地看到当前kernel正在执行的函数调用关系，再去对照源码查看，会节省不少工夫。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C">$ trace-cmd show | head <span class="hljs-number">-20</span><br><br>#<span class="hljs-meta"># tracer: function_graph</span><br>#<br># CPU  DURATION                  FUNCTION CALLS<br># |     |   |                     |   |   |   |<br> <span class="hljs-number">6</span>)               |        __fget_light() &#123;<br> <span class="hljs-number">6</span>)   <span class="hljs-number">0.804</span> us    |          __fget_files();<br> <span class="hljs-number">6</span>)   <span class="hljs-number">2.708</span> us    |        &#125;<br> <span class="hljs-number">6</span>)   <span class="hljs-number">3.650</span> us    |      &#125; <span class="hljs-comment">/* __fdget */</span><br> <span class="hljs-number">6</span>)   <span class="hljs-number">0.547</span> us    |      eventfd_poll();<br> <span class="hljs-number">6</span>)   <span class="hljs-number">0.535</span> us    |      fput();<br> <span class="hljs-number">6</span>)               |      __fdget() &#123;<br> <span class="hljs-number">6</span>)               |        __fget_light() &#123;<br> <span class="hljs-number">6</span>)   <span class="hljs-number">0.946</span> us    |          __fget_files();<br> <span class="hljs-number">6</span>)   <span class="hljs-number">1.895</span> us    |        &#125;<br> <span class="hljs-number">6</span>)   <span class="hljs-number">2.849</span> us    |      &#125;<br> <span class="hljs-number">6</span>)               |      sock_poll() &#123;<br> <span class="hljs-number">6</span>)   <span class="hljs-number">0.651</span> us    |        unix_poll();<br> <span class="hljs-number">6</span>)   <span class="hljs-number">1.905</span> us    |      &#125;<br> <span class="hljs-number">6</span>)   <span class="hljs-number">0.475</span> us    |      fput();<br> <span class="hljs-number">6</span>)               |      __fdget() &#123;<br></code></pre></td></tr></table></figure><p>但是不管再怎么fancy，trace-cmd 也无法离开ftrace单独使用，其主要依赖的就是通过 debugfs和内核中的ftrace进行交互。</p><p>kernelshark 我没有使用过，不过看上去功能也非常丰富，可以更好地可视化展现出来，而不像trace-cmd那样仅仅输出在命令行中。</p><h3 id="4-3-bcc-amp-bpftrace"><a href="#4-3-bcc-amp-bpftrace" class="headerlink" title="4.3 bcc &amp; bpftrace"></a>4.3 bcc &amp; bpftrace</h3><p>eBPF在 collecting mechanisim 这个层面已经做到了顶级，其前端工具也没有令我们失望。iovisor这个项目也做了很多贡献，通过bcc，bpftrace两这个工具，利用脚本<strong>定制化</strong>输出的方式和内容，极大提高了开发者体验，也有很多开箱即用的功能脚本，并且仍在不断扩充当中。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>trace</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
